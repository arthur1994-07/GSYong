#include "stdafx.h"
#include "CustomDrawHelper.h"
#include "GradientUtil.h"

CCustomDrawHelper::CCustomDrawHelper()
	: m_bWndHasFocus(false)
	, m_bFocusItem(false)
	, m_bSelected(false)
	, m_bIsHotItem(false)
	, m_bDrawBorderWhenFill(true)
	, m_bIsPressed(false)
	, m_bWndEnabled(true)
	, m_rcBounds(0,0,0,0)
	, m_hWnd(NULL)
{

}

CCustomDrawHelper::~CCustomDrawHelper()
{
	
}

/*
	Different cases with different colors:
					wnd has focus							 				  wnd has no focus
           +--------------------------------+                          +-------------------------+
		selected					 	unselected					selected				 	unselected
     +---------------+               +------------+              +-------------+            +---------+
	hot		      not hot			hot		   not hot			hot		 	not hot		   hot	   not hot
     1           +--------+          3            x              1             4            3         x
	 		  focus   no focus
				1		2
*/

// TODO: The colors can be generated by some kind of algorithm so that the the caller can control the main color.
// e.g. With given color (like sky-blue), all the other colors can be generated by reducing/increasing its luminosity,
// so RGB2HSL and HSL2RGB will be needed in that case. However, the difficult part is how to design the rule, which I
// do not have time by now, so I just use hard coded value here.
void CCustomDrawHelper::DrawItemBackground( CDC* pDC, CRect rect, BYTE byAlpha )
{
	if ( ShouldFillBackground() )
	{
		COLORREF clrFillColor1;
		COLORREF clrFillColor2;

		if ( m_bSelected )
		{
			if ( m_bIsHotItem || (m_bFocusItem && m_bWndHasFocus) )
			{
				clrFillColor1	= RGB_ITEM_SELFOCUS_FILL_COLOR1;
				clrFillColor2	= RGB_ITEM_SELFOCUS_FILL_COLOR2;
			}
			else if ( m_bWndHasFocus )
			{
				ASSERT( !m_bFocusItem );
				clrFillColor1	= RGB_ITEM_SELECTED_FILL_COLOR1;
				clrFillColor2	= RGB_ITEM_SELECTED_FILL_COLOR2;
			}
			else
			{
				clrFillColor1	= RGB_ITEM_SELNOFOCUS_FILL_COLOR1;
				clrFillColor2	= RGB_ITEM_SELNOFOCUS_FILL_COLOR2;
			}
		}
		else
		{
			// not selected, hot item
			clrFillColor1 = RGB_ITEM_HOT_FILL_COLOR1;
			clrFillColor2 = RGB_ITEM_HOT_FILL_COLOR2;
		}

		if ( m_bDrawBorderWhenFill )
		{
			COLORREF clrInnerBorder;
			COLORREF clrOuterBorder;
			if ( m_bSelected )
			{
				clrInnerBorder = (m_bWndHasFocus || m_bIsHotItem) ? RGB_ITEM_SELFOCUS_INNER_BORDER_COLOR : RGB_ITEM_SELNOFOCUS_INNER_BORDER_COLOR;
				clrOuterBorder = (m_bWndHasFocus || m_bIsHotItem) ? RGB_ITEM_SELFOCUS_OUTER_BORDER_COLOR : RGB_ITEM_SELNOFOCUS_OUTER_BORDER_COLOR;
			}
			else
			{
				clrInnerBorder = RGB_ITEM_HOT_INNER_BORDER_COLOR;
				clrOuterBorder = RGB_ITEM_HOT_OUTER_BORDER_COLOR;
			}
			DrawRoundRectItem(pDC, rect, clrFillColor1, clrFillColor2, clrInnerBorder, clrOuterBorder, byAlpha);
		}
		else
		{
			rect.DeflateRect(2, 2);
			FillGradient(pDC->GetSafeHdc(), rect, clrFillColor1, clrFillColor2, GFT_TOP_BOTTOM, byAlpha);
		}
	}
	else if ( m_bFocusItem )
	{
		CRect& rcItem = m_rcBounds.IsRectEmpty() ? rect : m_rcBounds;
		DrawFocus(pDC, rcItem, byAlpha);
	}
}

void CCustomDrawHelper::DrawFocus( CDC* pDC, CRect rect, BYTE byAlpha )
{
	ASSERT( !ShouldFillBackground() && m_bFocusItem );
	DrawSimpleRoundRectBorder(pDC, rect, RGB_ITEM_SELFOCUS_OUTER_BORDER_COLOR);
}