#include "pch.h"

#include "NSMaterialManager.h"

// ----------------------------------------------------------------------------
#include "../../SigmaCore/DebugInclude.h"
// ----------------------------------------------------------------------------

namespace NSMaterialManager
{
	void SetLightMapMaterial_PS30_Shading( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWorld; \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4x4 g_matShadow_PL1; \r\n"
			"float4x4 g_matShadow_PL2; \r\n"
			"float4   g_vPos_Range_CL_TOOL[2]; \r\n"
			"float4   g_vDiff_CosPhiHalf_CL_TOOL[2]; \r\n"
			"float4   g_vAtt_CosHalfThetaSubPhi_CL_TOOL[2]; \r\n"
			"float4   g_vDirect_Falloff_CL_TOOL[2]; \r\n"
			"float    g_fSpotShadowLightAlpha1; \r\n"
			"float    g_fSpotShadowLightAlpha2; \r\n"
			"float    g_fAttEndLineValue1 = 1.f; \r\n"
			"float    g_fAttEndLineValue2 = 1.f; \r\n"
			"float    g_fOverLighting1 = 2.f; \r\n"
			"float    g_fOverLighting2 = 2.f; \r\n"
			"float4   g_vWindowSize; \r\n"
			"float    g_fAlpha; \r\n"
			"float2   g_vLightMapUV_Offset; \r\n"
			"float2   g_vLightMapUV_Multiply; \r\n"
			"float3	  g_vVoxelColor; \r\n"
			" \r\n"
			"texture g_BackBufferTexture_2nd; \r\n"
			"sampler BackBufferSampler_2nd = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BackBufferTexture_2nd); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_BackBufferTexture_3rd; \r\n"
			"sampler BackBufferSampler_3rd = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BackBufferTexture_3rd); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_LightMapTex_DS_1st; \r\n"
			"sampler LightMapTexSampler_DS_1st = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_LightMapTex_DS_1st); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_LightMapTex_DS_2nd; \r\n"
			"sampler LightMapTexSampler_DS_2nd = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_LightMapTex_DS_2nd); \r\n"
			"}; \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_INPUT			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"   float3 m_vNormal		: NORMAL; \r\n"
			"	float4 m_vAlbedoXY_LMZW	: TEXCOORD0;	// 합쳐진 것을 사용할 경우 m_vAlbedoXY_LMZW 를 사용합니다. \r\n"
			"	// m_vLightmapUV 이름이 있으면, LightMap을 생성해준다. \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"struct VS_OUTPUT_LBUFFER		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition				: POSITION; \r\n"
			"	float2 m_vTexCoord0				: TEXCOORD0; \r\n"
			"	float3 m_vPosLight				: TEXCOORD1; \r\n"	// Albedo 좌표를 얻기 위함.
			"	float2 m_vLightmapUV			: TEXCOORD2; \r\n"
			"	float3 m_vPosViewSpace			: TEXCOORD3; \r\n"
			"   float3 m_vHalfSpot1				: TEXCOORD4; \r\n"
			"   float3 m_vHalfSpot2				: TEXCOORD5; \r\n"
			"}; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.3.0 LBUFFER \r\n"
			"VS_OUTPUT_LBUFFER VS_L_3( VS_INPUT In, uniform int nPL1, uniform int nPL2 )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_LBUFFER Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	Out.m_vPosViewSpace = mul(g_matWV, In.m_vPosition); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vAlbedoXY_LMZW.xy; \r\n"
			"	Out.m_vLightmapUV = In.m_vAlbedoXY_LMZW.zw; \r\n"
			"	Out.m_vLightmapUV += g_vLightMapUV_Offset; \r\n"
			" \r\n"
			"	// Transform the position to light projection space, or the \r\n"
			"	// projection space as if the camera is looking out from \r\n"
			"	// the spotlight. \r\n"
			"	// \r\n"
			"	Out.m_vPosLight.xyz = Out.m_vPosition.xyw; \r\n"
			" \r\n"
			"   Out.m_vHalfSpot1 = float3(0.f,0.f,0.f); \r\n"
			"   Out.m_vHalfSpot2 = float3(0.f,0.f,0.f); \r\n"
			" \r\n"
			"	if ( nPL1==2 ) \r\n"
			"	{ \r\n"
			"		// HalfVector \r\n"
			"		float3 vHalf = -Out.m_vPosViewSpace.xyz; \r\n"
			"		vHalf = normalize( vHalf ); \r\n"
			"		vHalf += normalize( g_vPos_Range_CL_TOOL[0].xyz - Out.m_vPosViewSpace.xyz );; \r\n"
			"		Out.m_vHalfSpot1 = normalize( vHalf ); \r\n"
			"	} \r\n"
			"	if ( nPL2==2 ) \r\n"
			"	{ \r\n"
			"		// HalfVector \r\n"
			"		float3 vHalf = -Out.m_vPosViewSpace.xyz; \r\n"
			"		vHalf = normalize( vHalf ); \r\n"
			"		vHalf += normalize( g_vPos_Range_CL_TOOL[1].xyz - Out.m_vPosViewSpace.xyz );; \r\n"
			"		Out.m_vHalfSpot2 = normalize( vHalf ); \r\n"
			"	} \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_L_3( VS_OUTPUT_LBUFFER In, uniform int nPL1, uniform int nPL2, uniform bool bAlphaTex ) : COLOR0 \r\n"
			"{ \r\n"
			"	float4 vOut=1.f; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = 1.f; \r\n"
			"	if ( bAlphaTex ) \r\n"
			"	{ \r\n"
			"		vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			"	} \r\n"
			" \r\n"
			"	//transform from RT space to texture space. \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosLight.xy / In.m_vPosLight.z + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	// Normal Vector 얻기. \r\n"
			"	float3 vNor = tex2D( BackBufferSampler_2nd, vProjTex ); \r\n"
			"	vNor = normalize( vNor ); \r\n"
			" \r\n"
			"	// Specular, CubeMap Factor 얻기. \r\n"
			"	float3 vSpecularCubemap = tex2D( BackBufferSampler_3rd, vProjTex ).xyz; \r\n"
			"	vSpecularCubemap.x *= 2.f; \r\n"
			"	vSpecularCubemap.y *= 256.f; \r\n"
			" \r\n"
			"	// 라이트맵  \r\n"
			"   float4 vLightMap_DS_1st = tex2D( LightMapTexSampler_DS_1st, In.m_vLightmapUV ); \r\n"
			"   float4 vLightMap_DS_2nd = tex2D( LightMapTexSampler_DS_2nd, In.m_vLightmapUV ); \r\n"
			" \r\n"
			"	float3 vAddColor = 0.f; \r\n"
			"	if ( nPL1==2 ) \r\n"
			"	{ \r\n"
			"		float fLightAmount = vLightMap_DS_1st.z; \r\n"
			"		fLightAmount *= vLightMap_DS_1st.x*3.f;  \r\n"
			"		float vLightAmountNEW = 1.f;  \r\n"
			"		{ \r\n"
			"			int i=0; \r\n"
			"			float3 afPosDir = g_vPos_Range_CL_TOOL[i].xyz - In.m_vPosViewSpace; \r\n"
			"			float fLength = length( afPosDir ); \r\n"
			"			// 내적 구함. \r\n"
			"			afPosDir = normalize( afPosDir ); \r\n"
			"			float fDotPL = saturate( dot( afPosDir, vNor ) ); \r\n"
			"			// 선형 감쇠, 2차 감쇠, 지수 감쇠 적용 \r\n"
			"			float fAttenuationSub = g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].x; \r\n"
			"			fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].y * fLength; \r\n"
			"			fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].z * fLength * fLength; \r\n"
			"			// 최종 감쇠값 \r\n"
			"			float fAttenuation = 1.f / fAttenuationSub; \r\n"
			"			// 거리 체크 \r\n"
			"			float fEnableLength = step(fLength, g_vPos_Range_CL_TOOL[i].w); \r\n"
			"		\r\n"
			"			//Cone쪽 계산 \r\n"
			"			 float3 fRho = dot(afPosDir,g_vDirect_Falloff_CL_TOOL[i].xyz); \r\n"
			"			fEnableLength *= step(g_vDiff_CosPhiHalf_CL_TOOL[i].w, fRho); \r\n"
			"			fEnableLength *= pow( (fRho - g_vDiff_CosPhiHalf_CL_TOOL[i].w) / g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].w, g_vDirect_Falloff_CL_TOOL[i].w ); \r\n"
			"			fEnableLength = min(1.f,fEnableLength); \r\n"
			"		\r\n"
			"			// 마지막 \r\n"
			"			float fSpec = pow( saturate( dot( normalize(In.m_vHalfSpot1), vNor ) ), vSpecularCubemap.y) * vSpecularCubemap.x; \r\n"
			"		\r\n"
			"			// Edge 부분이 저 감쇠만으로는 적용이 안되서 1 를 빼주었다. \r\n"
			"			vLightAmountNEW *= max((fAttenuation-g_fAttEndLineValue1),0) * fEnableLength; \r\n"
			"			float vLightAmountDIFF = vLightAmountNEW * fDotPL; \r\n"
			"			float vLightAmountSPEC = vLightAmountNEW * fSpec; \r\n"
			"			vLightAmountNEW = min(vLightAmountDIFF,g_fOverLighting1); \r\n"
			"			vLightAmountNEW += min(vLightAmountSPEC,g_fOverLighting1); \r\n"
			"			vLightAmountNEW *= vLightMap_DS_1st.z; \r\n"
			"		} \r\n"
			"		fLightAmount = (fLightAmount * (1.f-g_fSpotShadowLightAlpha1)) + (vLightAmountNEW * g_fSpotShadowLightAlpha1); \r\n"
			"		vAddColor += g_vDiff_CosPhiHalf_CL_TOOL[0].xyz * fLightAmount; \r\n"
			"	} \r\n"
			"	if ( nPL2==2 ) \r\n"
			"	{ \r\n"
			"		float fLightAmount = vLightMap_DS_2nd.z; \r\n"
			"		fLightAmount *= vLightMap_DS_2nd.x*3.f;  \r\n"
			"		float vLightAmountNEW = 1.f;  \r\n"
			"		{ \r\n"
			"			int i=1; \r\n"
			"			float3 afPosDir = g_vPos_Range_CL_TOOL[i].xyz - In.m_vPosViewSpace; \r\n"
			"			float fLength = length( afPosDir ); \r\n"
			"			// 내적 구함. \r\n"
			"			afPosDir = normalize( afPosDir ); \r\n"
			"			float fDotPL = saturate( dot( afPosDir, vNor ) ); \r\n"
			"			// 선형 감쇠, 2차 감쇠, 지수 감쇠 적용 \r\n"
			"			float fAttenuationSub = g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].x; \r\n"
			"			fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].y * fLength; \r\n"
			"			fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].z * fLength * fLength; \r\n"
			"			// 최종 감쇠값 \r\n"
			"			float fAttenuation = 1.f / fAttenuationSub; \r\n"
			"			// 거리 체크 \r\n"
			"			float fEnableLength = step(fLength, g_vPos_Range_CL_TOOL[i].w); \r\n"
			"		\r\n"
			"			//Cone쪽 계산 \r\n"
			"			 float3 fRho = dot(afPosDir,g_vDirect_Falloff_CL_TOOL[i].xyz); \r\n"
			"			fEnableLength *= step(g_vDiff_CosPhiHalf_CL_TOOL[i].w, fRho); \r\n"
			"			fEnableLength *= pow( (fRho - g_vDiff_CosPhiHalf_CL_TOOL[i].w) / g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].w, g_vDirect_Falloff_CL_TOOL[i].w ); \r\n"
			"			fEnableLength = min(1.f,fEnableLength); \r\n"
			"		\r\n"
			"			// 마지막 \r\n"
			"			float fSpec = pow( saturate( dot( normalize(In.m_vHalfSpot2), vNor ) ), vSpecularCubemap.y) * vSpecularCubemap.x; \r\n"
			"		\r\n"
			"			// Edge 부분이 저 감쇠만으로는 적용이 안되서 1 를 빼주었다. \r\n"
			"			vLightAmountNEW *= max((fAttenuation-g_fAttEndLineValue2),0) * fEnableLength; \r\n"
			"			float vLightAmountDIFF = vLightAmountNEW * fDotPL; \r\n"
			"			float vLightAmountSPEC = vLightAmountNEW * fSpec; \r\n"
			"			vLightAmountNEW = min(vLightAmountDIFF,g_fOverLighting2); \r\n"
			"			vLightAmountNEW += min(vLightAmountSPEC,g_fOverLighting2); \r\n"
			"			vLightAmountNEW *= vLightMap_DS_2nd.z; \r\n"
			"		} \r\n"
			"		fLightAmount = (fLightAmount * (1.f-g_fSpotShadowLightAlpha2)) + (vLightAmountNEW * g_fSpotShadowLightAlpha2); \r\n"
			"		vAddColor += g_vDiff_CosPhiHalf_CL_TOOL[1].xyz * fLightAmount; \r\n"
			"	} \r\n"
			" \r\n"
			"	vOut.xyz = vAddColor * vColor.w / 3; \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique runtime_3 \r\n"
			"{ \r\n"
			"	pass Spot_LBuffer_PL1_ON \r\n"		// 0
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_L_3( 2, 0 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_L_3( 2, 0, false ); \r\n"
			"	} \r\n"
			"	pass Spot_LBuffer_PL2_ON \r\n"		// 1
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_L_3( 0, 2 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_L_3( 0, 2, false ); \r\n"
			"	} \r\n"
			"	pass Spot_LBuffer_PL1_PL2_ON \r\n"	// 2
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_L_3( 2, 2 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_L_3( 2, 2, false ); \r\n"
			"	} \r\n"
			"	pass Spot_LBuffer_PL1_ON_AlphaTex \r\n"		// 3
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_L_3( 2, 0 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_L_3( 2, 0, true ); \r\n"
			"	} \r\n"
			"	pass Spot_LBuffer_PL2_ON_AlphaTex \r\n"		// 4
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_L_3( 0, 2 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_L_3( 0, 2, true ); \r\n"
			"	} \r\n"
			"	pass Spot_LBuffer_PL1_PL2_ON_AlphaTex \r\n"	// 5
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_L_3( 2, 2 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_L_3( 2, 2, true ); \r\n"
			"	} \r\n"
			"}; \r\n"
			" \r\n";
	}

	void SetVoxelColorMaterial_PS30_Shading( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWorld; \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4x4 g_matShadow_PL1; \r\n"
			"float4x4 g_matShadow_PL2; \r\n"
			"float4   g_vPos_Range_CL_TOOL[2]; \r\n"
			"float4   g_vDiff_CosPhiHalf_CL_TOOL[2]; \r\n"
			"float4   g_vAtt_CosHalfThetaSubPhi_CL_TOOL[2]; \r\n"
			"float4   g_vDirect_Falloff_CL_TOOL[2]; \r\n"
			"float    g_fSpotShadowLightAlpha1; \r\n"
			"float    g_fSpotShadowLightAlpha2; \r\n"
			"float    g_fAttEndLineValue1 = 1.f; \r\n"
			"float    g_fAttEndLineValue2 = 1.f; \r\n"
			"float    g_fOverLighting1 = 2.f; \r\n"
			"float    g_fOverLighting2 = 2.f; \r\n"
			"float	  g_fSpotShadowLight1_VoxelColorPower = 1.f; \r\n"
			"float	  g_fSpotShadowLight2_VoxelColorPower = 1.f; \r\n"
			"float4   g_vWindowSize; \r\n"
			"float    g_fAlpha; \r\n"
			"float3	  g_vVoxelColor; \r\n"
			" \r\n"
			"texture g_BackBufferTexture_2nd; \r\n"
			"sampler BackBufferSampler_2nd = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BackBufferTexture_2nd); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_BackBufferTexture_3rd; \r\n"
			"sampler BackBufferSampler_3rd = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BackBufferTexture_3rd); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_INPUT			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"   float3 m_vNormal    : NORMAL; \r\n"		// PS_3_0 때문에 그냥 사용하는 방향으로 간다.
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"struct VS_OUTPUT_LBUFFER		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition				: POSITION; \r\n"
			"	float2 m_vTexCoord0				: TEXCOORD0; \r\n"
			"	float3 m_vPosLight				: TEXCOORD1; \r\n"	// Albedo 좌표를 얻기 위함.
			"	float3 m_vPosViewSpace			: TEXCOORD2; \r\n"
			"   float3 m_vHalfSpot1				: TEXCOORD3; \r\n"
			"   float3 m_vHalfSpot2				: TEXCOORD4; \r\n"
			"}; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.3.0 LBUFFER \r\n"
			"VS_OUTPUT_LBUFFER VS_L_3( VS_INPUT In, uniform int nPL1, uniform int nPL2 )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_LBUFFER Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	Out.m_vPosViewSpace = mul(g_matWV, In.m_vPosition); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	// Transform the position to light projection space, or the \r\n"
			"	// projection space as if the camera is looking out from \r\n"
			"	// the spotlight. \r\n"
			"	// \r\n"
			"	Out.m_vPosLight.xyz = Out.m_vPosition.xyw; \r\n"
			" \r\n"
			"   Out.m_vHalfSpot1 = float3(0.f,0.f,0.f); \r\n"
			"   Out.m_vHalfSpot2 = float3(0.f,0.f,0.f); \r\n"
			" \r\n"
			"	if ( nPL1==2 ) \r\n"
			"	{ \r\n"
			"		// HalfVector \r\n"
			"		float3 vHalf = -Out.m_vPosViewSpace.xyz; \r\n"
			"		vHalf = normalize( vHalf ); \r\n"
			"		vHalf += normalize( g_vPos_Range_CL_TOOL[0].xyz - Out.m_vPosViewSpace.xyz );; \r\n"
			"		Out.m_vHalfSpot1 = normalize( vHalf ); \r\n"
			"	} \r\n"
			"	if ( nPL2==2 ) \r\n"
			"	{ \r\n"
			"		// HalfVector \r\n"
			"		float3 vHalf = -Out.m_vPosViewSpace.xyz; \r\n"
			"		vHalf = normalize( vHalf ); \r\n"
			"		vHalf += normalize( g_vPos_Range_CL_TOOL[1].xyz - Out.m_vPosViewSpace.xyz );; \r\n"
			"		Out.m_vHalfSpot2 = normalize( vHalf ); \r\n"
			"	} \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_L_3( VS_OUTPUT_LBUFFER In, uniform int nPL1, uniform int nPL2, uniform bool bAlphaTex ) : COLOR0 \r\n"
			"{ \r\n"
			"	float4 vOut=1.f; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = 1.f; \r\n"
			"	if ( bAlphaTex ) \r\n"
			"	{ \r\n"
			"		vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			"	} \r\n"
			" \r\n"
			"	//transform from RT space to texture space. \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosLight.xy / In.m_vPosLight.z + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	// Normal Vector 얻기. \r\n"
			"	float3 vNor = tex2D( BackBufferSampler_2nd, vProjTex ); \r\n"
			"	vNor = normalize( vNor ); \r\n"
			" \r\n"
			"	// Specular, CubeMap Factor 얻기. \r\n"
			"	float3 vSpecularCubemap = tex2D( BackBufferSampler_3rd, vProjTex ).xyz; \r\n"
			"	vSpecularCubemap.x *= 2.f; \r\n"
			"	vSpecularCubemap.y *= 256.f; \r\n"
			" \r\n"
			"	float3 vAddColor = 0.f; \r\n"
			"	if ( nPL1==2 ) \r\n"
			"	{ \r\n"
			"		float fLightAmount = g_fSpotShadowLight1_VoxelColorPower; \r\n"
			"		float vLightAmountNEW = 1.f;  \r\n"
			"		{ \r\n"
			"			int i=0; \r\n"
			"			float3 afPosDir = g_vPos_Range_CL_TOOL[i].xyz - In.m_vPosViewSpace; \r\n"
			"			float fLength = length( afPosDir ); \r\n"
			"			// 내적 구함. \r\n"
			"			afPosDir = normalize( afPosDir ); \r\n"
			"			float fDotPL = saturate( dot( afPosDir, vNor ) ); \r\n"
			"			// 선형 감쇠, 2차 감쇠, 지수 감쇠 적용 \r\n"
			"			float fAttenuationSub = g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].x; \r\n"
			"			fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].y * fLength; \r\n"
			"			fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].z * fLength * fLength; \r\n"
			"			// 최종 감쇠값 \r\n"
			"			float fAttenuation = 1.f / fAttenuationSub; \r\n"
			"			// 거리 체크 \r\n"
			"			float fEnableLength = step(fLength, g_vPos_Range_CL_TOOL[i].w); \r\n"
			"		\r\n"
			"			//Cone쪽 계산 \r\n"
			"			 float3 fRho = dot(afPosDir,g_vDirect_Falloff_CL_TOOL[i].xyz); \r\n"
			"			fEnableLength *= step(g_vDiff_CosPhiHalf_CL_TOOL[i].w, fRho); \r\n"
			"			fEnableLength *= pow( (fRho - g_vDiff_CosPhiHalf_CL_TOOL[i].w) / g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].w, g_vDirect_Falloff_CL_TOOL[i].w ); \r\n"
			"			fEnableLength = min(1.f,fEnableLength); \r\n"
			"		\r\n"
			"			// 마지막 \r\n"
			"			float fSpec = pow( saturate( dot( normalize(In.m_vHalfSpot1), vNor ) ), vSpecularCubemap.y) * vSpecularCubemap.x; \r\n"
			" \r\n"
			"			// Edge 부분이 저 감쇠만으로는 적용이 안되서 1 를 빼주었다. \r\n"
			"			vLightAmountNEW *= max((fAttenuation-g_fAttEndLineValue1),0) * fEnableLength; \r\n"
			"			float vLightAmountDIFF = vLightAmountNEW * fDotPL; \r\n"
			"			float vLightAmountSPEC = vLightAmountNEW * fSpec; \r\n"
			"			vLightAmountNEW = min(vLightAmountDIFF,g_fOverLighting1); \r\n"
			"			vLightAmountNEW += min(vLightAmountSPEC,g_fOverLighting1); \r\n"
			"		} \r\n"
			"		fLightAmount = (fLightAmount * (1.f-g_fSpotShadowLightAlpha1)) + (vLightAmountNEW * g_fSpotShadowLightAlpha1); \r\n"
			"		vAddColor += g_vDiff_CosPhiHalf_CL_TOOL[0].xyz * fLightAmount; \r\n"
			"	} \r\n"
			"	if ( nPL2==2 ) \r\n"
			"	{ \r\n"
			"		float fLightAmount = g_fSpotShadowLight2_VoxelColorPower; \r\n"
			"		float vLightAmountNEW = 1.f;  \r\n"
			"		{ \r\n"
			"			int i=1; \r\n"
			"			float3 afPosDir = g_vPos_Range_CL_TOOL[i].xyz - In.m_vPosViewSpace; \r\n"
			"			float fLength = length( afPosDir ); \r\n"
			"			// 내적 구함. \r\n"
			"			afPosDir = normalize( afPosDir ); \r\n"
			"			float fDotPL = saturate( dot( afPosDir, vNor ) ); \r\n"
			"			// 선형 감쇠, 2차 감쇠, 지수 감쇠 적용 \r\n"
			"			float fAttenuationSub = g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].x; \r\n"
			"			fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].y * fLength; \r\n"
			"			fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].z * fLength * fLength; \r\n"
			"			// 최종 감쇠값 \r\n"
			"			float fAttenuation = 1.f / fAttenuationSub; \r\n"
			"			// 거리 체크 \r\n"
			"			float fEnableLength = step(fLength, g_vPos_Range_CL_TOOL[i].w); \r\n"
			"		\r\n"
			"			//Cone쪽 계산 \r\n"
			"			 float3 fRho = dot(afPosDir,g_vDirect_Falloff_CL_TOOL[i].xyz); \r\n"
			"			fEnableLength *= step(g_vDiff_CosPhiHalf_CL_TOOL[i].w, fRho); \r\n"
			"			fEnableLength *= pow( (fRho - g_vDiff_CosPhiHalf_CL_TOOL[i].w) / g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].w, g_vDirect_Falloff_CL_TOOL[i].w ); \r\n"
			"			fEnableLength = min(1.f,fEnableLength); \r\n"
			"		\r\n"
			"			// 마지막 \r\n"
			"			float fSpec = pow( saturate( dot( normalize(In.m_vHalfSpot2), vNor ) ), vSpecularCubemap.y) * vSpecularCubemap.x; \r\n"
			" \r\n"
			"			// Edge 부분이 저 감쇠만으로는 적용이 안되서 1 를 빼주었다. \r\n"
			"			vLightAmountNEW *= max((fAttenuation-g_fAttEndLineValue2),0) * fEnableLength; \r\n"
			"			float vLightAmountDIFF = vLightAmountNEW * fDotPL; \r\n"
			"			float vLightAmountSPEC = vLightAmountNEW * fSpec; \r\n"
			"			vLightAmountNEW = min(vLightAmountDIFF,g_fOverLighting2); \r\n"
			"			vLightAmountNEW += min(vLightAmountSPEC,g_fOverLighting2); \r\n"
			"		} \r\n"
			"		fLightAmount = (fLightAmount * (1.f-g_fSpotShadowLightAlpha2)) + (vLightAmountNEW * g_fSpotShadowLightAlpha2); \r\n"
			"		vAddColor += g_vDiff_CosPhiHalf_CL_TOOL[1].xyz * fLightAmount; \r\n"
			"	} \r\n"
			" \r\n"
			"	vOut.xyz = vAddColor * vColor.w / 3; \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique runtime_3 \r\n"
			"{ \r\n"
			"	pass Spot_LBuffer_PL1_ON \r\n"		// 0
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_L_3( 2, 0 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_L_3( 2, 0, false ); \r\n"
			"	} \r\n"
			"	pass Spot_LBuffer_PL2_ON \r\n"		// 1
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_L_3( 0, 2 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_L_3( 0, 2, false ); \r\n"
			"	} \r\n"
			"	pass Spot_LBuffer_PL1_PL2_ON \r\n"	// 2
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_L_3( 2, 2 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_L_3( 2, 2, false ); \r\n"
			"	} \r\n"
			"	pass Spot_LBuffer_PL1_ON_AlphaTex \r\n"		// 3
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_L_3( 2, 0 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_L_3( 2, 0, true ); \r\n"
			"	} \r\n"
			"	pass Spot_LBuffer_PL2_ON_AlphaTex \r\n"		// 4
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_L_3( 0, 2 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_L_3( 0, 2, true ); \r\n"
			"	} \r\n"
			"	pass Spot_LBuffer_PL1_PL2_ON_AlphaTex \r\n"	// 5
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_L_3( 2, 2 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_L_3( 2, 2, true ); \r\n"
			"	} \r\n"
			"}; \r\n"
			" \r\n";
	}

	void SetAmbientCubeFX_PS30_Shading( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWorld; \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4x4 g_matShadow_PL1; \r\n"
			"float4x4 g_matShadow_PL2; \r\n"
			"float4   g_vPos_Range_CL_TOOL[2]; \r\n"
			"float4   g_vDiff_CosPhiHalf_CL_TOOL[2]; \r\n"
			"float4   g_vAtt_CosHalfThetaSubPhi_CL_TOOL[2]; \r\n"
			"float4   g_vDirect_Falloff_CL_TOOL[2]; \r\n"
			"float    g_fSpotShadowLightAlpha1; \r\n"
			"float    g_fSpotShadowLightAlpha2; \r\n"
			"float    g_fAttEndLineValue1 = 1.f; \r\n"
			"float    g_fAttEndLineValue2 = 1.f; \r\n"
			"float    g_fOverLighting1 = 2.f; \r\n"
			"float    g_fOverLighting2 = 2.f; \r\n"
			"float	  g_fSpotShadowLight1_VoxelColorPower = 1.f; \r\n"
			"float	  g_fSpotShadowLight2_VoxelColorPower = 1.f; \r\n"
			"float4   g_vWindowSize; \r\n"
			"float    g_fAlpha; \r\n"
			"float3	  g_vVoxelColor; \r\n"
			"float3	  g_vAmbientCube[6]; \r\n"
			"float	  g_arrayfAmbientCubePL1[6] = {0.f,0.f,0.f,0.f,0.f,0.f}; \r\n"
			"float	  g_arrayfAmbientCubePL2[6] = {0.f,0.f,0.f,0.f,0.f,0.f}; \r\n"
			" \r\n"
			"texture g_BackBufferTexture_2nd; \r\n"
			"sampler BackBufferSampler_2nd = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BackBufferTexture_2nd); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_BackBufferTexture_3rd; \r\n"
			"sampler BackBufferSampler_3rd = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BackBufferTexture_3rd); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_INPUT			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"   float3 m_vNormal    : NORMAL; \r\n"		// PS_3_0 때문에 그냥 사용하는 방향으로 간다.
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"struct VS_OUTPUT_LBUFFER		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition				: POSITION; \r\n"
			"	float2 m_vTexCoord0				: TEXCOORD0; \r\n"
			"	float3 m_vPosLight				: TEXCOORD1; \r\n"	// Albedo 좌표를 얻기 위함.
			"	float3 m_vPosViewSpace			: TEXCOORD2; \r\n"
			"   float3 m_vHalfSpot1				: TEXCOORD3; \r\n"
			"   float3 m_vHalfSpot2				: TEXCOORD4; \r\n"
			"	float2 m_vACubeSpot1Spot2		: TEXCOORD5; \r\n"
			"}; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"float AmbientLightPL1( const float3 worldNormal) \r\n"
			"{ \r\n"
			"   float3 nSquared= worldNormal* worldNormal; \r\n"
			"   int3 isNegative= ( worldNormal< 0.0 ); \r\n"
			"   float linearColor; \r\n"
			"   linearColor = nSquared.x* g_arrayfAmbientCubePL1[isNegative.x] + \r\n"
			"	nSquared.y* g_arrayfAmbientCubePL1[isNegative.y+2] + \r\n"
			"	nSquared.z* g_arrayfAmbientCubePL1[isNegative.z+4]; \r\n"
			"   return linearColor; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"float AmbientLightPL2( const float3 worldNormal) \r\n"
			"{ \r\n"
			"   float3 nSquared= worldNormal* worldNormal; \r\n"
			"   int3 isNegative= ( worldNormal< 0.0 ); \r\n"
			"   float linearColor; \r\n"
			"   linearColor = nSquared.x* g_arrayfAmbientCubePL2[isNegative.x] + \r\n"
			"	nSquared.y* g_arrayfAmbientCubePL2[isNegative.y+2] + \r\n"
			"	nSquared.z* g_arrayfAmbientCubePL2[isNegative.z+4]; \r\n"
			"   return linearColor; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.3.0 LBUFFER \r\n"
			"VS_OUTPUT_LBUFFER VS_L_3( VS_INPUT In, uniform int nPL1, uniform int nPL2 )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_LBUFFER Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	Out.m_vPosViewSpace = mul(g_matWV, In.m_vPosition); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	// Transform the position to light projection space, or the \r\n"
			"	// projection space as if the camera is looking out from \r\n"
			"	// the spotlight. \r\n"
			"	// \r\n"
			"	Out.m_vPosLight.xyz = Out.m_vPosition.xyw; \r\n"
			" \r\n"
			"   Out.m_vHalfSpot1 = float3(0.f,0.f,0.f); \r\n"
			"   Out.m_vHalfSpot2 = float3(0.f,0.f,0.f); \r\n"
			"	Out.m_vACubeSpot1Spot2 = float2(0.f,0.f); \r\n"
			" \r\n"
			"	float3 vNor = normalize(mul(g_matWorld, In.m_vNormal)); \r\n"
			" \r\n"
			"	if ( nPL1==2 ) \r\n"
			"	{ \r\n"
			"		// HalfVector \r\n"
			"		float3 vHalf = -Out.m_vPosViewSpace.xyz; \r\n"
			"		vHalf = normalize( vHalf ); \r\n"
			"		vHalf += normalize( g_vPos_Range_CL_TOOL[0].xyz - Out.m_vPosViewSpace.xyz );; \r\n"
			"		Out.m_vHalfSpot1 = normalize( vHalf ); \r\n"
			" \r\n"
			"		Out.m_vACubeSpot1Spot2.x = AmbientLightPL1( vNor ); \r\n"
			"	} \r\n"
			"	if ( nPL2==2 ) \r\n"
			"	{ \r\n"
			"		// HalfVector \r\n"
			"		float3 vHalf = -Out.m_vPosViewSpace.xyz; \r\n"
			"		vHalf = normalize( vHalf ); \r\n"
			"		vHalf += normalize( g_vPos_Range_CL_TOOL[1].xyz - Out.m_vPosViewSpace.xyz );; \r\n"
			"		Out.m_vHalfSpot2 = normalize( vHalf ); \r\n"
			" \r\n"
			"		Out.m_vACubeSpot1Spot2.y = AmbientLightPL2( vNor ); \r\n"
			"	} \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_L_3( VS_OUTPUT_LBUFFER In, uniform int nPL1, uniform int nPL2, uniform bool bAlphaTex ) : COLOR0 \r\n"
			"{ \r\n"
			"	float4 vOut=1.f; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = 1.f; \r\n"
			"	if ( bAlphaTex ) \r\n"
			"	{ \r\n"
			"		vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			"	} \r\n"
			" \r\n"
			"	//transform from RT space to texture space. \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosLight.xy / In.m_vPosLight.z + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	// Normal Vector 얻기. \r\n"
			"	float3 vNor = tex2D( BackBufferSampler_2nd, vProjTex ); \r\n"
			"	vNor = normalize( vNor ); \r\n"
			" \r\n"
			"	// Specular, CubeMap Factor 얻기. \r\n"
			"	float3 vSpecularCubemap = tex2D( BackBufferSampler_3rd, vProjTex ).xyz; \r\n"
			"	vSpecularCubemap.x *= 2.f; \r\n"
			"	vSpecularCubemap.y *= 256.f; \r\n"
			" \r\n"
			"	float3 vAddColor = 0.f; \r\n"
			"	if ( nPL1==2 ) \r\n"
			"	{ \r\n"
			"		float fLightAmount = In.m_vACubeSpot1Spot2.x; \r\n"
			"		float vLightAmountNEW = 1.f;  \r\n"
			"		{ \r\n"
			"			int i=0; \r\n"
			"			float3 afPosDir = g_vPos_Range_CL_TOOL[i].xyz - In.m_vPosViewSpace; \r\n"
			"			float fLength = length( afPosDir ); \r\n"
			"			// 내적 구함. \r\n"
			"			afPosDir = normalize( afPosDir ); \r\n"
			"			float fDotPL = saturate( dot( afPosDir, vNor ) ); \r\n"
			"			// 선형 감쇠, 2차 감쇠, 지수 감쇠 적용 \r\n"
			"			float fAttenuationSub = g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].x; \r\n"
			"			fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].y * fLength; \r\n"
			"			fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].z * fLength * fLength; \r\n"
			"			// 최종 감쇠값 \r\n"
			"			float fAttenuation = 1.f / fAttenuationSub; \r\n"
			"			// 거리 체크 \r\n"
			"			float fEnableLength = step(fLength, g_vPos_Range_CL_TOOL[i].w); \r\n"
			"		\r\n"
			"			//Cone쪽 계산 \r\n"
			"			 float3 fRho = dot(afPosDir,g_vDirect_Falloff_CL_TOOL[i].xyz); \r\n"
			"			fEnableLength *= step(g_vDiff_CosPhiHalf_CL_TOOL[i].w, fRho); \r\n"
			"			fEnableLength *= pow( (fRho - g_vDiff_CosPhiHalf_CL_TOOL[i].w) / g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].w, g_vDirect_Falloff_CL_TOOL[i].w ); \r\n"
			"			fEnableLength = min(1.f,fEnableLength); \r\n"
			"		\r\n"
			"			// 마지막 \r\n"
			"			float fSpec = pow( saturate( dot( normalize(In.m_vHalfSpot1), vNor ) ), vSpecularCubemap.y) * vSpecularCubemap.x; \r\n"
			"		\r\n"
			"			// Edge 부분이 저 감쇠만으로는 적용이 안되서 1 를 빼주었다. \r\n"
			"			vLightAmountNEW *= max((fAttenuation-g_fAttEndLineValue1),0) * fEnableLength; \r\n"
			"			float vLightAmountDIFF = vLightAmountNEW * fDotPL; \r\n"
			"			float vLightAmountSPEC = vLightAmountNEW * fSpec; \r\n"
			"			vLightAmountNEW = min(vLightAmountDIFF,g_fOverLighting1); \r\n"
			"			vLightAmountNEW += min(vLightAmountSPEC,g_fOverLighting1); \r\n"
			"		} \r\n"
			"		fLightAmount = (fLightAmount * (1.f-g_fSpotShadowLightAlpha1)) + (vLightAmountNEW * g_fSpotShadowLightAlpha1); \r\n"
			"		vAddColor += g_vDiff_CosPhiHalf_CL_TOOL[0].xyz * fLightAmount; \r\n"
			"	} \r\n"
			"	if ( nPL2==2 ) \r\n"
			"	{ \r\n"
			"		float fLightAmount = In.m_vACubeSpot1Spot2.y; \r\n"
			"		float vLightAmountNEW = 1.f;  \r\n"
			"		{ \r\n"
			"			int i=1; \r\n"
			"			float3 afPosDir = g_vPos_Range_CL_TOOL[i].xyz - In.m_vPosViewSpace; \r\n"
			"			float fLength = length( afPosDir ); \r\n"
			"			// 내적 구함. \r\n"
			"			afPosDir = normalize( afPosDir ); \r\n"
			"			float fDotPL = saturate( dot( afPosDir, vNor ) ); \r\n"
			"			// 선형 감쇠, 2차 감쇠, 지수 감쇠 적용 \r\n"
			"			float fAttenuationSub = g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].x; \r\n"
			"			fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].y * fLength; \r\n"
			"			fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].z * fLength * fLength; \r\n"
			"			// 최종 감쇠값 \r\n"
			"			float fAttenuation = 1.f / fAttenuationSub; \r\n"
			"			// 거리 체크 \r\n"
			"			float fEnableLength = step(fLength, g_vPos_Range_CL_TOOL[i].w); \r\n"
			"		\r\n"
			"			//Cone쪽 계산 \r\n"
			"			 float3 fRho = dot(afPosDir,g_vDirect_Falloff_CL_TOOL[i].xyz); \r\n"
			"			fEnableLength *= step(g_vDiff_CosPhiHalf_CL_TOOL[i].w, fRho); \r\n"
			"			fEnableLength *= pow( (fRho - g_vDiff_CosPhiHalf_CL_TOOL[i].w) / g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].w, g_vDirect_Falloff_CL_TOOL[i].w ); \r\n"
			"			fEnableLength = min(1.f,fEnableLength); \r\n"
			"		\r\n"
			"			// 마지막 \r\n"
			"			float fSpec = pow( saturate( dot( normalize(In.m_vHalfSpot2), vNor ) ), vSpecularCubemap.y) * vSpecularCubemap.x; \r\n"
			"		\r\n"
			"			// Edge 부분이 저 감쇠만으로는 적용이 안되서 1 를 빼주었다. \r\n"
			"			vLightAmountNEW *= max((fAttenuation-g_fAttEndLineValue2),0) * fEnableLength; \r\n"
			"			float vLightAmountDIFF = vLightAmountNEW * fDotPL; \r\n"
			"			float vLightAmountSPEC = vLightAmountNEW * fSpec; \r\n"
			"			vLightAmountNEW = min(vLightAmountDIFF,g_fOverLighting2); \r\n"
			"			vLightAmountNEW += min(vLightAmountSPEC,g_fOverLighting2); \r\n"
			"		} \r\n"
			"		fLightAmount = (fLightAmount * (1.f-g_fSpotShadowLightAlpha2)) + (vLightAmountNEW * g_fSpotShadowLightAlpha2); \r\n"
			"		vAddColor += g_vDiff_CosPhiHalf_CL_TOOL[1].xyz * fLightAmount; \r\n"
			"	} \r\n"
			" \r\n"
			"	vOut.xyz = vAddColor * vColor.w / 3; \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique runtime_3 \r\n"
			"{ \r\n"
			"	pass Spot_LBuffer_PL1_ON \r\n"		// 0
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_L_3( 2, 0 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_L_3( 2, 0, false ); \r\n"
			"	} \r\n"
			"	pass Spot_LBuffer_PL2_ON \r\n"		// 1
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_L_3( 0, 2 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_L_3( 0, 2, false ); \r\n"
			"	} \r\n"
			"	pass Spot_LBuffer_PL1_PL2_ON \r\n"	// 2
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_L_3( 2, 2 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_L_3( 2, 2, false ); \r\n"
			"	} \r\n"
			"	pass Spot_LBuffer_PL1_ON_AlphaTex \r\n"		// 3
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_L_3( 2, 0 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_L_3( 2, 0, true ); \r\n"
			"	} \r\n"
			"	pass Spot_LBuffer_PL2_ON_AlphaTex \r\n"		// 4
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_L_3( 0, 2 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_L_3( 0, 2, true ); \r\n"
			"	} \r\n"
			"	pass Spot_LBuffer_PL1_PL2_ON_AlphaTex \r\n"	// 5
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_L_3( 2, 2 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_L_3( 2, 2, true ); \r\n"
			"	} \r\n"
			"}; \r\n";
	}
};
