#include "pch.h"

#include "NSMaterialManager.h"

// ----------------------------------------------------------------------------
#include "../../SigmaCore/DebugInclude.h"
// ----------------------------------------------------------------------------

namespace NSMaterialManager
{
	void SetDefaultMaterialTool_Deffered( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4x4 g_matLightObjectWV; \r\n"
			"float4x4 g_matLightObjectWVP; \r\n"
			"float4x4 g_matInverseView; \r\n"
			"float4x4 g_matInverseProj; \r\n"
			"float4x4 g_matInvView_Shadow; \r\n"
			"float4x4 g_matInvView_Shadow_2nd; \r\n"
			"float4x4 g_matInvView_Shadow_PL1; \r\n"
			"float4x4 g_matInvView_Shadow_PL2; \r\n"
			"float4   g_vLightDiffuse; \r\n"
			"float3   g_vLightAmbient; \r\n"
			"float3   g_vLightDirViewSpace; \r\n"
			"float2   g_vFOG;		// FogEnd, FogDist \r\n"
			"float3   g_vFogColor; \r\n"
			"float4   g_vPos_Range_PL_TOOL; \r\n"
			"float4   g_vDiff_OverLighting_PL_TOOL; \r\n"
			"float4   g_vAtt_PL_TOOL; \r\n"
			"float4   g_vPos_Range_CL_TOOL; \r\n"
			"float4   g_vDiff_CosPhiHalf_CL_TOOL; \r\n"
			"float4   g_vAtt_CosHalfThetaSubPhi_CL_TOOL; \r\n"
			"float4   g_vDirect_Falloff_CL_TOOL; \r\n"
			"float    g_fAttEndLineValue_CL_TOOL; \r\n"
			"float    g_fOverLighting_CL_TOOL; \r\n"
			"float    g_fSpecularPower = 256.f; \r\n"
			"float    g_fSpecularIntensity = 2.f; \r\n"
			"float4   g_vWindowSize; \r\n"
			"float    g_fAlpha; \r\n"
			"float2   g_vLightMapUV_Offset; \r\n"
			"float2   g_vLightMapUV_Multiply; \r\n"
			"float3	  g_vVoxelColor; \r\n"
			"float	  g_fVoxel; \r\n"
			"float	  g_fCubeMapValue; \r\n"
			"float	  g_fDecalNormal = 1.f; \r\n"
			" \r\n"
			"texture g_BackBufferTexture; \r\n"
			"sampler BackBufferSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BackBufferTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_BackBufferTexture_2nd; \r\n"
			"sampler BackBufferSampler_2nd = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BackBufferTexture_2nd); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_BackBufferTexture_3rd; \r\n"
			"sampler BackBufferSampler_3rd = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BackBufferTexture_3rd); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_BackBufferTexture_4th; \r\n"
			"sampler BackBufferSampler_4th = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BackBufferTexture_4th); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_BackBufferTexture_Depth; \r\n"
			"sampler BackBufferSampler_Depth = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BackBufferTexture_Depth); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_DepthBuffer; \r\n"
			"sampler DepthBufferSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_DepthBuffer); \r\n"
			"}; \r\n"			
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			" texture g_GlobalCubeTexture; \r\n"
			" samplerCUBE CubeTexSampler = sampler_state  \r\n"
			" { \r\n"
			" 	Texture = (g_GlobalCubeTexture); \r\n"
			" }; \r\n"
			" \r\n"
			"texture g_MaskTexture; \r\n"
			"sampler MaskTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_MaskTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_LightAccumulateTexture; \r\n"
			"sampler LightAccumulateSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_LightAccumulateTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_pTextureLodBlend; \r\n"
			"sampler TextureLodBlendSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_pTextureLodBlend); \r\n"
			"}; \r\n"			
			" \r\n"
			"texture g_LightMapDayTex; \r\n"
			"sampler LightMapTexSampler_1st = sampler_state  \r\n"
			"{ \r\n"
			"	MinFilter = Linear; \r\n"
			"	MagFilter = Linear; \r\n"
			"	Texture = (g_LightMapDayTex); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_LightMapTex_DS_1st; \r\n"
			"sampler LightMapTexSampler_DS_1st = sampler_state  \r\n"
			"{ \r\n"
			"	MinFilter = Linear; \r\n"
			"	MagFilter = Linear; \r\n"
			"	Texture = (g_LightMapTex_DS_1st); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_LightMapTex_DS_2nd; \r\n"
			"sampler LightMapTexSampler_DS_2nd = sampler_state  \r\n"
			"{ \r\n"
			"	MinFilter = Linear; \r\n"
			"	MagFilter = Linear; \r\n"
			"	Texture = (g_LightMapTex_DS_2nd); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_ShadowTexture_CSM; \r\n"
			"sampler ShadowTexSampler_CSM = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_ShadowTexture_CSM); \r\n"
			" \r\n"
			"	MinFilter = Point; \r\n"
			"	MagFilter = Point; \r\n"
			"	AddressU = Clamp; \r\n"
			"	AddressV = Clamp; \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_ShadowTexture_PL1; \r\n"
			"sampler ShadowTexSampler_PL1 = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_ShadowTexture_PL1); \r\n"
			" \r\n"
			"	MinFilter = Point; \r\n"
			"	MagFilter = Point; \r\n"
			"	AddressU = Clamp; \r\n"
			"	AddressV = Clamp; \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_ShadowTexture_PL2; \r\n"
			"sampler ShadowTexSampler_PL2 = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_ShadowTexture_PL2); \r\n"
			" \r\n"
			"	MinFilter = Point; \r\n"
			"	MagFilter = Point; \r\n"
			"	AddressU = Clamp; \r\n"
			"	AddressV = Clamp; \r\n"
			"}; \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"struct VS_INPUT_TOOL	\r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float4 m_vColor0		: COLOR0; \r\n"
			"	float3 m_vNormal		: NORMAL; \r\n"
			"	float3 m_vBinormal		: BINORMAL; \r\n"
			"	float3 m_vTangent		: TANGENT; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_OUTPUT_GPASS	\r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float4 m_vColor0		: COLOR0; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"	float3 m_vNormal		: TEXCOORD1; \r\n"
			"	float3 m_vBinormal		: TEXCOORD2; \r\n"
			"	float3 m_vTangent		: TEXCOORD3; \r\n"
			"	float3 m_vPosViewSpace	: TEXCOORD4; \r\n"
			"	float4 m_vPosProjSpace	: TEXCOORD5; \r\n"
			"}; \r\n"
			" \r\n"
			"struct PS_DEFFERED_OUT	\r\n"
			"{ \r\n"
			"	float4 m_vColor0		: COLOR0; \r\n"	// Albedo
			"	float4 m_vColor1		: COLOR1; \r\n"	// Normal
			"	float4 m_vColor2		: COLOR2; \r\n"	// Specular(Intensity,Power), CubeMap
			"	float4 m_vColor3		: COLOR3; \r\n"	// 
			"}; \r\n"
			"struct VS_OUTPUT_QUAD	\r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_INPUT_LPASS	\r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_LPASS	\r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float3 m_vPosProjSpace	: TEXCOORD0; \r\n"	// Albedo 좌표를 얻기 위함.
			//"	float3 m_vDirViewSpace	: TEXCOORD1; \r\n"	// 위치값을 얻기위한 방향벡터
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_MPASS	\r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float2 m_vTexCoord0     : TEXCOORD0; \r\n"	// Texture Alpha(xy) 값을 위함.
			"	float3 m_vPosLight		: TEXCOORD1; \r\n"	// Albedo 좌표를 얻기 위함.
			"	float  m_fFog			: FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_INPUT			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"	float2 m_vLightmapUV	: TEXCOORD1;	// LightMap를 사용할 경우, m_vLightmapUV 이름을 유지해주세요. \r\n"
			"	// m_vLightmapUV 이름이 있으면, LightMap을 생성해준다. \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					N o r m a l \r\n"
			"float3 GetNormal( VS_OUTPUT_GPASS In, float4 vMaskColor ) \r\n"
			"{ \r\n"
			"    // If using a signed texture, we must unbias the normal map data \r\n"
			"    float3 Normal; \r\n"
			"    Normal.xy = (vMaskColor.wy * 2) - 1; \r\n"
			"	 Normal.z = sqrt( 1.f - dot( Normal.xy, Normal.xy ) ); \r\n"
			"    \r\n"
			"    // Move the normal from tangent space to world space \r\n"
			"    float3x3 mTangentFrame = { In.m_vTangent, In.m_vBinormal, In.m_vNormal }; \r\n"
			"    Normal = mul( Normal, mTangentFrame ); \r\n"
			"    Normal = normalize( Normal ); \r\n"
			" \r\n"
			"    return Normal;  \r\n"
			"}  \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//				TOOL		G-Pass \r\n"
			"VS_OUTPUT_GPASS VS_GPASS( VS_INPUT_TOOL In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_GPASS Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	Out.m_vColor0 = In.m_vColor0; \r\n"
			"	Out.m_vNormal = normalize( mul(g_matWV, In.m_vNormal) ); \r\n"
			"	Out.m_vBinormal = normalize( mul(g_matWV, In.m_vBinormal) ); \r\n"
			"	Out.m_vTangent = normalize( mul(g_matWV, In.m_vTangent) ); \r\n"
			"	Out.m_vPosViewSpace = mul(g_matWV, In.m_vPosition).xyz; \r\n"
			"	Out.m_vPosProjSpace = mul(g_matWVP, In.m_vPosition); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_GPASS( VS_OUTPUT_GPASS In, uniform int nDecalMode )  \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.w + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor *= In.m_vColor0; \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			//"	vColor.a *= (fTextureLodBlend+1.f) * g_fAlpha; \r\n"
			" \r\n"
			"	float3 vNor = GetNormal( In, vMaskColor ); \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"	vOut.m_vColor1 = float4(((vNor+1.f)*0.5f),vColor.w*g_fDecalNormal); \r\n"
			"   vOut.m_vColor2 = float4( g_fSpecularIntensity*0.5f*vMaskColor.r, g_fSpecularPower/256.f, g_fCubeMapValue*vMaskColor.b, vColor.w*g_fDecalNormal); \r\n"
			"   vOut.m_vColor3 = 1.f; \r\n"
			"   vOut.m_vColor3.x = g_fVoxel; \r\n"
			" \r\n"
			"   if ( nDecalMode == 1 ) \r\n"	// Multiply
			"	{ \r\n"
			"		vOut.m_vColor1 = 1.f; \r\n"
			"		vOut.m_vColor2 = 1.f; \r\n"
			"		vOut.m_vColor3 = 1.f; \r\n"
			"	} \r\n"
			"   else if ( nDecalMode == 2 ) \r\n"	// Add
			"	{ \r\n"
			"		vOut.m_vColor1 = 0.f; \r\n"
			"		vOut.m_vColor2 = 0.f; \r\n"
			"		vOut.m_vColor3 = 0.f; \r\n"
			"	} \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//				TOOL		L-Pass Sun \r\n"
			"float4 PS_LSPASS( VS_OUTPUT_QUAD In ) : COLOR0  \r\n"
			"{ \r\n"
			"	float4 vOut = 1.f; \r\n"
			" \r\n"
			"	// Normal Vector 얻기. \r\n"
			"	float3 vNor = tex2D( BackBufferSampler_2nd, In.m_vTexCoord0 ); \r\n"
			"	vNor = vNor*2.f-1.f; \r\n"
			"	vNor = normalize( vNor ); \r\n"
			" \r\n"
			"	// Specular, CubeMap Factor 얻기. \r\n"
			"	float3 vSpecularCubemap = tex2D( BackBufferSampler_3rd, In.m_vTexCoord0 ).xyz; \r\n"
			"	vSpecularCubemap.x *= 2.f; \r\n"
			"	vSpecularCubemap.y *= 256.f; \r\n"
			" \r\n"
			"	// Specular, CubeMap Factor 얻기. \r\n"
			"	float fVoxel = tex2D( BackBufferSampler_4th, In.m_vTexCoord0 ).x; \r\n"
			" \r\n"
			"	// Get the depth buffer value at this pixel. \r\n"
			"	float zOverW = tex2D( BackBufferSampler_Depth, In.m_vTexCoord0 ).x; \r\n"
			"	// H is the viewport position at this pixel in the range -1 to 1. \r\n"
			"	float4 H = float4(In.m_vTexCoord0.x * 2 - 1, (1 - In.m_vTexCoord0.y) * 2 - 1, zOverW, 1); \r\n"
			"	// Transform by the view-projection inverse. \r\n"
			"	float4 D = mul(g_matInverseProj, H); \r\n"
			"	// Divide by w to get the world position. \r\n"
			"	float3 vPositionViewSpace = D / D.w; \r\n"
			" \r\n"
			"   float fDot = saturate(dot(g_vLightDirViewSpace,vNor)); \r\n"	// 난반사 계산됨.
			" \r\n"
			"	// HalfVector \r\n"
			"	float3 vHalf = -vPositionViewSpace; \r\n"
			"	vHalf = normalize( vHalf ); \r\n"
			"	vHalf += g_vLightDirViewSpace; \r\n"
			"	vHalf = normalize( vHalf ); \r\n"
			" \r\n"
			"	float fSpec = pow( saturate( dot( vHalf, vNor ) ), vSpecularCubemap.y) * vSpecularCubemap.x; \r\n"	// 정반사 계산
			"   fDot += fSpec; \r\n"
			" \r\n"
			" if ( fVoxel > 0.5f ) \r\n"
			" { \r\n"
			"	vOut.xyz = g_vLightDiffuse*0.5f + g_vLightAmbient; \r\n"
			" } \r\n"
			" else \r\n"
			" { \r\n"
			"	vOut.xyz = g_vLightDiffuse*fDot + g_vLightAmbient; \r\n"
			" } \r\n"			
			"   vOut.xyz /= 3.f; \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//				TOOL		L-Pass \r\n"
			"VS_OUTPUT_LPASS VS_LPASS( VS_INPUT_LPASS In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_LPASS Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matLightObjectWVP, In.m_vPosition); \r\n"
			" \r\n"
			"	// Transform the position to light projection space, or the \r\n"
			"	// projection space as if the camera is looking out from \r\n"
			"	// the spotlight. \r\n"
			"	// \r\n"
			"	Out.m_vPosProjSpace.xyz = Out.m_vPosition.xyw; \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_LPASS_POINT( VS_OUTPUT_LPASS In ) : COLOR0  \r\n"
			"{ \r\n"
			"	float4 vOut = 1.f; \r\n"
			" \r\n"
			"	//transform from RT space to texture space. \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.z + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	// Normal Vector 얻기. \r\n"
			"	float3 vNor = tex2D( BackBufferSampler_2nd, vProjTex ); \r\n"
			"	vNor = vNor*2.f-1.f; \r\n"
			"	vNor = normalize( vNor ); \r\n"
			" \r\n"
			"	// Specular, CubeMap Factor 얻기. \r\n"
			"	float3 vSpecularCubemap = tex2D( BackBufferSampler_3rd, vProjTex ).xyz; \r\n"
			"	vSpecularCubemap.x *= 2.f; \r\n"
			"	vSpecularCubemap.y *= 256.f; \r\n"
			" \r\n"
			"	// Get the depth buffer value at this pixel. \r\n"
			"	float zOverW = tex2D( BackBufferSampler_Depth, vProjTex ).x; \r\n"
			"	// H is the viewport position at this pixel in the range -1 to 1. \r\n"
			"	float4 H = float4(vProjTex.x * 2 - 1, (1 - vProjTex.y) * 2 - 1, zOverW, 1); \r\n"
			"	// Transform by the view-projection inverse. \r\n"
			"	float4 D = mul(g_matInverseProj, H); \r\n"
			"	// Divide by w to get the world position. \r\n"
			"	float3 vPositionViewSpace = D / D.w; \r\n"
			" \r\n"
			//"	float4 vProjectedPos = float4(In.m_vPosProjSpace.x, In.m_vPosProjSpace.y, vPositionViewSpace.x, 1.0f); \r\n"
			//"	// Transform by the inverse projection matrix \r\n"
			//"	float4 vPositionVS = mul(g_matInverseProj, vProjectedPos); \r\n"
			//"	// Divide by w to get the view-space position \r\n"
			////"	vPositionVS.xyz / vPositionVS.w; \r\n"
			//" \r\n"
			"	float3 afPosDir = g_vPos_Range_PL_TOOL.xyz - vPositionViewSpace; \r\n"
			" 	float fLength = length( afPosDir ); \r\n"
			"	// 내적 구함. \r\n"
			"	afPosDir = normalize( afPosDir ); \r\n"
			"	float fDotPL = saturate( dot( afPosDir, vNor ) ); \r\n"
			"	// 선형 감쇠, 2차 감쇠, 지수 감쇠 적용 \r\n"
			"	float fAttenuationSub = g_vAtt_PL_TOOL.x; \r\n"
			"	fAttenuationSub += g_vAtt_PL_TOOL.y * fLength; \r\n"
			"	fAttenuationSub += g_vAtt_PL_TOOL.z * fLength * fLength; \r\n"
			"	// 최종 감쇠값 \r\n"
			"	float fAttenuation = 1.f / fAttenuationSub; \r\n"
			"	// 거리 체크 \r\n"
			"	float fEnableLength = step(fLength, g_vPos_Range_PL_TOOL.w); \r\n"
			"	// 마지막 \r\n"
			"	// Edge 부분이 저 감쇠만으로는 적용이 안되서 1 를 빼주었다. \r\n"
			"	fAttenuation = max((fAttenuation-1.f),0) * fDotPL * fEnableLength; \r\n"
			"	fAttenuation = min(fAttenuation,g_vDiff_OverLighting_PL_TOOL.w); \r\n"
			" 	vOut.xyz = g_vDiff_OverLighting_PL_TOOL.xyz * fAttenuation; \r\n"
			" 	vOut.xyz /= 3.f; \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_LPASS_SPOT( VS_OUTPUT_LPASS In ) : COLOR0  \r\n"
			"{ \r\n"
			"	float4 vOut = 1.f; \r\n"
			" \r\n"
			"	//transform from RT space to texture space. \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.z + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	// Normal Vector 얻기. \r\n"
			"	float3 vNor = tex2D( BackBufferSampler_2nd, vProjTex ); \r\n"
			"	vNor = vNor*2.f-1.f; \r\n"
			"	vNor = normalize( vNor ); \r\n"
			" \r\n"
			"	// Specular, CubeMap Factor 얻기. \r\n"
			"	float3 vSpecularCubemap = tex2D( BackBufferSampler_3rd, vProjTex ).xyz; \r\n"
			"	vSpecularCubemap.x *= 2.f; \r\n"
			"	vSpecularCubemap.y *= 256.f; \r\n"
			" \r\n"
			"	// Get the depth buffer value at this pixel. \r\n"
			"	float zOverW = tex2D( BackBufferSampler_Depth, vProjTex ).x; \r\n"
			"	// H is the viewport position at this pixel in the range -1 to 1. \r\n"
			"	float4 H = float4(vProjTex.x * 2 - 1, (1 - vProjTex.y) * 2 - 1, zOverW, 1); \r\n"
			"	// Transform by the view-projection inverse. \r\n"
			"	float4 D = mul(g_matInverseProj, H); \r\n"
			"	// Divide by w to get the world position. \r\n"
			"	float3 vPositionViewSpace = D / D.w; \r\n"
			" \r\n"
			"	float3 afPosDir = g_vPos_Range_CL_TOOL.xyz - vPositionViewSpace; \r\n"
			" 	float fLength = length( afPosDir ); \r\n"
			"	// 내적 구함. \r\n"
			"	afPosDir = normalize( afPosDir ); \r\n"
			"	float fDotPL = saturate( dot( afPosDir, vNor ) ); \r\n"
			"	// 선형 감쇠, 2차 감쇠, 지수 감쇠 적용 \r\n"
			"	float fAttenuationSub = g_vAtt_CosHalfThetaSubPhi_CL_TOOL.x; \r\n"
			"	fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL.y * fLength; \r\n"
			"	fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL.z * fLength * fLength; \r\n"
			"	// 최종 감쇠값 \r\n"
			"	float fAttenuation = 1.f / fAttenuationSub; \r\n"
			"	// 거리 체크 \r\n"
			"	float fEnableLength = step(fLength, g_vPos_Range_CL_TOOL.w); \r\n"
			" \r\n"
			"	//Cone쪽 계산 \r\n"
			"	float3 fRho = dot(afPosDir,g_vDirect_Falloff_CL_TOOL.xyz); \r\n"
			"	fEnableLength *= step(g_vDiff_CosPhiHalf_CL_TOOL.w, fRho); \r\n"
			"	fEnableLength *= pow( (fRho - g_vDiff_CosPhiHalf_CL_TOOL.w) / g_vAtt_CosHalfThetaSubPhi_CL_TOOL.w, g_vDirect_Falloff_CL_TOOL.w ); \r\n"
			"	fEnableLength = min(1.f,fEnableLength); \r\n"
			" \r\n"
			"	// 마지막 \r\n"
			"	// Edge 부분이 저 감쇠만으로는 적용이 안되서 1 를 빼주었다. \r\n"
			"	fAttenuation = max((fAttenuation-1.f),0) * fDotPL * fEnableLength; \r\n"
			"	fAttenuation = min(fAttenuation,g_fOverLighting_CL_TOOL); \r\n"
			" 	vOut.xyz = g_vDiff_CosPhiHalf_CL_TOOL.xyz * fAttenuation; \r\n"
			" 	vOut.xyz /= 3.f; \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//				TOOL		M-Pass deffered \r\n"
			"float4 PS_MPASS_deffered_psf( VS_OUTPUT_QUAD In, uniform bool bSoftAlpha ) : COLOR0  \r\n"
			"{ \r\n"
			"	// Texture \r\n"
			"	float4 vOut = tex2D( BackBufferSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	// LBuffer 값 얻기. \r\n"
			"	float3 vLColor = tex2D( LightAccumulateSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	// Normal Vector 얻기. \r\n"
			"	float3 vNor = tex2D( BackBufferSampler_2nd, In.m_vTexCoord0 ); \r\n"
			"	vNor = vNor*2.f-1.f; \r\n"
			"	vNor = normalize( vNor ); \r\n"
			" \r\n"
			"	// Specular, CubeMap Factor 얻기. \r\n"
			"	float3 vSpecularCubemap = tex2D( BackBufferSampler_3rd, In.m_vTexCoord0 ).xyz; \r\n"
			"	vSpecularCubemap.x *= 2.f; \r\n"
			"	vSpecularCubemap.y *= 256.f; \r\n"
			" \r\n"
			"	// Get the depth buffer value at this pixel. \r\n"
			"	float zOverW = tex2D( BackBufferSampler_Depth, In.m_vTexCoord0 ).x; \r\n"
			"	// H is the viewport position at this pixel in the range -1 to 1. \r\n"
			"	float4 H = float4(In.m_vTexCoord0.x * 2 - 1, (1 - In.m_vTexCoord0.y) * 2 - 1, zOverW, 1); \r\n"
			"	// Transform by the view-projection inverse. \r\n"
			"	float4 D = mul(g_matInverseProj, H); \r\n"
			"	// Divide by w to get the world position. \r\n"
			"	float3 vPositionViewSpace = D / D.w; \r\n"
			" \r\n"
			"	// CubMap 작업. \r\n"
			"	float3 vEyeToVector = normalize(vPositionViewSpace); \r\n"
			"	float3 vCubeTexcoord = reflect(vEyeToVector, vNor); \r\n"
			"	vCubeTexcoord = mul(g_matInverseView, vCubeTexcoord); \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMap \r\n"
			"	vOut.xyz = vOut.xyz*(1.f-vSpecularCubemap.z) + texCUBE( CubeTexSampler, vCubeTexcoord ).xyz * vSpecularCubemap.z; \r\n"
			" \r\n"
			"	vOut.xyz = vOut*vLColor*3.f; \r\n"
			" \r\n"
			"	float fFog = saturate((g_vFOG.x - vPositionViewSpace.z) / g_vFOG.y); \r\n"
			"	vOut.xyz = (vOut.xyz*fFog) + g_vFogColor*(1.f-fFog); \r\n"
			" \r\n"
			"	if ( bSoftAlpha ) \r\n"
			"	{ \r\n"
			"		vOut.xyz *= 1.f / vOut.w; \r\n"
			"	} \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique tool_deffered \r\n"
			"{ \r\n"
			"	pass geometry_pass \r\n"	// 0
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_GPASS(); \r\n"
			"		PixelShader = compile ps_3_0 PS_GPASS(0); \r\n"
			"	} \r\n"
			"	pass geometry_decal_multiply_pass \r\n"	// 1
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_GPASS(); \r\n"
			"		PixelShader = compile ps_3_0 PS_GPASS(1); \r\n"
			"	} \r\n"
			"	pass geometry_decal_add_pass \r\n"	// 2
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_GPASS(); \r\n"
			"		PixelShader = compile ps_3_0 PS_GPASS(2); \r\n"
			"	} \r\n"
			"	pass light_accumulation_sun_pass \r\n"	// 3
			"	{ \r\n"
			"		PixelShader = compile ps_3_0 PS_LSPASS(); \r\n"
			"	} \r\n"
			"	pass light_accumulation_point_pass \r\n"	// 4
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_LPASS(); \r\n"
			"		PixelShader = compile ps_3_0 PS_LPASS_POINT(); \r\n"
			"	} \r\n"
			"	pass light_accumulations_spot_pass \r\n"	// 5
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_LPASS(); \r\n"
			"		PixelShader = compile ps_3_0 PS_LPASS_SPOT(); \r\n"
			"	} \r\n"
			"	pass material_pass_deffered \r\n"	// 6
			"	{ \r\n"
			"		PixelShader = compile ps_3_0 PS_MPASS_deffered_psf(false); \r\n"
			"	} \r\n"
			"	pass material_pass_deffered \r\n"	// 7
			"	{ \r\n"
			"		PixelShader = compile ps_3_0 PS_MPASS_deffered_psf(true); \r\n"
			"	} \r\n"
			"}; \r\n"
			" \r\n";
	}
};