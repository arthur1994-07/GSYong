#include "pch.h"

#include "NSMaterialManager.h"

// ----------------------------------------------------------------------------
#include "../../SigmaCore/DebugInclude.h"
// ----------------------------------------------------------------------------

namespace NSMaterialManager
{
	void SetLightMapMaterialTool( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4   g_vLightDiffuse; \r\n"
			"float3   g_vLightAmbient; \r\n"
			"float3   g_vLightDirViewSpace; \r\n"
			"float2   g_vFOG;		// FogEnd, FogDist \r\n"
			"float3   g_vFogColor; \r\n"
			"int      g_nPointLightNum_TOOL; \r\n"
			"float4   g_vPos_Range_PL_TOOL[12]; \r\n"
			"float4   g_vDiff_OverLighting_PL_TOOL[12]; \r\n"
			"float4   g_vAtt_PL_TOOL[12]; \r\n"
			"int      g_nConeLightNum_TOOL; \r\n"
			"float4   g_vPos_Range_CL_TOOL[3]; \r\n"
			"float4   g_vDiff_CosPhiHalf_CL_TOOL[3]; \r\n"
			"float4   g_vAtt_CosHalfThetaSubPhi_CL_TOOL[3]; \r\n"
			"float4   g_vDirect_Falloff_CL_TOOL[3]; \r\n"
			"float    g_fAttEndLineValue_CL_TOOL[3]; \r\n"
			"float    g_fOverLighting_CL_TOOL[3]; \r\n"
			"float    g_fSpecularPower = 256.f; \r\n"
			"float    g_fSpecularIntensity = 2.f; \r\n"
			"float    g_fOverLightPower_PS_2_0 = 1.f; \r\n"
			"float    g_fVS_1_1_ColorMulti = 0.75f; \r\n"
			"float4   g_vWindowSize; \r\n"
			"float    g_fAlpha; \r\n"
			"float2   g_vLightMapUV_Offset; \r\n"
			"float2   g_vLightMapUV_Multiply; \r\n"
			"float3	  g_vVoxelColor; \r\n"
			"float	  g_fCubeMapValue; \r\n"
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_LightMapDayTex; \r\n"
			"sampler LightMapTexSampler_1st = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_LightMapDayTex); \r\n"
			"}; \r\n"
			" \r\n"
			" texture g_GlobalCubeTexture; \r\n"
			" samplerCUBE CubeTexSampler = sampler_state  \r\n"
			" { \r\n"
			" 	Texture = (g_GlobalCubeTexture); \r\n"
			" }; \r\n"
			" \r\n"
			"texture g_MaskTexture; \r\n"
			"sampler MaskTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_MaskTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			// Tool 쪽 struct VS_INPUT_TOOL 들은 동일한 구조체로 되어 있어야 한다.
			// 동일하지 않으면 VoxelColorVC 쪽에서 에러가 생긴다. Diffuse 를 못 얻어온다.
			// Mesh 를 만들 경우 Version 만 보고 Refresh 를 하기 때문이다.
			"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"		
			"{ \r\n"												
			"	float4 m_vPosition  : POSITION; \r\n"				
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float4 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_OUTPUT_TOOL	// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float3 m_vPos       : TEXCOORD1; \r\n"
			"	float3 m_vNor       : TEXCOORD2; \r\n"
			"	float3 m_vColor0    : TEXCOORD3; \r\n"
			"	float3 m_vCubeTexcoord : TEXCOORD4; \r\n"
			"	float3 m_vHalf      : TEXCOORD5; \r\n"
			"	float  m_fFog       : FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_INPUT			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"   float3 m_vNormal    : NORMAL; \r\n"
			"#else \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"   float3 m_vNormal    : NORMAL; \r\n"
			"#endif \r\n"
			"#endif \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float2 m_vLightmapUV   : TEXCOORD1;	// LightMap를 사용할 경우, m_vLightmapUV 이름을 유지해주세요. \r\n"
			"	// m_vLightmapUV 이름이 있으면, LightMap을 생성해준다. \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"struct VS_OUTPUT_TEST	// test \r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"	float2 m_vLightmapUV	: TEXCOORD1; \r\n"
			"	float  m_fFog			: FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//				TOOL		editer 렌더용 \r\n"
			"VS_OUTPUT_TOOL VS_TOOL( VS_INPUT_TOOL In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_TOOL Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	Out.m_vPos = mul(g_matWV, In.m_vPosition); \r\n"
			"	Out.m_vNor = normalize( mul(g_matWV, In.m_vNormal) ); \r\n"
			" \r\n"
			"	// HalfVector \r\n"
			"	float3 vHalf = -Out.m_vPos.xyz; \r\n"
			"	vHalf = normalize( vHalf ); \r\n"
			"	vHalf += normalize( g_vLightDirViewSpace.xyz ); \r\n"
			"	Out.m_vHalf.xyz = normalize( vHalf ); \r\n"
			" \r\n"
			"	// CubMap 작업. \r\n"
			"	float3 vEyeToVector = normalize(Out.m_vPos); \r\n"
			"	Out.m_vCubeTexcoord = reflect(vEyeToVector, Out.m_vNor); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	float fDiffuseDot = saturate( dot( g_vLightDirViewSpace, Out.m_vNor ) ); \r\n"
			"	float3 vDiffuse = g_vLightDiffuse * fDiffuseDot + g_vLightAmbient; \r\n"
			" \r\n"
			"	Out.m_vColor0.xyz = vDiffuse.xyz; \r\n"
			" \r\n"
			"	Out.m_fFog = saturate((g_vFOG.x - Out.m_vPosition.z) / g_vFOG.y); \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_TOOL( VS_OUTPUT_TOOL In ) : COLOR0  \r\n"
			"{ \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"    float3 vNor = normalize( In.m_vNor ); \r\n"
			" \r\n"
			"    float3 vPointColor = 0.f; \r\n"
			"    for ( int i=0; i<g_nPointLightNum_TOOL; ++i ) \r\n"
			"    { \r\n"
			"        float3 afPosDir = g_vPos_Range_PL_TOOL[i].xyz - In.m_vPos; \r\n"
			"        float fLength = length( afPosDir ); \r\n"
			"        // 내적 구함. \r\n"
			"        afPosDir = normalize( afPosDir ); \r\n"
			"        float fDotPL = saturate( dot( afPosDir, vNor ) ); \r\n"
			"        // 선형 감쇠, 2차 감쇠, 지수 감쇠 적용 \r\n"
			"        float fAttenuationSub = g_vAtt_PL_TOOL[i].x; \r\n"
			"        fAttenuationSub += g_vAtt_PL_TOOL[i].y * fLength; \r\n"
			"        fAttenuationSub += g_vAtt_PL_TOOL[i].z * fLength * fLength; \r\n"
			"        // 최종 감쇠값 \r\n"
			"        float fAttenuation = 1.f / fAttenuationSub; \r\n"
			"        // 거리 체크 \r\n"
			"        float fEnableLength = step(fLength, g_vPos_Range_PL_TOOL[i].w); \r\n"
			"        // 마지막 \r\n"
			"	     // Edge 부분이 저 감쇠만으로는 적용이 안되서 1 를 빼주었다. \r\n"
			"		 fAttenuation = max((fAttenuation-1.f),0) * fDotPL * fEnableLength; \r\n"
			"		 fAttenuation = min(fAttenuation,g_vDiff_OverLighting_PL_TOOL[i].w); \r\n"
			"        vPointColor += g_vDiff_OverLighting_PL_TOOL[i].xyz * fAttenuation; \r\n"
			"    } \r\n"
			" \r\n"
			"    for ( int i=0; i<g_nConeLightNum_TOOL; ++i ) \r\n"
			"    { \r\n"
			"        float3 afPosDir = g_vPos_Range_CL_TOOL[i].xyz - In.m_vPos; \r\n"
			"        float fLength = length( afPosDir ); \r\n"
			"        // 내적 구함. \r\n"
			"        afPosDir = normalize( afPosDir ); \r\n"
			"        float fDotPL = saturate( dot( afPosDir, vNor ) ); \r\n"
			"        // 선형 감쇠, 2차 감쇠, 지수 감쇠 적용 \r\n"
			"        float fAttenuationSub = g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].x; \r\n"
			"        fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].y * fLength; \r\n"
			"        fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].z * fLength * fLength; \r\n"
			"        // 최종 감쇠값 \r\n"
			"        float fAttenuation = 1.f / fAttenuationSub; \r\n"
			"        // 거리 체크 \r\n"
			"        float fEnableLength = step(fLength, g_vPos_Range_CL_TOOL[i].w); \r\n"
			"    \r\n"
			"		 //Cone쪽 계산 \r\n"
			"        float3 fRho = dot(afPosDir,g_vDirect_Falloff_CL_TOOL[i].xyz); \r\n"
			"        fEnableLength *= step(g_vDiff_CosPhiHalf_CL_TOOL[i].w, fRho); \r\n"
			"        fEnableLength *= pow( (fRho - g_vDiff_CosPhiHalf_CL_TOOL[i].w) / g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].w, g_vDirect_Falloff_CL_TOOL[i].w ); \r\n"
			"        fEnableLength = min(1.f,fEnableLength); \r\n"
			"    \r\n"
			"		 // 마지막 \r\n"
			"		 float3 vHalf = -In.m_vPos; \r\n"
			"		 vHalf = normalize( vHalf ); \r\n"
			"		 vHalf += normalize( g_vPos_Range_CL_TOOL[i].xyz - In.m_vPos ); \r\n"
			"		 float fSpec = pow( saturate( dot( normalize(vHalf), vNor ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
			"    \r\n"
			"		 // Edge 부분이 저 감쇠만으로는 적용이 안되서 1 를 빼주었다. \r\n"
			"		 float vLightAmountNEW = max((fAttenuation-g_fAttEndLineValue_CL_TOOL[i]),0) * fEnableLength; \r\n"
			"		 float vLightAmountDIFF = vLightAmountNEW * fDotPL; \r\n"
			"		 float vLightAmountSPEC = vLightAmountNEW * fSpec; \r\n"
			"		 vLightAmountNEW = min(vLightAmountDIFF,g_fOverLighting_CL_TOOL[i]); \r\n"
			"		 vLightAmountNEW += min(vLightAmountSPEC,g_fOverLighting_CL_TOOL[i]); \r\n"
			"        vPointColor += g_vDiff_CosPhiHalf_CL_TOOL[i].xyz * vLightAmountNEW; \r\n"
			"    } \r\n"
			" // Direction Specular 계산.\r\n"
			" \r\n"
			"   float fSpec=0.f; \r\n"
			"	{ \r\n"
			"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"		fSpec = pow( saturate( dot( normalize(In.m_vHalf.xyz), vNor ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
			"	    fSpec *= vMaskColor.x; \r\n"
			"	} \r\n"			
			"	\r\n"
			" \r\n"
			"   vPointColor += In.m_vColor0.xyz * (1.f + fSpec); \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMapMask \r\n"
			"	float fCubeMapValue = g_fCubeMapValue; \r\n"
			"	{ \r\n"
			"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"		fCubeMapValue *= vMaskColor.z; \r\n"
			"	} \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMap \r\n"
			"	vColor.xyz = vColor.xyz*(1.f-fCubeMapValue) + texCUBE( CubeTexSampler, In.m_vCubeTexcoord ).xyz * fCubeMapValue; \r\n"
			" \r\n"
			"	vColor.xyz *= min(vPointColor.xyz,3.f); \r\n"
			"	vColor.xyz = (vColor.xyz*In.m_fFog) + g_vFogColor*(1.f-In.m_fFog); \r\n"
			"	vColor.w *= g_fAlpha; \r\n"
			" \r\n"
			"	return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					P	S		test 렌더용 \r\n"
			" \r\n"
			"VS_OUTPUT_TEST VS_TEST( VS_INPUT In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_TEST Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			"	Out.m_vLightmapUV = In.m_vLightmapUV; \r\n"
			//"	Out.m_vLightmapUV.xy += g_vLightMapUV_Offset; \r\n"
			" \r\n"
			"	Out.m_fFog = saturate((g_vFOG.x - Out.m_vPosition.z) / g_vFOG.y); \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_TEST( VS_OUTPUT_TEST In ) : COLOR0  \r\n"
			"{ \r\n"
			"	// Texture \r\n"
			"	// 라이트맵  \r\n"
			"   float2 vUV = In.m_vLightmapUV*g_vLightMapUV_Multiply; \r\n"
			"   float4 vLightMapDay = tex2D( LightMapTexSampler_1st, vUV ); \r\n"
			" \r\n"
			//"	float4 vColor = vLightMapDay * g_fOverLightPower_PS_2_0; \r\n"
			"	float4 vColor = vLightMapDay; \r\n"
			"	vColor.w = g_fAlpha; \r\n"
			" \r\n"
			"	return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique tool \r\n"
			"{ \r\n"
			"	pass high \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_TOOL(); \r\n"
			"		PixelShader = compile ps_3_0 PS_TOOL(); \r\n"
			"	} \r\n"
			"}; \r\n"
			" \r\n"
			"technique lightmaptest \r\n"
			"{ \r\n"
			"	pass high \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_2_0 VS_TEST(); \r\n"
			"		PixelShader = compile ps_2_0 PS_TEST(); \r\n"
			"	} \r\n"
			"}; \r\n"
			" \r\n";
	}

	//void SetVoxelColorMaterialTool( std::string& strFX )
	//{
	//	strFX = 
	//		"//-------------------------------------------------------------------------------------- \r\n"
	//		"//       shhan \r\n"
	//		"//-------------------------------------------------------------------------------------- \r\n"
	//		" \r\n"
	//		"//-------------------------------------------------------------------------------------- \r\n"
	//		"// Global variables \r\n"
	//		"//-------------------------------------------------------------------------------------- \r\n"
	//		"float4x4 g_matWV; \r\n"
	//		"float4x4 g_matWVP; \r\n"
	//		"float4   g_vLightDiffuse; \r\n"
	//		"float3   g_vLightAmbient; \r\n"
	//		"float3   g_vLightDirViewSpace; \r\n"
	//		"float2   g_vFOG;	// FogEnd, FogDist \r\n"
	//		"float3   g_vFogColor; \r\n"
	//		"int      g_nConeLightNum_TOOL; \r\n"
	//		"float4   g_vPos_Range_CL_TOOL[3]; \r\n"
	//		"float4   g_vDiff_CosPhiHalf_CL_TOOL[3]; \r\n"
	//		"float4   g_vAtt_CosHalfThetaSubPhi_CL_TOOL[3]; \r\n"
	//		"float4   g_vDirect_Falloff_CL_TOOL[3]; \r\n"
	//		"float    g_fAttEndLineValue_CL_TOOL[3]; \r\n"
	//		"float    g_fOverLighting_CL_TOOL[3]; \r\n"
	//		"float    g_fSpecularPower = 256.f; \r\n"
	//		"float    g_fSpecularIntensity = 2.f; \r\n"
	//		"float4   g_vWindowSize; \r\n"
	//		"float    g_fAlpha; \r\n"
	//		"float3	  g_vVoxelColor; \r\n"
	//		"float	  g_fCubeMapValue; \r\n"
	//		" \r\n"
	//		"texture g_BaseTexture; \r\n"
	//		"sampler BaseTexSampler = sampler_state  \r\n"
	//		"{ \r\n"
	//		"	Texture = (g_BaseTexture); \r\n"
	//		"}; \r\n"
	//		" \r\n"
	//		" texture g_GlobalCubeTexture; \r\n"
	//		" samplerCUBE CubeTexSampler = sampler_state  \r\n"
	//		" { \r\n"
	//		" 	Texture = (g_GlobalCubeTexture); \r\n"
	//		" }; \r\n"
	//		" \r\n"
	//		"texture g_MaskTexture; \r\n"
	//		"sampler MaskTexSampler = sampler_state  \r\n"
	//		"{ \r\n"
	//		"	Texture = (g_MaskTexture); \r\n"
	//		"}; \r\n"
	//		" \r\n"
	//		"//-------------------------------------------------------------------------------------- \r\n"
	//		"// Basic vertex transformation \r\n"
	//		"//-------------------------------------------------------------------------------------- \r\n"
	//		// Tool 쪽 struct VS_INPUT_TOOL 들은 동일한 구조체로 되어 있어야 한다.
	//		// 동일하지 않으면 VoxelColorVC 쪽에서 에러가 생긴다. Diffuse 를 못 얻어온다.
	//		// Mesh 를 만들 경우 Version 만 보고 Refresh 를 하기 때문이다.
	//		"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"
	//		"{ \r\n"
	//		"	float4 m_vPosition  : POSITION; \r\n"
	//		"	float3 m_vNormal    : NORMAL; \r\n"
	//		"	float4 m_vColor0    : COLOR0; \r\n"
	//		"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
	//		"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
	//		" \r\n"
	//		"struct VS_OUTPUT_TOOL	// editer 렌더용 \r\n"
	//		"{ \r\n"
	//		"	float4 m_vPosition  : POSITION; \r\n"
	//		"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
	//		"	float3 m_vPos       : TEXCOORD1; \r\n"
	//		"	float3 m_vNor       : TEXCOORD2; \r\n"
	//		"	float3 m_vColor0    : TEXCOORD3; \r\n"
	//		"	float3 m_vCubeTexcoord : TEXCOORD4; \r\n"
	//		"	float3 m_vHalf      : TEXCOORD5; \r\n"
	//		"	float  m_fFog       : FOG; \r\n"
	//		"}; \r\n"
	//		" \r\n"
	//		"struct VS_INPUT			// game 렌더용 \r\n"
	//		"{ \r\n"
	//		"	float4 m_vPosition  : POSITION; \r\n"
	//		"#ifdef USE_CUBEMAP \r\n"
	//		"   float3 m_vNormal    : NORMAL; \r\n"
	//		"#else \r\n"
	//		"#ifdef USE_SPECULAR \r\n"
	//		"   float3 m_vNormal    : NORMAL; \r\n"
	//		"#endif \r\n"
	//		"#endif \r\n"
	//		"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
	//		"} Vertex : SEMANTIC_VS_INPUT; \r\n"
	//		" \r\n"
	//		"//---------------------------------------------------------------------------------------------------------- \r\n"
	//		"//				TOOL		editer 렌더용 \r\n"
	//		"VS_OUTPUT_TOOL VS_TOOL( VS_INPUT_TOOL In )  \r\n"
	//		"{ \r\n"
	//		"	VS_OUTPUT_TOOL Out; \r\n"
	//		" \r\n"
	//		"	// Now that we have the calculated weight, add in the final influence \r\n"
	//		"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
	//		"	Out.m_vPos = mul(g_matWV, In.m_vPosition); \r\n"
	//		"	float3 vNor = normalize( mul(g_matWV, In.m_vNormal) ); \r\n"
	//		"	Out.m_vNor = vNor; \r\n"
	//		" \r\n"
	//		"	// HalfVector \r\n"
	//		"	float3 vHalf = -Out.m_vPos.xyz; \r\n"
	//		"	vHalf = normalize( vHalf ); \r\n"
	//		"	vHalf += normalize( g_vLightDirViewSpace.xyz ); \r\n"
	//		"	Out.m_vHalf.xyz = normalize( vHalf ); \r\n"
	//		" \r\n"
	//		"	// CubMap 작업. \r\n"
	//		"	float3 vEyeToVector = normalize(Out.m_vPos); \r\n"
	//		"	Out.m_vCubeTexcoord = reflect(vEyeToVector, vNor); \r\n"
	//		" \r\n"
	//		"	// Pass the texture coordinate \r\n"
	//		"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
	//		" \r\n"
	//		"	float3 vDiffuse = g_vLightDiffuse * 0.5f + g_vLightAmbient; \r\n"
	//		" \r\n"
	//		"	Out.m_vColor0.xyz = vDiffuse.xyz; \r\n"
	//		" \r\n"
	//		"	Out.m_fFog = saturate((g_vFOG.x - Out.m_vPosition.z) / g_vFOG.y); \r\n"
	//		" \r\n"
	//		"	return Out; \r\n"
	//		"} \r\n"
	//		" \r\n"
	//		"float4 PS_TOOL( VS_OUTPUT_TOOL In ) : COLOR0  \r\n"
	//		"{ \r\n"
	//		"	// Texture \r\n"
	//		"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
	//		" \r\n"
	//		"    float3 vNor = normalize( In.m_vNor ); \r\n"
	//		" \r\n"
	//		"    float3 vPointColor = 0.f; \r\n"
	//		"    for ( int i=0; i<g_nConeLightNum_TOOL; ++i ) \r\n"
	//		"    { \r\n"
	//		"        float3 afPosDir = g_vPos_Range_CL_TOOL[i].xyz - In.m_vPos; \r\n"
	//		"        float fLength = length( afPosDir ); \r\n"
	//		"        // 내적 구함. \r\n"
	//		"        afPosDir = normalize( afPosDir ); \r\n"
	//		"        float fDotPL = saturate( dot( afPosDir, vNor ) ); \r\n"
	//		"        // 선형 감쇠, 2차 감쇠, 지수 감쇠 적용 \r\n"
	//		"        float fAttenuationSub = g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].x; \r\n"
	//		"        fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].y * fLength; \r\n"
	//		"        fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].z * fLength * fLength; \r\n"
	//		"        // 최종 감쇠값 \r\n"
	//		"        float fAttenuation = 1.f / fAttenuationSub; \r\n"
	//		"        // 거리 체크 \r\n"
	//		"        float fEnableLength = step(fLength, g_vPos_Range_CL_TOOL[i].w); \r\n"
	//		"    \r\n"
	//		"		 //Cone쪽 계산 \r\n"
	//		"        float3 fRho = dot(afPosDir,g_vDirect_Falloff_CL_TOOL[i].xyz); \r\n"
	//		"        fEnableLength *= step(g_vDiff_CosPhiHalf_CL_TOOL[i].w, fRho); \r\n"
	//		"        fEnableLength *= pow( (fRho - g_vDiff_CosPhiHalf_CL_TOOL[i].w) / g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].w, g_vDirect_Falloff_CL_TOOL[i].w ); \r\n"
	//		"        fEnableLength = min(1.f,fEnableLength); \r\n"
	//		"    \r\n"
	//		"		 // 마지막 \r\n"
	//		"		 float3 vHalf = -In.m_vPos; \r\n"
	//		"		 vHalf = normalize( vHalf ); \r\n"
	//		"		 vHalf += normalize( g_vPos_Range_CL_TOOL[i].xyz - In.m_vPos ); \r\n"
	//		"		 float fSpec = pow( saturate( dot( normalize(vHalf), vNor ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
	//		"    \r\n"
	//		"		 // Edge 부분이 저 감쇠만으로는 적용이 안되서 1 를 빼주었다. \r\n"
	//		//"        vPointColor += g_vDiff_CosPhiHalf_CL_TOOL[i].xyz * max((fAttenuation-1.f),0) * (fDotPL+fSpec) * fEnableLength; \r\n"
	//		"		 float vLightAmountNEW = max((fAttenuation-g_fAttEndLineValue_CL_TOOL[i]),0) * fEnableLength; \r\n"
	//		"		 float vLightAmountDIFF = vLightAmountNEW * fDotPL; \r\n"
	//		"		 float vLightAmountSPEC = vLightAmountNEW * fSpec; \r\n"
	//		"		 vLightAmountNEW = min(vLightAmountDIFF,g_fOverLighting_CL_TOOL[i]); \r\n"
	//		"		 vLightAmountNEW += min(vLightAmountSPEC,g_fOverLighting_CL_TOOL[i]); \r\n"
	//		"        vPointColor += g_vDiff_CosPhiHalf_CL_TOOL[i].xyz * vLightAmountNEW; \r\n"
	//		"    } \r\n"
	//		" \r\n"
	//		" // Direction Specular 계산.\r\n"
	//		" \r\n"
	//		"   float fSpec=0.f; \r\n"
	//		"	{ \r\n"
	//		"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
	//		"		fSpec = pow( saturate( dot( normalize(In.m_vHalf.xyz), vNor ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
	//		"	    fSpec *= vMaskColor.x; \r\n"
	//		"	} \r\n"			
	//		"	\r\n"
	//		" \r\n"
	//		"   vPointColor += In.m_vColor0.xyz * (1.f + fSpec); \r\n"
	//		" \r\n"
	//		"	//------------------------------------------ CubeMapMask \r\n"
	//		"	float fCubeMapValue = g_fCubeMapValue; \r\n"
	//		"	{ \r\n"
	//		"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
	//		"		fCubeMapValue *= vMaskColor.z; \r\n"
	//		"	} \r\n"
	//		" \r\n"
	//		"	//------------------------------------------ CubeMap \r\n"
	//		"	vColor.xyz = vColor.xyz*(1.f-fCubeMapValue) + texCUBE( CubeTexSampler, In.m_vCubeTexcoord ).xyz * fCubeMapValue; \r\n"
	//		" \r\n"
	//		"	vColor.xyz *= min(vPointColor.xyz,3.f); \r\n"
	//		"	vColor.xyz = (vColor.xyz*In.m_fFog) + g_vFogColor*(1.f-In.m_fFog); \r\n"
	//		"	vColor.w *= g_fAlpha; \r\n"
	//		" \r\n"
	//		"	return vColor; \r\n"
	//		"} \r\n"
	//		" \r\n"
	//		"//---------------------------------------------------------------------------------------------------------- \r\n"
	//		"//					technique \r\n"
	//		" \r\n"
	//		"technique tool \r\n"
	//		"{ \r\n"
	//		"	pass high \r\n"
	//		"	{ \r\n"
	//		"		VertexShader = compile vs_3_0 VS_TOOL(); \r\n"
	//		"		PixelShader = compile ps_3_0 PS_TOOL(); \r\n"
	//		"	} \r\n"
	//		"}; \r\n";
	//}

	void SetVoxelColorMaterialTool( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4   g_vLightDiffuse; \r\n"
			"float3   g_vLightAmbient; \r\n"
			"float3   g_vLightDirViewSpace; \r\n"
			"float2   g_vFOG;	// FogEnd, FogDist \r\n"
			"float3   g_vFogColor; \r\n"
			"int      g_nConeLightNum_TOOL; \r\n"
			"float4   g_vPos_Range_CL_TOOL[3]; \r\n"
			"float4   g_vDiff_CosPhiHalf_CL_TOOL[3]; \r\n"
			"float4   g_vAtt_CosHalfThetaSubPhi_CL_TOOL[3]; \r\n"
			"float4   g_vDirect_Falloff_CL_TOOL[3]; \r\n"
			"float    g_fAttEndLineValue_CL_TOOL[3]; \r\n"
			"float    g_fOverLighting_CL_TOOL[3]; \r\n"
			"float    g_fSpecularPower = 256.f; \r\n"
			"float    g_fSpecularIntensity = 2.f; \r\n"
			"float4   g_vWindowSize; \r\n"
			"float    g_fAlpha; \r\n"
			"float3	  g_vVoxelColor; \r\n"
			"float	  g_fCubeMapValue; \r\n"
			" \r\n"
			"texture g_BackBufferTexture; \r\n"
			"sampler BackBufferSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BackBufferTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			" texture g_GlobalCubeTexture; \r\n"
			" samplerCUBE CubeTexSampler = sampler_state  \r\n"
			" { \r\n"
			" 	Texture = (g_GlobalCubeTexture); \r\n"
			" }; \r\n"
			" \r\n"
			"texture g_MaskTexture; \r\n"
			"sampler MaskTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_MaskTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			// Tool 쪽 struct VS_INPUT_TOOL 들은 동일한 구조체로 되어 있어야 한다.
			// 동일하지 않으면 VoxelColorVC 쪽에서 에러가 생긴다. Diffuse 를 못 얻어온다.
			// Mesh 를 만들 경우 Version 만 보고 Refresh 를 하기 때문이다.
			"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float4 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_OUTPUT_TOOL	// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float3 m_vPos       : TEXCOORD1; \r\n"
			"	float3 m_vNor       : TEXCOORD2; \r\n"
			"	float3 m_vColor0    : TEXCOORD3; \r\n"
			"	float3 m_vCubeTexcoord : TEXCOORD4; \r\n"
			"	float3 m_vHalf      : TEXCOORD5; \r\n"
			"	float  m_fFog       : FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_INPUT			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"   float3 m_vNormal    : NORMAL; \r\n"
			"#else \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"   float3 m_vNormal    : NORMAL; \r\n"
			"#endif \r\n"
			"#endif \r\n"
			"	float4 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//				TOOL		editer 렌더용 \r\n"
			"VS_OUTPUT_TOOL VS_TOOL( VS_INPUT_TOOL In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_TOOL Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	Out.m_vPos = mul(g_matWV, In.m_vPosition); \r\n"
			"	float3 vNor = normalize( mul(g_matWV, In.m_vNormal) ); \r\n"
			"	Out.m_vNor = vNor; \r\n"
			" \r\n"
			"	// HalfVector \r\n"
			"	float3 vHalf = -Out.m_vPos.xyz; \r\n"
			"	vHalf = normalize( vHalf ); \r\n"
			"	vHalf += normalize( g_vLightDirViewSpace.xyz ); \r\n"
			"	Out.m_vHalf.xyz = normalize( vHalf ); \r\n"
			" \r\n"
			"	// CubMap 작업. \r\n"
			"	float3 vEyeToVector = normalize(Out.m_vPos); \r\n"
			"	Out.m_vCubeTexcoord = reflect(vEyeToVector, vNor); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	// Get Color \r\n"
			"	Out.m_vColor0 = In.m_vColor0; \r\n"
			" \r\n"
			"	float3 vDiffuse = g_vLightDiffuse * 0.5f + g_vLightAmbient; \r\n"
			" \r\n"
			"	Out.m_vColor0.xyz *= vDiffuse.xyz; \r\n"
			" \r\n"
			"	Out.m_fFog = saturate((g_vFOG.x - Out.m_vPosition.z) / g_vFOG.y); \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_TOOL( VS_OUTPUT_TOOL In ) : COLOR0  \r\n"
			"{ \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"    float3 vNor = normalize( In.m_vNor ); \r\n"
			" \r\n"
			"    float3 vPointColor = 0.f; \r\n"
			"    for ( int i=0; i<g_nConeLightNum_TOOL; ++i ) \r\n"
			"    { \r\n"
			"        float3 afPosDir = g_vPos_Range_CL_TOOL[i].xyz - In.m_vPos; \r\n"
			"        float fLength = length( afPosDir ); \r\n"
			"        // 내적 구함. \r\n"
			"        afPosDir = normalize( afPosDir ); \r\n"
			"        float fDotPL = saturate( dot( afPosDir, vNor ) ); \r\n"
			"        // 선형 감쇠, 2차 감쇠, 지수 감쇠 적용 \r\n"
			"        float fAttenuationSub = g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].x; \r\n"
			"        fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].y * fLength; \r\n"
			"        fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].z * fLength * fLength; \r\n"
			"        // 최종 감쇠값 \r\n"
			"        float fAttenuation = 1.f / fAttenuationSub; \r\n"
			"        // 거리 체크 \r\n"
			"        float fEnableLength = step(fLength, g_vPos_Range_CL_TOOL[i].w); \r\n"
			"    \r\n"
			"		 //Cone쪽 계산 \r\n"
			"        float3 fRho = dot(afPosDir,g_vDirect_Falloff_CL_TOOL[i].xyz); \r\n"
			"        fEnableLength *= step(g_vDiff_CosPhiHalf_CL_TOOL[i].w, fRho); \r\n"
			"        fEnableLength *= pow( (fRho - g_vDiff_CosPhiHalf_CL_TOOL[i].w) / g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].w, g_vDirect_Falloff_CL_TOOL[i].w ); \r\n"
			"        fEnableLength = min(1.f,fEnableLength); \r\n"
			"    \r\n"
			"		 // 마지막 \r\n"
			"		 float3 vHalf = -In.m_vPos; \r\n"
			"		 vHalf = normalize( vHalf ); \r\n"
			"		 vHalf += normalize( g_vPos_Range_CL_TOOL[i].xyz - In.m_vPos ); \r\n"
			"		 float fSpec = pow( saturate( dot( normalize(vHalf), vNor ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
			"    \r\n"
			"		 // Edge 부분이 저 감쇠만으로는 적용이 안되서 1 를 빼주었다. \r\n"
			"		 float vLightAmountNEW = max((fAttenuation-g_fAttEndLineValue_CL_TOOL[i]),0) * fEnableLength; \r\n"
			"		 float vLightAmountDIFF = vLightAmountNEW * fDotPL; \r\n"
			"		 float vLightAmountSPEC = vLightAmountNEW * fSpec; \r\n"
			"		 vLightAmountNEW = min(vLightAmountDIFF,g_fOverLighting_CL_TOOL[i]); \r\n"
			"		 vLightAmountNEW += min(vLightAmountSPEC,g_fOverLighting_CL_TOOL[i]); \r\n"
			"        vPointColor += g_vDiff_CosPhiHalf_CL_TOOL[i].xyz * vLightAmountNEW; \r\n"
			"    } \r\n"
			" \r\n"
			" // Direction Specular 계산.\r\n"
			" \r\n"
			"   float fSpec=0.f; \r\n"
			"	{ \r\n"
			"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"		fSpec = pow( saturate( dot( normalize(In.m_vHalf.xyz), vNor ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
			"	    fSpec *= vMaskColor.x; \r\n"
			"	} \r\n"			
			"	\r\n"
			" \r\n"
			"   vPointColor += In.m_vColor0.xyz * (1.f + fSpec); \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMapMask \r\n"
			"	float fCubeMapValue = g_fCubeMapValue; \r\n"
			"	{ \r\n"
			"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"		fCubeMapValue *= vMaskColor.z; \r\n"
			"	} \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMap \r\n"
			"	vColor.xyz = vColor.xyz*(1.f-fCubeMapValue) + texCUBE( CubeTexSampler, In.m_vCubeTexcoord ).xyz * fCubeMapValue; \r\n"
			" \r\n"
			"	vColor.xyz *= min(vPointColor.xyz,3.f); \r\n"
			"	vColor.xyz = (vColor.xyz*In.m_fFog) + g_vFogColor*(1.f-In.m_fFog); \r\n"
			"	vColor.w *= g_fAlpha; \r\n"
			" \r\n"
			"	return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique tool \r\n"
			"{ \r\n"
			"	pass high \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_TOOL(); \r\n"
			"		PixelShader = compile ps_3_0 PS_TOOL(); \r\n"
			"	} \r\n"
			"}; \r\n";
	}

	void SetAmbientCubeMaterialTool( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4   g_vLightDiffuse; \r\n"
			"float3   g_vLightAmbient; \r\n"
			"float3   g_vLightDirViewSpace; \r\n"
			"float2   g_vFOG;	// FogEnd, FogDist \r\n"
			"float3   g_vFogColor; \r\n"
			"int      g_nPointLightNum_TOOL; \r\n"
			"float4   g_vPos_Range_PL_TOOL[12]; \r\n"
			"float4   g_vDiff_OverLighting_PL_TOOL[12]; \r\n"
			"float4   g_vAtt_PL_TOOL[12]; \r\n"
			"int      g_nConeLightNum_TOOL; \r\n"
			"float4   g_vPos_Range_CL_TOOL[3]; \r\n"
			"float4   g_vDiff_CosPhiHalf_CL_TOOL[3]; \r\n"
			"float4   g_vAtt_CosHalfThetaSubPhi_CL_TOOL[3]; \r\n"
			"float4   g_vDirect_Falloff_CL_TOOL[3]; \r\n"
			"float    g_fAttEndLineValue_CL_TOOL[3]; \r\n"
			"float    g_fOverLighting_CL_TOOL[3]; \r\n"
			"float    g_fSpecularPower = 256.f; \r\n"
			"float    g_fSpecularIntensity = 2.f; \r\n"
			"float4   g_vWindowSize; \r\n"
			"float    g_fAlpha; \r\n"
			"float3	  g_vAmbientCube[6]; \r\n"
			"float	  g_fCubeMapValue; \r\n"
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			" texture g_GlobalCubeTexture; \r\n"
			" samplerCUBE CubeTexSampler = sampler_state  \r\n"
			" { \r\n"
			" 	Texture = (g_GlobalCubeTexture); \r\n"
			" }; \r\n"
			" \r\n"
			"texture g_MaskTexture; \r\n"
			"sampler MaskTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_MaskTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			// Tool 쪽 struct VS_INPUT_TOOL 들은 동일한 구조체로 되어 있어야 한다.
			// 동일하지 않으면 VoxelColorVC 쪽에서 에러가 생긴다. Diffuse 를 못 얻어온다.
			// Mesh 를 만들 경우 Version 만 보고 Refresh 를 하기 때문이다.
			"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float4 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_OUTPUT_TOOL	// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float3 m_vPos       : TEXCOORD1; \r\n"
			"	float3 m_vNor       : TEXCOORD2; \r\n"
			"	float3 m_vColor0    : TEXCOORD3; \r\n"
			"	float3 m_vCubeTexcoord : TEXCOORD4; \r\n"
			"	float3 m_vHalf      : TEXCOORD5; \r\n"
			"	float  m_fFog       : FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_INPUT			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//				TOOL		editer 렌더용 \r\n"
			"VS_OUTPUT_TOOL VS_TOOL( VS_INPUT_TOOL In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_TOOL Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	Out.m_vPos = mul(g_matWV, In.m_vPosition); \r\n"
			"	Out.m_vNor = normalize( mul(g_matWV, In.m_vNormal) ); \r\n"
			" \r\n"
			"	// HalfVector \r\n"
			"	float3 vHalf = -Out.m_vPos.xyz; \r\n"
			"	vHalf = normalize( vHalf ); \r\n"
			"	vHalf += normalize( g_vLightDirViewSpace.xyz ); \r\n"
			"	Out.m_vHalf.xyz = normalize( vHalf ); \r\n"
			" \r\n"
			"	// CubMap 작업. \r\n"
			"	float3 vEyeToVector = normalize(Out.m_vPos); \r\n"
			"	Out.m_vCubeTexcoord = reflect(vEyeToVector, Out.m_vNor); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	// Get Color \r\n"
			"	Out.m_vColor0 = In.m_vColor0; \r\n"
			" \r\n"
			"	float fDiffuseDot = saturate( dot( g_vLightDirViewSpace, Out.m_vNor ) ); \r\n"
			"	float3 vDiffuse = g_vLightDiffuse * fDiffuseDot + g_vLightAmbient; \r\n"
			" \r\n"
			"	Out.m_vColor0.xyz *= vDiffuse.xyz; \r\n"
			" \r\n"
			"	Out.m_fFog = saturate((g_vFOG.x - Out.m_vPosition.z) / g_vFOG.y); \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_TOOL( VS_OUTPUT_TOOL In ) : COLOR0  \r\n"
			"{ \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"    float3 vNor = normalize( In.m_vNor ); \r\n"
			" \r\n"
			"    float3 vPointColor = 0.f; \r\n"
			"    for ( int i=0; i<g_nPointLightNum_TOOL; ++i ) \r\n"
			"    { \r\n"
			"        float3 afPosDir = g_vPos_Range_PL_TOOL[i].xyz - In.m_vPos; \r\n"
			"        float fLength = length( afPosDir ); \r\n"
			"        // 내적 구함. \r\n"
			"        afPosDir = normalize( afPosDir ); \r\n"
			"        float fDotPL = saturate( dot( afPosDir, vNor ) ); \r\n"
			"        // 선형 감쇠, 2차 감쇠, 지수 감쇠 적용 \r\n"
			"        float fAttenuationSub = g_vAtt_PL_TOOL[i].x; \r\n"
			"        fAttenuationSub += g_vAtt_PL_TOOL[i].y * fLength; \r\n"
			"        fAttenuationSub += g_vAtt_PL_TOOL[i].z * fLength * fLength; \r\n"
			"        // 최종 감쇠값 \r\n"
			"        float fAttenuation = 1.f / fAttenuationSub; \r\n"
			"        // 거리 체크 \r\n"
			"        float fEnableLength = step(fLength, g_vPos_Range_PL_TOOL[i].w); \r\n"
			"        // 마지막 \r\n"
			"	     // Edge 부분이 저 감쇠만으로는 적용이 안되서 1 를 빼주었다. \r\n"
			"		 fAttenuation = max((fAttenuation-1.f),0) * fDotPL * fEnableLength; \r\n"
			"		 fAttenuation = min(fAttenuation,g_vDiff_OverLighting_PL_TOOL[i].w); \r\n"
			"        vPointColor += g_vDiff_OverLighting_PL_TOOL[i].xyz * fAttenuation; \r\n"
			"    } \r\n"
			" \r\n"
			"    for ( int i=0; i<g_nConeLightNum_TOOL; ++i ) \r\n"
			"    { \r\n"
			"        float3 afPosDir = g_vPos_Range_CL_TOOL[i].xyz - In.m_vPos; \r\n"
			"        float fLength = length( afPosDir ); \r\n"
			"        // 내적 구함. \r\n"
			"        afPosDir = normalize( afPosDir ); \r\n"
			"        float fDotPL = saturate( dot( afPosDir, vNor ) ); \r\n"
			"        // 선형 감쇠, 2차 감쇠, 지수 감쇠 적용 \r\n"
			"        float fAttenuationSub = g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].x; \r\n"
			"        fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].y * fLength; \r\n"
			"        fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].z * fLength * fLength; \r\n"
			"        // 최종 감쇠값 \r\n"
			"        float fAttenuation = 1.f / fAttenuationSub; \r\n"
			"        // 거리 체크 \r\n"
			"        float fEnableLength = step(fLength, g_vPos_Range_CL_TOOL[i].w); \r\n"
			"    \r\n"
			"		 //Cone쪽 계산 \r\n"
			"        float3 fRho = dot(afPosDir,g_vDirect_Falloff_CL_TOOL[i].xyz); \r\n"
			"        fEnableLength *= step(g_vDiff_CosPhiHalf_CL_TOOL[i].w, fRho); \r\n"
			"        fEnableLength *= pow( (fRho - g_vDiff_CosPhiHalf_CL_TOOL[i].w) / g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].w, g_vDirect_Falloff_CL_TOOL[i].w ); \r\n"
			"        fEnableLength = min(1.f,fEnableLength); \r\n"
			"    \r\n"
			"		 // 마지막 \r\n"
			"		 float3 vHalf = -In.m_vPos; \r\n"
			"		 vHalf = normalize( vHalf ); \r\n"
			"		 vHalf += normalize( g_vPos_Range_CL_TOOL[i].xyz - In.m_vPos ); \r\n"
			"		 float fSpec = pow( saturate( dot( normalize(vHalf), vNor ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
			"    \r\n"
			"		 // Edge 부분이 저 감쇠만으로는 적용이 안되서 1 를 빼주었다. \r\n"
			"		 float vLightAmountNEW = max((fAttenuation-g_fAttEndLineValue_CL_TOOL[i]),0) * fEnableLength; \r\n"
			"		 float vLightAmountDIFF = vLightAmountNEW * fDotPL; \r\n"
			"		 float vLightAmountSPEC = vLightAmountNEW * fSpec; \r\n"
			"		 vLightAmountNEW = min(vLightAmountDIFF,g_fOverLighting_CL_TOOL[i]); \r\n"
			"		 vLightAmountNEW += min(vLightAmountSPEC,g_fOverLighting_CL_TOOL[i]); \r\n"
			"        vPointColor += g_vDiff_CosPhiHalf_CL_TOOL[i].xyz * vLightAmountNEW; \r\n"
			"    } \r\n"
			" \r\n"
			" // Direction Specular 계산.\r\n"
			" \r\n"
			"   float fSpec=0.f; \r\n"
			"	{ \r\n"
			"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"		fSpec = pow( saturate( dot( normalize(In.m_vHalf.xyz), vNor ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
			"	    fSpec *= vMaskColor.x; \r\n"
			"	} \r\n"			
			"	\r\n"
			" \r\n"
			"   vPointColor += In.m_vColor0.xyz * (1.f + fSpec); \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMapMask \r\n"
			"	float fCubeMapValue = g_fCubeMapValue; \r\n"
			"	{ \r\n"
			"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"		fCubeMapValue *= vMaskColor.z; \r\n"
			"	} \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMap \r\n"
			"	vColor.xyz = vColor.xyz*(1.f-fCubeMapValue) + texCUBE( CubeTexSampler, In.m_vCubeTexcoord ).xyz * fCubeMapValue; \r\n"
			" \r\n"
			"	vColor.xyz *= min(vPointColor.xyz,3.f); \r\n"
			"	vColor.xyz = (vColor.xyz*In.m_fFog) + g_vFogColor*(1.f-In.m_fFog); \r\n"
			"	vColor.w *= g_fAlpha; \r\n"
			" \r\n"
			"	return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique tool \r\n"
			"{ \r\n"
			"	pass high \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_TOOL(); \r\n"
			"		PixelShader = compile ps_3_0 PS_TOOL(); \r\n"
			"	} \r\n"
			"}; \r\n";
	}

	void SetDecalMaterialTool( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4   g_vLightDiffuse; \r\n"
			"float3   g_vLightAmbient; \r\n"
			"float3   g_vLightDirViewSpace; \r\n"
			"float2   g_vFOG;	// FogEnd, FogDist \r\n"
			"float3   g_vFogColor; \r\n"
			"int      g_nPointLightNum_TOOL; \r\n"
			"float4   g_vPos_Range_PL_TOOL[12]; \r\n"
			"float4   g_vDiff_OverLighting_PL_TOOL[12]; \r\n"
			"float4   g_vAtt_PL_TOOL[12]; \r\n"
			"int      g_nConeLightNum_TOOL; \r\n"
			"float4   g_vPos_Range_CL_TOOL[3]; \r\n"
			"float4   g_vDiff_CosPhiHalf_CL_TOOL[3]; \r\n"
			"float4   g_vAtt_CosHalfThetaSubPhi_CL_TOOL[3]; \r\n"
			"float4   g_vDirect_Falloff_CL_TOOL[3]; \r\n"
			"float    g_fAttEndLineValue_CL_TOOL[3]; \r\n"
			"float    g_fOverLighting_CL_TOOL[3]; \r\n"
			"float    g_fSpecularPower = 256.f; \r\n"
			"float    g_fSpecularIntensity = 2.f; \r\n"
			"float    g_fAlpha; \r\n"
			"float2   g_vLightMapUV_Offset; \r\n"
			"float2   g_vLightMapUV_Multiply; \r\n"
			"float3	  g_vVoxelColor; \r\n"
			"float3	  g_vDecalBelndColor; \r\n"
			"float	  g_fCubeMapValue; \r\n"
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			" texture g_GlobalCubeTexture; \r\n"
			" samplerCUBE CubeTexSampler = sampler_state  \r\n"
			" { \r\n"
			" 	Texture = (g_GlobalCubeTexture); \r\n"
			" }; \r\n"
			" \r\n"
			"texture g_MaskTexture; \r\n"
			"sampler MaskTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_MaskTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			// Tool 쪽 struct VS_INPUT_TOOL 들은 동일한 구조체로 되어 있어야 한다.
			// 동일하지 않으면 VoxelColorVC 쪽에서 에러가 생긴다. Diffuse 를 못 얻어온다.
			// Mesh 를 만들 경우 Version 만 보고 Refresh 를 하기 때문이다.
			"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float4 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_OUTPUT_TOOL	// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float3 m_vPos       : TEXCOORD1; \r\n"
			"	float3 m_vNor       : TEXCOORD2; \r\n"
			"	float4 m_vColor0    : TEXCOORD3; \r\n"
			"	float3 m_vCubeTexcoord : TEXCOORD4; \r\n"
			"	float3 m_vHalf      : TEXCOORD5; \r\n"
			"	float  m_fFog       : FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_INPUT_DECAL			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"   float3 m_vNormal    : NORMAL; \r\n"
			"#else \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"   float3 m_vNormal    : NORMAL; \r\n"
			"#endif \r\n"
			"#endif \r\n"
			"	float4 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//				TOOL		editer 렌더용 \r\n"
			"VS_OUTPUT_TOOL VS_TOOL( VS_INPUT_TOOL In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_TOOL Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	Out.m_vPos = mul(g_matWV, In.m_vPosition); \r\n"
			"	Out.m_vNor = normalize( mul(g_matWV, In.m_vNormal) ); \r\n"
			" \r\n"
			"	// HalfVector \r\n"
			"	float3 vHalf = -Out.m_vPos.xyz; \r\n"
			"	vHalf = normalize( vHalf ); \r\n"
			"	vHalf += normalize( g_vLightDirViewSpace.xyz ); \r\n"
			"	Out.m_vHalf.xyz = normalize( vHalf ); \r\n"
			" \r\n"
			"	// CubMap 작업. \r\n"
			"	float3 vEyeToVector = normalize(Out.m_vPos); \r\n"
			"	Out.m_vCubeTexcoord = reflect(vEyeToVector, Out.m_vNor); \r\n"
			" \r\n"
			"	// Get Color \r\n"
			"	Out.m_vColor0 = In.m_vColor0; \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	float fDiffuseDot = saturate( dot( g_vLightDirViewSpace, Out.m_vNor ) ); \r\n"
			"	float3 vDiffuse = g_vLightDiffuse * fDiffuseDot + g_vLightAmbient; \r\n"
			" \r\n"
			"	Out.m_vColor0.xyz *= vDiffuse.xyz; \r\n"
			" \r\n"
			"	Out.m_fFog = saturate((g_vFOG.x - Out.m_vPosition.z) / g_vFOG.y); \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_TOOL( VS_OUTPUT_TOOL In, uniform bool bShading ) : COLOR0  \r\n"
			"{ \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float3 vNor = normalize( In.m_vNor ); \r\n"
			" \r\n"
			"	float3 vPointColor = 0.f; \r\n"
			"   if ( bShading ) \r\n"
			"   { \r\n"
			"	\r\n"
			"		for ( int i=0; i<g_nPointLightNum_TOOL; ++i ) \r\n"
			"		{ \r\n"
			"			float3 afPosDir = g_vPos_Range_PL_TOOL[i].xyz - In.m_vPos; \r\n"
			"			float fLength = length( afPosDir ); \r\n"
			"			 // 내적 구함. \r\n"
			"			afPosDir = normalize( afPosDir ); \r\n"
			"			float fDotPL = saturate( dot( afPosDir, vNor ) ); \r\n"
			"			// 선형 감쇠, 2차 감쇠, 지수 감쇠 적용 \r\n"
			"			float fAttenuationSub = g_vAtt_PL_TOOL[i].x; \r\n"
			"			fAttenuationSub += g_vAtt_PL_TOOL[i].y * fLength; \r\n"
			"			fAttenuationSub += g_vAtt_PL_TOOL[i].z * fLength * fLength; \r\n"
			"			// 최종 감쇠값 \r\n"
			"			float fAttenuation = 1.f / fAttenuationSub; \r\n"
			"			// 거리 체크 \r\n"
			"			float fEnableLength = step(fLength, g_vPos_Range_PL_TOOL[i].w); \r\n"
			"			// 마지막 \r\n"
			"			// Edge 부분이 저 감쇠만으로는 적용이 안되서 1 를 빼주었다. \r\n"
			"		 fAttenuation = max((fAttenuation-1.f),0) * fDotPL * fEnableLength; \r\n"
			"		 fAttenuation = min(fAttenuation,g_vDiff_OverLighting_PL_TOOL[i].w); \r\n"
			"        vPointColor += g_vDiff_OverLighting_PL_TOOL[i].xyz * fAttenuation; \r\n"
			"		} \r\n"
			"	\r\n"
			"		for ( int i=0; i<g_nConeLightNum_TOOL; ++i ) \r\n"
			"		 { \r\n"
			"			float3 afPosDir = g_vPos_Range_CL_TOOL[i].xyz - In.m_vPos; \r\n"
			"			float fLength = length( afPosDir ); \r\n"
			"			// 내적 구함. \r\n"
			"			 afPosDir = normalize( afPosDir ); \r\n"
			"			float fDotPL = saturate( dot( afPosDir, vNor ) ); \r\n"
			"			// 선형 감쇠, 2차 감쇠, 지수 감쇠 적용 \r\n"
			"			float fAttenuationSub = g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].x; \r\n"
			"			fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].y * fLength; \r\n"
			"			fAttenuationSub += g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].z * fLength * fLength; \r\n"
			"			// 최종 감쇠값 \r\n"
			"			float fAttenuation = 1.f / fAttenuationSub; \r\n"
			"			// 거리 체크 \r\n"
			"			 float fEnableLength = step(fLength, g_vPos_Range_CL_TOOL[i].w); \r\n"
			"		 \r\n"
			"			//Cone쪽 계산 \r\n"
			"			float3 fRho = dot(afPosDir,g_vDirect_Falloff_CL_TOOL[i].xyz); \r\n"
			"			fEnableLength *= step(g_vDiff_CosPhiHalf_CL_TOOL[i].w, fRho); \r\n"
			"			fEnableLength *= pow( (fRho - g_vDiff_CosPhiHalf_CL_TOOL[i].w) / g_vAtt_CosHalfThetaSubPhi_CL_TOOL[i].w, g_vDirect_Falloff_CL_TOOL[i].w ); \r\n"
			"			 fEnableLength = min(1.f,fEnableLength); \r\n"
			"		 \r\n"
			"			// 마지막 \r\n"
			"			float3 vHalf = -In.m_vPos; \r\n"
			"			vHalf = normalize( vHalf ); \r\n"
			"			vHalf += normalize( g_vPos_Range_CL_TOOL[i].xyz - In.m_vPos ); \r\n"
			"			float fSpec = pow( saturate( dot( normalize(vHalf), vNor ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
			"		   // Edge 부분이 저 감쇠만으로는 적용이 안되서 1 를 빼주었다. \r\n"
			"		   float vLightAmountNEW = max((fAttenuation-g_fAttEndLineValue_CL_TOOL[i]),0) * fEnableLength; \r\n"
			"		   float vLightAmountDIFF = vLightAmountNEW * fDotPL; \r\n"
			"		   float vLightAmountSPEC = vLightAmountNEW * fSpec; \r\n"
			"		   vLightAmountNEW = min(vLightAmountDIFF,g_fOverLighting_CL_TOOL[i]); \r\n"
			"		   vLightAmountNEW += min(vLightAmountSPEC,g_fOverLighting_CL_TOOL[i]); \r\n"
			"          vPointColor += g_vDiff_CosPhiHalf_CL_TOOL[i].xyz * vLightAmountNEW; \r\n"
			"		} \r\n"
			"   } \r\n"
			" // Direction Specular 계산.\r\n"
			" \r\n"
			"   float fSpec=0.f; \r\n"
			"	{ \r\n"
			"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"		fSpec = pow( saturate( dot( normalize(In.m_vHalf.xyz), vNor ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
			"	    fSpec *= vMaskColor.x; \r\n"
			"	} \r\n"			
			"	\r\n"
			" \r\n"
			"   vPointColor += In.m_vColor0.xyz * (1.f + fSpec); \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMapMask \r\n"
			"	float fCubeMapValue = g_fCubeMapValue; \r\n"
			"	{ \r\n"
			"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"		fCubeMapValue *= vMaskColor.z; \r\n"
			"	} \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMap \r\n"
			"	vColor.xyz = vColor.xyz*(1.f-fCubeMapValue) + texCUBE( CubeTexSampler, In.m_vCubeTexcoord ).xyz * fCubeMapValue; \r\n"
			" \r\n"
			"	vColor.xyz *= min(vPointColor.xyz,3.f); \r\n"
			"	if ( !bShading ) \r\n"
			"	{ \r\n"
			"		vColor.xyz = (vColor.xyz*vColor.w)+(g_vDecalBelndColor*(1.f-vColor.w)); \r\n"
			"	} \r\n"
			"	vColor.xyz = (vColor.xyz*In.m_fFog) + g_vFogColor*(1.f-In.m_fFog); \r\n"
			"	vColor.w *= In.m_vColor0.w * g_fAlpha; \r\n"
			" \r\n"
			"	return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique tool \r\n"
			"{ \r\n"
			"	pass high \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_TOOL(); \r\n"
			"		PixelShader = compile ps_3_0 PS_TOOL(true); \r\n"
			"	} \r\n"
			"	pass pass2 \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_TOOL(); \r\n"
			"		PixelShader = compile ps_3_0 PS_TOOL(false); \r\n"
			"	} \r\n"
			"}; \r\n";
	}
};