#include "pch.h"

#include "NSMaterialManager.h"

// ----------------------------------------------------------------------------
#include "../../SigmaCore/DebugInclude.h"
// ----------------------------------------------------------------------------

namespace NSMaterialManager
{
	void SetDefault_PS30_FX( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWorld; \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4x4 g_matView; \r\n"
			"float4x4 g_matProj; \r\n"
			"float4   g_vLightDiffuse; \r\n"
			"float    g_fSpecularPower = 256.f; \r\n"
			"float    g_fSpecularIntensity = 2.f; \r\n"
			"float4   g_vPos_Range_CL_TOOL[2]; \r\n"
			"float4   g_vDiff_CosPhiHalf_CL_TOOL[2]; \r\n"
			"float4   g_vAtt_CosHalfThetaSubPhi_CL_TOOL[2]; \r\n"
			"float4   g_vDirect_Falloff_CL_TOOL[2]; \r\n"
			"float4   g_vWindowSize; \r\n"
			"float    g_fAlpha; \r\n"
			"float2   g_vLightMapUV_Offset; \r\n"
			"float2   g_vLightMapUV_Multiply; \r\n"
			"float4	  g_vVoxelColor; \r\n"
			"float	  g_fCubeMapValue; \r\n"
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_LightMapDayTex; \r\n"
			"sampler LightMapTexSampler_1st = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_LightMapDayTex); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_LightMapTex_DS_1st; \r\n"
			"sampler LightMapTexSampler_DS_1st = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_LightMapTex_DS_1st); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_LightMapTex_DS_2nd; \r\n"
			"sampler LightMapTexSampler_DS_2nd = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_LightMapTex_DS_2nd); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_MaskTexture; \r\n"
			"sampler MaskTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_MaskTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_pTextureLodBlend; \r\n"
			"sampler TextureLodBlendSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_pTextureLodBlend); \r\n"
			"}; \r\n"			
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float3 m_vBinormal  : BINORMAL; \r\n"
			"	float3 m_vTangent   : TANGENT; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_INPUT			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"   float3 m_vNormal		: NORMAL; \r\n"
			"	float4 m_vAlbedoXY_LMZW	: TEXCOORD0;	// 합쳐진 것을 사용할 경우 m_vAlbedoXY_LMZW 를 사용합니다. \r\n"
			"	// m_vLightmapUV 이름이 있으면, LightMap을 생성해준다. \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"struct VS_INPUT_INSTANCING			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition			: POSITION; \r\n"
			"   float3 m_vNormal			: NORMAL; \r\n"
			"	float4 m_vAlbedoXY_LMZW		: TEXCOORD0;	// 합쳐진 것을 사용할 경우 m_vAlbedoXY_LMZW 를 사용합니다. \r\n"
			"	float4 m_vVC_AC0XY					: TEXCOORD1; \r\n"
			"	float4 m_vMatrix1_AC0W				: TEXCOORD2; \r\n"
			"	float4 m_vMatrix2_LMOffsetX			: TEXCOORD3; \r\n"
			"	float4 m_vMatrix3_LMOffsetY			: TEXCOORD4; \r\n"
			"	float4 m_vMatrix4					: TEXCOORD5; \r\n"
			"	float4 m_vAmbientCube_0Z_12_3X		: TEXCOORD6; \r\n"
			"	float4 m_vAmbientCube_3YZ_45		: TEXCOORD7; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_ALBEDO		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"	float2 m_vLightmapUV	: TEXCOORD1; \r\n"
			"	float3 m_vNormal		: TEXCOORD2; \r\n"
			"	float3 m_vPosProjSpace	: TEXCOORD3; \r\n"
			"}; \r\n"
			" \r\n"
			"struct PS_DEFFERED_OUT		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vColor0	: COLOR0; \r\n"
			"	float4 m_vColor1	: COLOR1; \r\n"
			"	float4 m_vColor2	: COLOR2; \r\n"
			"	float4 m_vColor3	: COLOR3; \r\n"
			"}; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.3.0 Albedo \r\n"
			"VS_OUTPUT_ALBEDO VS_3( VS_INPUT In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	Out.m_vPosProjSpace = Out.m_vPosition.xyw; \r\n"
			"	Out.m_vNormal = normalize( mul(g_matWV, In.m_vNormal) ); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vAlbedoXY_LMZW.xy; \r\n"
			"	Out.m_vLightmapUV = In.m_vAlbedoXY_LMZW.zw; \r\n"
			"	Out.m_vLightmapUV += g_vLightMapUV_Offset; \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			" float ExportVector2ToFloat( float fX, float fY ) // fX 와 fY 는 1 이하여야 한다. \r\n"	
			" { \r\n"
			" 	float2 vecEncode = floor( float2( fX * 255.0f, fY * 255.0f ) ); \r\n"
			" 	float fResult = ( ( vecEncode.x * 256.0f ) + vecEncode.y ) / 65535.0f; \r\n" // 256 - <<8 한다는 개념
			" 	return fResult; \r\n"
			" } \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_3( VS_OUTPUT_ALBEDO In, uniform bool bSoftAlpha, uniform int nPL1, uniform int nPL2 ) \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float3 vNorNormalize = normalize( In.m_vNormal ); \r\n"
			"	float3 vNorConvert = (vNorNormalize+1.f)*0.5f; \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.z + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	// 라이트맵  \r\n"
			"   float4 vLightMap_Indirect = tex2D( LightMapTexSampler_1st, In.m_vLightmapUV ) * 3.f; \r\n"
			"   float4 vLightMap_DS_1st = tex2D( LightMapTexSampler_DS_1st, In.m_vLightmapUV ); \r\n"
			"   float4 vLightMap_DS_2nd = tex2D( LightMapTexSampler_DS_2nd, In.m_vLightmapUV ); \r\n"
			" \r\n"
			"	float3 vAddColor = vLightMap_Indirect.xyz; \r\n"
			"	if ( nPL1==1 ) \r\n"
			"	{ \r\n"
			"		float fLightAmount = vLightMap_DS_1st.z; \r\n"
			"		fLightAmount *= vLightMap_DS_1st.x*3.f;  \r\n"
			"		vAddColor += g_vDiff_CosPhiHalf_CL_TOOL[0].xyz * fLightAmount; \r\n"
			"	} \r\n"
			"	if ( nPL2==1 ) \r\n"
			"	{ \r\n"
			"		float fLightAmount = vLightMap_DS_2nd.z; \r\n"
			"		fLightAmount *= vLightMap_DS_2nd.x*3.f;  \r\n"
			"		vAddColor += g_vDiff_CosPhiHalf_CL_TOOL[1].xyz * fLightAmount; \r\n"
			"	} \r\n"
			" \r\n"
			"	if ( bSoftAlpha ) \r\n"
			"	{ \r\n"
			"		vAddColor += g_vLightDiffuse.xyz * vLightMap_DS_1st.z; \r\n"		// SoftAlpha라면 DirectionLight Diffuse를 넣는다. Opaque나 HardAlpha는 LBuffer에서 한다.
			"	} \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"   vOut.m_vColor1 = float4(vNorNormalize,vColor.w); \r\n"
			"   vOut.m_vColor2 = float4(g_fSpecularIntensity*0.5f*vMaskColor.r,g_fSpecularPower/256.f,g_fCubeMapValue*vMaskColor.b,vColor.w); \r\n"
			"	vOut.m_vColor3.x = ExportVector2ToFloat( min(vAddColor.x * 0.33333333f, 1.f), min(vAddColor.y * 0.33333333f, 1.f) ); \r\n"
			"	vOut.m_vColor3.y = ExportVector2ToFloat( min(vAddColor.z * 0.33333333f, 1.f), vNorConvert.x ); \r\n"
			"	vOut.m_vColor3.z = ExportVector2ToFloat( vNorConvert.y, vNorConvert.z ); \r\n"
			"	if ( bSoftAlpha ) \r\n"
			"	{ \r\n"
			"		vOut.m_vColor3.w = 1.f; \r\n"	// AlphaBlend 때문에 어쩔수 없이 1을 넣어야 한다.
			"	} \r\n"
			"	else \r\n"
			"	{ \r\n"
			"		vOut.m_vColor3.w = vLightMap_DS_1st.z + 0.00001f; \r\n"		// 00001f - 라이트맵은 PS_LSPASS 에서 빛계산을 해야하기 때문에 Zero 로 만들지 못하게 한다.
			"	} \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.3.0 Albedo INSTANCING \r\n"
			"VS_OUTPUT_ALBEDO VS_INSTANCING( VS_INPUT_INSTANCING In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO Out; \r\n"
			" \r\n"
			"	g_matWorld[0].xyzw = float4(In.m_vMatrix1_AC0W.xyz,0.f); \r\n"
			"	g_matWorld[1].xyzw = float4(In.m_vMatrix2_LMOffsetX.xyz,0.f); \r\n"
			"	g_matWorld[2].xyzw = float4(In.m_vMatrix3_LMOffsetY.xyz,0.f); \r\n"
			"	g_matWorld[3].xyzw = In.m_vMatrix4; \r\n"
			" \r\n"
			"   g_matWV = mul(g_matWorld,g_matView); \r\n"
			"   g_matWVP = mul(g_matWV,g_matProj); \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(In.m_vPosition,g_matWVP); \r\n"
			"	Out.m_vPosProjSpace = Out.m_vPosition.xyw; \r\n"
			"	Out.m_vNormal = normalize( mul(In.m_vNormal,g_matWV) ); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vAlbedoXY_LMZW.xy; \r\n"
			"	Out.m_vLightmapUV = In.m_vAlbedoXY_LMZW.zw; \r\n"
			"	Out.m_vLightmapUV += float2(In.m_vMatrix2_LMOffsetX.w, In.m_vMatrix3_LMOffsetY.w); \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique runtime_3 \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"				// 0
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 0, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_ON \r\n"		// 1
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 1, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL2_ON \r\n"		// 2
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 0, 1 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_PL2_ON \r\n"	// 3
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 1, 1 ); \r\n"
			"	} \r\n"
			"	pass albedo_AlphTex \r\n"				// 0
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 0, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_ON_AlphTex \r\n"		// 1
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 1, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL2_ON_AlphTex \r\n"		// 2
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 0, 1 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_PL2_ON_AlphTex \r\n"	// 3
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 1, 1 ); \r\n"
			"	} \r\n"
			"} \r\n"
			"technique runtime_Instancing \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"				// 0
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_INSTANCING(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 0, 0 ); \r\n"
			"	} \r\n"
			"} \r\n"
			" \r\n";
	}

	void SetVoxelColor_PS30_FX( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWorld; \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4x4 g_matView; \r\n"
			"float4x4 g_matProj; \r\n"
			"float4   g_vPos_Range_CL_TOOL[2]; \r\n"
			"float4   g_vDiff_CosPhiHalf_CL_TOOL[2]; \r\n"
			"float4   g_vAtt_CosHalfThetaSubPhi_CL_TOOL[2]; \r\n"
			"float4   g_vDirect_Falloff_CL_TOOL[2]; \r\n"
			"float    g_fSpecularPower = 256.f; \r\n"
			"float    g_fSpecularIntensity = 2.f; \r\n"
			"float4   g_vWindowSize; \r\n"
			"float    g_fAlpha; \r\n"
			"float4   g_vVoxelColor; \r\n"
			"float	  g_fCubeMapValue; \r\n"
			"float	  g_fSpotShadowLight1_VoxelColorPower = 1.f; \r\n"
			"float	  g_fSpotShadowLight2_VoxelColorPower = 1.f; \r\n"
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_MaskTexture; \r\n"
			"sampler MaskTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_MaskTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_pTextureLodBlend; \r\n"
			"sampler TextureLodBlendSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_pTextureLodBlend); \r\n"
			"}; \r\n"			
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float3 m_vBinormal  : BINORMAL; \r\n"
			"	float3 m_vTangent   : TANGENT; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_INPUT			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"   float3 m_vNormal		: NORMAL; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"struct VS_INPUT_INSTANCING			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"   float3 m_vNormal		: NORMAL; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"	float4 m_vVC_AC0XY					: TEXCOORD1; \r\n"
			"	float4 m_vMatrix1_AC0W				: TEXCOORD2; \r\n"
			"	float4 m_vMatrix2_LMOffsetX			: TEXCOORD3; \r\n"
			"	float4 m_vMatrix3_LMOffsetY			: TEXCOORD4; \r\n"
			"	float4 m_vMatrix4					: TEXCOORD5; \r\n"
			"	float4 m_vAmbientCube_0Z_12_3X		: TEXCOORD6; \r\n"
			"	float4 m_vAmbientCube_3YZ_45		: TEXCOORD7; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_ALBEDO		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"	float3 m_vNormal		: TEXCOORD1; \r\n"
			"	float3 m_vPosProjSpace	: TEXCOORD2; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_ALBEDO_INSTANCING		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"	float3 m_vNormal		: TEXCOORD1; \r\n"
			"	float3 m_vPosProjSpace	: TEXCOORD2; \r\n"
			"	float3 m_vVoxelColor	: TEXCOORD3; \r\n"
			"}; \r\n"
			" \r\n"
			"struct PS_DEFFERED_OUT		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vColor0	: COLOR0; \r\n"
			"	float4 m_vColor1	: COLOR1; \r\n"
			"	float4 m_vColor2	: COLOR2; \r\n"
			"	float4 m_vColor3	: COLOR3; \r\n"
			"}; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.3.0 Albedo \r\n"
			"VS_OUTPUT_ALBEDO VS_3( VS_INPUT In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	Out.m_vPosProjSpace = Out.m_vPosition.xyw; \r\n"
			"	Out.m_vNormal = normalize( mul(g_matWV, In.m_vNormal) ); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			" float ExportVector2ToFloat( float fX, float fY ) // fX 와 fY 는 1 이하여야 한다. \r\n"	
			" { \r\n"
			" 	float2 vecEncode = floor( float2( fX * 255.0f, fY * 255.0f ) ); \r\n"
			" 	float fResult = ( ( vecEncode.x * 256.0f ) + vecEncode.y ) / 65535.0f; \r\n" // 256 - <<8 한다는 개념
			" 	return fResult; \r\n"
			" } \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_3( VS_OUTPUT_ALBEDO In, uniform bool bSoftAlpha, uniform int nPL1, uniform int nPL2 ) \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float3 vNorNormalize = normalize( In.m_vNormal ); \r\n"
			"	float3 vNorConvert = (vNorNormalize+1.f)*0.5f; \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.z + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	float3 vAddColor = g_vVoxelColor.xyz; \r\n"
			"	if ( nPL1==1 ) \r\n"
			"	{ \r\n"
			"		vAddColor += g_vDiff_CosPhiHalf_CL_TOOL[0].xyz * g_fSpotShadowLight1_VoxelColorPower; \r\n"
			"	} \r\n"
			"	if ( nPL2==1 ) \r\n"
			"	{ \r\n"
			"		vAddColor += g_vDiff_CosPhiHalf_CL_TOOL[1].xyz * g_fSpotShadowLight2_VoxelColorPower; \r\n"
			"	} \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"   vOut.m_vColor1 = float4(vNorNormalize,vColor.w); \r\n"
			"   vOut.m_vColor2 = float4(g_fSpecularIntensity*0.5f*vMaskColor.r,g_fSpecularPower/256.f,g_fCubeMapValue*vMaskColor.b,vColor.w); \r\n"
			"	vOut.m_vColor3.x = ExportVector2ToFloat( min(vAddColor.x * 0.33333333f, 1.f), min(vAddColor.y * 0.33333333f, 1.f) ); \r\n"
			"	vOut.m_vColor3.y = ExportVector2ToFloat( min(vAddColor.z * 0.33333333f, 1.f), vNorConvert.x ); \r\n"
			"	vOut.m_vColor3.z = ExportVector2ToFloat( vNorConvert.y, vNorConvert.z ); \r\n"
			"	if ( bSoftAlpha ) \r\n"
			"	{ \r\n"
			"		vOut.m_vColor3.w = 1.f; \r\n"	// AlphaBlend 때문에 어쩔수 없이 1을 넣어야 한다.
			"	} \r\n"
			"	else \r\n"
			"	{ \r\n"
			//"		vOut.m_vColor3.w = 0.f; \r\n"	// VoxelColor 는 LBuffer의 DirectionLighting 을 사용하지 못하도록 한다.
			"		vOut.m_vColor3.w = 0.f; \r\n"	// 변경됨. Voxel 은 Dot 을 - 값을 높여서 사용하도록 해서 입체감을 살리도록 함.
			"	} \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.3.0 Albedo INSTANCING \r\n"
			"VS_OUTPUT_ALBEDO_INSTANCING VS_INSTANCING( VS_INPUT_INSTANCING In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO_INSTANCING Out; \r\n"
			" \r\n"
			"	g_matWorld[0].xyzw = float4(In.m_vMatrix1_AC0W.xyz,0.f); \r\n"
			"	g_matWorld[1].xyzw = float4(In.m_vMatrix2_LMOffsetX.xyz,0.f); \r\n"
			"	g_matWorld[2].xyzw = float4(In.m_vMatrix3_LMOffsetY.xyz,0.f); \r\n"
			"	g_matWorld[3].xyzw = In.m_vMatrix4; \r\n"
			" \r\n"
			"	Out.m_vVoxelColor = In.m_vVC_AC0XY.xyz; \r\n"
			" \r\n"
			"   g_matWV = mul(g_matWorld,g_matView); \r\n"
			"   g_matWVP = mul(g_matWV,g_matProj); \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(In.m_vPosition, g_matWVP); \r\n"
			"	Out.m_vPosProjSpace = Out.m_vPosition.xyw; \r\n"
			"	Out.m_vNormal = normalize( mul(In.m_vNormal, g_matWV) ); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_INSTANCING( VS_OUTPUT_ALBEDO_INSTANCING In ) \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float3 vNorNormalize = normalize( In.m_vNormal ); \r\n"
			"	float3 vNorConvert = (vNorNormalize+1.f)*0.5f; \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.z + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	float3 vAddColor = In.m_vVoxelColor.xyz; \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"   vOut.m_vColor1 = float4(vNorNormalize,vColor.w); \r\n"
			"   vOut.m_vColor2 = float4(g_fSpecularIntensity*0.5f*vMaskColor.r,g_fSpecularPower/256.f,g_fCubeMapValue*vMaskColor.b,vColor.w); \r\n"
			"	vOut.m_vColor3.x = ExportVector2ToFloat( min(vAddColor.x * 0.33333333f, 1.f), min(vAddColor.y * 0.33333333f, 1.f) ); \r\n"
			"	vOut.m_vColor3.y = ExportVector2ToFloat( min(vAddColor.z * 0.33333333f, 1.f), vNorConvert.x ); \r\n"
			"	vOut.m_vColor3.z = ExportVector2ToFloat( vNorConvert.y, vNorConvert.z ); \r\n"
			//"	vOut.m_vColor3.w = 0.f; \r\n"	// VoxelColor 는 LBuffer의 DirectionLighting 을 사용하지 못하도록 한다.
			"	vOut.m_vColor3.w = 0.f; \r\n"	// 변경됨. Voxel 은 Dot 을 - 값을 높여서 사용하도록 해서 입체감을 살리도록 함.
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique runtime_3 \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"				// 0
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 0, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_ON \r\n"		// 1
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 1, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL2_ON \r\n"		// 2
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 0, 1 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_PL2_ON \r\n"	// 3
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 1, 1 ); \r\n"
			"	} \r\n"
			"	pass albedo_AlphTex \r\n"				// 0
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 0, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_ON_AlphTex \r\n"		// 1
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 1, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL2_ON_AlphTex \r\n"		// 2
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 0, 1 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_PL2_ON_AlphTex \r\n"	// 3
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 1, 1 ); \r\n"
			"	} \r\n"
			"} \r\n"
			"technique runtime_Instancing \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"				// 0
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_INSTANCING(); \r\n"
			"		PixelShader = compile ps_3_0 PS_INSTANCING(); \r\n"
			"	} \r\n"
			"} \r\n"
			" \r\n";
	}

	void SetVoxelColorVertexColor_PS30_FX( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWorld; \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4x4 g_matView; \r\n"
			"float4x4 g_matProj; \r\n"
			"float4   g_vPos_Range_CL_TOOL[2]; \r\n"
			"float4   g_vDiff_CosPhiHalf_CL_TOOL[2]; \r\n"
			"float4   g_vAtt_CosHalfThetaSubPhi_CL_TOOL[2]; \r\n"
			"float4   g_vDirect_Falloff_CL_TOOL[2]; \r\n"
			"float    g_fSpecularPower = 256.f; \r\n"
			"float    g_fSpecularIntensity = 2.f; \r\n"
			"float4   g_vWindowSize; \r\n"
			"float    g_fAlpha; \r\n"
			"float4	  g_vVoxelColor; \r\n"
			"float	  g_fCubeMapValue; \r\n"
			"float	  g_fSpotShadowLight1_VoxelColorPower = 1.f; \r\n"
			"float	  g_fSpotShadowLight2_VoxelColorPower = 1.f; \r\n"
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_MaskTexture; \r\n"
			"sampler MaskTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_MaskTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_pTextureLodBlend; \r\n"
			"sampler TextureLodBlendSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_pTextureLodBlend); \r\n"
			"}; \r\n"			
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float4 m_vColor0    : COLOR0; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_INPUT			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float4 m_vColor0		: COLOR0; \r\n"
			"   float3 m_vNormal		: NORMAL; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"struct VS_INPUT_INSTANCING			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float4 m_vColor0		: COLOR0; \r\n"
			"   float3 m_vNormal		: NORMAL; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"	float4 m_vVC_AC0XY					: TEXCOORD1; \r\n"
			"	float4 m_vMatrix1_AC0W				: TEXCOORD2; \r\n"
			"	float4 m_vMatrix2_LMOffsetX			: TEXCOORD3; \r\n"
			"	float4 m_vMatrix3_LMOffsetY			: TEXCOORD4; \r\n"
			"	float4 m_vMatrix4					: TEXCOORD5; \r\n"
			"	float4 m_vAmbientCube_0Z_12_3X		: TEXCOORD6; \r\n"
			"	float4 m_vAmbientCube_3YZ_45		: TEXCOORD7; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_ALBEDO		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float4 m_vColor0		: COLOR0; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"	float3 m_vNormal		: TEXCOORD1; \r\n"
			"	float3 m_vPosProjSpace	: TEXCOORD2; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_ALBEDO_INSTANCING		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float4 m_vColor0		: COLOR0; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"	float3 m_vNormal		: TEXCOORD1; \r\n"
			"	float3 m_vPosProjSpace	: TEXCOORD2; \r\n"
			"	float3 m_vVoxelColor	: TEXCOORD3; \r\n"
			"}; \r\n"
			" \r\n"
			"struct PS_DEFFERED_OUT		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vColor0	: COLOR0; \r\n"
			"	float4 m_vColor1	: COLOR1; \r\n"
			"	float4 m_vColor2	: COLOR2; \r\n"
			"	float4 m_vColor3	: COLOR3; \r\n"
			"}; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.3.0 Albedo \r\n"
			"VS_OUTPUT_ALBEDO VS_3( VS_INPUT In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	Out.m_vPosProjSpace = Out.m_vPosition.xyw; \r\n"
			"	Out.m_vNormal = normalize( mul(g_matWV, In.m_vNormal) ); \r\n"
			" \r\n"
			"	// Get Color \r\n"
			"	Out.m_vColor0 = In.m_vColor0; \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			" float ExportVector2ToFloat( float fX, float fY ) // fX 와 fY 는 1 이하여야 한다. \r\n"	
			" { \r\n"
			" 	float2 vecEncode = floor( float2( fX * 255.0f, fY * 255.0f ) ); \r\n"
			" 	float fResult = ( ( vecEncode.x * 256.0f ) + vecEncode.y ) / 65535.0f; \r\n" // 256 - <<8 한다는 개념
			" 	return fResult; \r\n"
			" } \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_3( VS_OUTPUT_ALBEDO In, uniform bool bSoftAlpha, uniform int nPL1, uniform int nPL2 ) \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float3 vNorNormalize = normalize( In.m_vNormal ); \r\n"
			"	float3 vNorConvert = (vNorNormalize+1.f)*0.5f; \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.z + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor *= In.m_vColor0; \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	float3 vAddColor = g_vVoxelColor.xyz; \r\n"
			"	if ( nPL1==1 ) \r\n"
			"	{ \r\n"
			"		vAddColor += g_vDiff_CosPhiHalf_CL_TOOL[0].xyz * g_fSpotShadowLight1_VoxelColorPower; \r\n"
			"	} \r\n"
			"	if ( nPL2==1 ) \r\n"
			"	{ \r\n"
			"		vAddColor += g_vDiff_CosPhiHalf_CL_TOOL[1].xyz * g_fSpotShadowLight2_VoxelColorPower; \r\n"
			"	} \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"   vOut.m_vColor1 = float4(vNorNormalize,vColor.w); \r\n"
			"   vOut.m_vColor2 = float4(g_fSpecularIntensity*0.5f*vMaskColor.r,g_fSpecularPower/256.f,g_fCubeMapValue*vMaskColor.b,vColor.w); \r\n"
			"	vOut.m_vColor3.x = ExportVector2ToFloat( min(vAddColor.x * 0.33333333f, 1.f), min(vAddColor.y * 0.33333333f, 1.f) ); \r\n"
			"	vOut.m_vColor3.y = ExportVector2ToFloat( min(vAddColor.z * 0.33333333f, 1.f), vNorConvert.x ); \r\n"
			"	vOut.m_vColor3.z = ExportVector2ToFloat( vNorConvert.y, vNorConvert.z ); \r\n"
			"	if ( bSoftAlpha ) \r\n"
			"	{ \r\n"
			"		vOut.m_vColor3.w = 1.f; \r\n"	// AlphaBlend 때문에 어쩔수 없이 1을 넣어야 한다.
			"	} \r\n"
			"	else \r\n"
			"	{ \r\n"
			//"		vOut.m_vColor3.w = 0.f; \r\n"	// VoxelColor 는 LBuffer의 DirectionLighting 을 사용하지 못하도록 한다.
			"		vOut.m_vColor3.w = 0.f; \r\n"	// 변경됨. Voxel 은 Dot 을 - 값을 높여서 사용하도록 해서 입체감을 살리도록 함.
			"	} \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.3.0 Albedo INSTANCING \r\n"
			"VS_OUTPUT_ALBEDO_INSTANCING VS_INSTANCING( VS_INPUT_INSTANCING In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO_INSTANCING Out; \r\n"
			" \r\n"
			"	g_matWorld[0].xyzw = float4(In.m_vMatrix1_AC0W.xyz,0.f); \r\n"
			"	g_matWorld[1].xyzw = float4(In.m_vMatrix2_LMOffsetX.xyz,0.f); \r\n"
			"	g_matWorld[2].xyzw = float4(In.m_vMatrix3_LMOffsetY.xyz,0.f); \r\n"
			"	g_matWorld[3].xyzw = In.m_vMatrix4; \r\n"
			" \r\n"
			"	Out.m_vVoxelColor = In.m_vVC_AC0XY.xyz; \r\n"
			" \r\n"
			"   g_matWV = mul(g_matWorld,g_matView); \r\n"
			"   g_matWVP = mul(g_matWV,g_matProj); \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(In.m_vPosition, g_matWVP); \r\n"
			"	Out.m_vPosProjSpace = Out.m_vPosition.xyw; \r\n"
			"	Out.m_vNormal = normalize( mul(In.m_vNormal, g_matWV) ); \r\n"
			" \r\n"
			"	// Get Color \r\n"
			"	Out.m_vColor0 = In.m_vColor0; \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_INSTANCING( VS_OUTPUT_ALBEDO_INSTANCING In ) \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float3 vNorNormalize = normalize( In.m_vNormal ); \r\n"
			"	float3 vNorConvert = (vNorNormalize+1.f)*0.5f; \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.z + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor *= In.m_vColor0; \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	float3 vAddColor = In.m_vVoxelColor.xyz; \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"   vOut.m_vColor1 = float4(vNorNormalize,vColor.w); \r\n"
			"   vOut.m_vColor2 = float4(g_fSpecularIntensity*0.5f*vMaskColor.r,g_fSpecularPower/256.f,g_fCubeMapValue*vMaskColor.b,vColor.w); \r\n"
			"	vOut.m_vColor3.x = ExportVector2ToFloat( min(vAddColor.x * 0.33333333f, 1.f), min(vAddColor.y * 0.33333333f, 1.f) ); \r\n"
			"	vOut.m_vColor3.y = ExportVector2ToFloat( min(vAddColor.z * 0.33333333f, 1.f), vNorConvert.x ); \r\n"
			"	vOut.m_vColor3.z = ExportVector2ToFloat( vNorConvert.y, vNorConvert.z ); \r\n"
			//"	vOut.m_vColor3.w = 0.f; \r\n"	// VoxelColor 는 LBuffer의 DirectionLighting 을 사용하지 못하도록 한다.
			"	vOut.m_vColor3.w = 0.f; \r\n"	// 변경됨. Voxel 은 Dot 을 - 값을 높여서 사용하도록 해서 입체감을 살리도록 함.
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique runtime_3 \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"				// 0
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 0, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_ON \r\n"		// 1
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 1, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL2_ON \r\n"		// 2
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 0, 1 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_PL2_ON \r\n"	// 3
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 1, 1 ); \r\n"
			"	} \r\n"
			"	pass albedo_AlphTex \r\n"				// 0
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 0, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_ON_AlphTex \r\n"		// 1
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 1, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL2_ON_AlphTex \r\n"		// 2
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 0, 1 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_PL2_ON_AlphTex \r\n"	// 3
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3(); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 1, 1 ); \r\n"
			"	} \r\n"
			"} \r\n"
			"technique runtime_Instancing \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"				// 0
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_INSTANCING(); \r\n"
			"		PixelShader = compile ps_3_0 PS_INSTANCING(); \r\n"
			"	} \r\n"
			"} \r\n"
			" \r\n";
	}

	void SetAmbientCube_PS30_FX( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWorld; \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4x4 g_matView; \r\n"
			"float4x4 g_matProj; \r\n"
			"float4   g_vLightDiffuse; \r\n"
			"float4   g_vPos_Range_CL_TOOL[2]; \r\n"
			"float4   g_vDiff_CosPhiHalf_CL_TOOL[2]; \r\n"
			"float4   g_vAtt_CosHalfThetaSubPhi_CL_TOOL[2]; \r\n"
			"float4   g_vDirect_Falloff_CL_TOOL[2]; \r\n"
			"float    g_fSpecularPower = 256.f; \r\n"
			"float    g_fSpecularIntensity = 2.f; \r\n"
			"float4   g_vWindowSize; \r\n"
			"float    g_fAlpha; \r\n"
			"float4	  g_vAmbientCube[6]; \r\n"
			"float	  g_arrayfAmbientCubePL1[6] = {0.f,0.f,0.f,0.f,0.f,0.f}; \r\n"
			"float	  g_arrayfAmbientCubePL2[6] = {0.f,0.f,0.f,0.f,0.f,0.f}; \r\n"
			"float	  g_fCubeMapValue; \r\n"
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_MaskTexture; \r\n"
			"sampler MaskTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_MaskTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_pTextureLodBlend; \r\n"
			"sampler TextureLodBlendSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_pTextureLodBlend); \r\n"
			"}; \r\n"			
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float3 m_vBinormal  : BINORMAL; \r\n"
			"	float3 m_vTangent   : TANGENT; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_INPUT			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"   float3 m_vNormal	: NORMAL; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"struct VS_INPUT_INSTANCING			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"   float3 m_vNormal		: NORMAL; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"	float4 m_vVC_AC0XY					: TEXCOORD1; \r\n"
			"	float4 m_vMatrix1_AC0W				: TEXCOORD2; \r\n"
			"	float4 m_vMatrix2_LMOffsetX			: TEXCOORD3; \r\n"
			"	float4 m_vMatrix3_LMOffsetY			: TEXCOORD4; \r\n"
			"	float4 m_vMatrix4					: TEXCOORD5; \r\n"
			"	float4 m_vAmbientCube_0Z_12_3X		: TEXCOORD6; \r\n"
			"	float4 m_vAmbientCube_3YZ_45		: TEXCOORD7; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_ALBEDO		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition			: POSITION; \r\n"
			"	float2 m_vTexCoord0			: TEXCOORD0; \r\n"
			"	float3 m_vNormal			: TEXCOORD1; \r\n"
			"	float3 m_vColor0			: TEXCOORD2; \r\n"
			"	float2 m_vACubeSpot1Spot2	: TEXCOORD3; \r\n"		// x-AmbientCube_Spot1, y-AmbientCube_Spot2
			"	float3 m_vPosProjSpace		: TEXCOORD4; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_ALBEDO_INSTANCING		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition			: POSITION; \r\n"
			"	float2 m_vTexCoord0			: TEXCOORD0; \r\n"
			"	float3 m_vNormal			: TEXCOORD1; \r\n"
			"	float4 m_vColor0			: TEXCOORD2; \r\n"
			"	float3 m_vPosProjSpace		: TEXCOORD3; \r\n"
			"}; \r\n"
			" \r\n"
			"struct PS_DEFFERED_OUT		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vColor0	: COLOR0; \r\n"
			"	float4 m_vColor1	: COLOR1; \r\n"
			"	float4 m_vColor2	: COLOR2; \r\n"
			"	float4 m_vColor3	: COLOR3; \r\n"
			"}; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"float3 AmbientLight( const float3 worldNormal ) \r\n"
			"{ \r\n"
			"   float3 nSquared= worldNormal* worldNormal; \r\n"
			"   int3 isNegative= ( worldNormal< 0.0 ); \r\n"
			"   float3 linearColor; \r\n"
			"   linearColor= nSquared.x* g_vAmbientCube[isNegative.x] + \r\n"
			"	nSquared.y* g_vAmbientCube[isNegative.y+2] + \r\n"
			"	nSquared.z* g_vAmbientCube[isNegative.z+4]; \r\n"
			"   return linearColor; \r\n"
			"} \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"float AmbientLightPL1( const float3 worldNormal ) \r\n"
			"{ \r\n"
			"   float3 nSquared= worldNormal* worldNormal; \r\n"
			"   int3 isNegative= ( worldNormal< 0.0 ); \r\n"
			"   float linearColor; \r\n"
			"   linearColor = nSquared.x* g_arrayfAmbientCubePL1[isNegative.x] + \r\n"
			"	nSquared.y* g_arrayfAmbientCubePL1[isNegative.y+2] + \r\n"
			"	nSquared.z* g_arrayfAmbientCubePL1[isNegative.z+4]; \r\n"
			"   return linearColor; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"float AmbientLightPL2( const float3 worldNormal ) \r\n"
			"{ \r\n"
			"   float3 nSquared= worldNormal* worldNormal; \r\n"
			"   int3 isNegative= ( worldNormal< 0.0 ); \r\n"
			"   float linearColor; \r\n"
			"   linearColor = nSquared.x* g_arrayfAmbientCubePL2[isNegative.x] + \r\n"
			"	nSquared.y* g_arrayfAmbientCubePL2[isNegative.y+2] + \r\n"
			"	nSquared.z* g_arrayfAmbientCubePL2[isNegative.z+4]; \r\n"
			"   return linearColor; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.3.0 Albedo \r\n"
			"VS_OUTPUT_ALBEDO VS_3( VS_INPUT In, uniform int nPL1, uniform int nPL2 )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	Out.m_vPosProjSpace = Out.m_vPosition.xyw; \r\n"
			"	Out.m_vNormal = normalize( mul(g_matWV, In.m_vNormal) ); \r\n"
			" \r\n"
			"	float3 vNor = normalize(mul(g_matWorld, In.m_vNormal)); \r\n"
			"   Out.m_vColor0 = AmbientLight( vNor ); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	Out.m_vACubeSpot1Spot2 = float2(0.f,0.f); \r\n"
			"	if ( nPL1==1 ) \r\n"
			"	{ \r\n"
			"		Out.m_vACubeSpot1Spot2.x = AmbientLightPL1( vNor ); \r\n"
			"	} \r\n"
			"	if ( nPL2==1 ) \r\n"
			"	{ \r\n"
			"		Out.m_vACubeSpot1Spot2.y = AmbientLightPL2( vNor ); \r\n"
			"	} \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			" float ExportVector2ToFloat( float fX, float fY ) // fX 와 fY 는 1 이하여야 한다. \r\n"	
			" { \r\n"
			" 	float2 vecEncode = floor( float2( fX * 255.0f, fY * 255.0f ) ); \r\n"
			" 	float fResult = ( ( vecEncode.x * 256.0f ) + vecEncode.y ) / 65535.0f; \r\n" // 256 - <<8 한다는 개념
			" 	return fResult; \r\n"
			" } \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_3( VS_OUTPUT_ALBEDO In, uniform bool bSoftAlpha, uniform int nPL1, uniform int nPL2 ) \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float3 vNorNormalize = normalize( In.m_vNormal ); \r\n"
			"	float3 vNorConvert = (vNorNormalize+1.f)*0.5f; \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.z + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	float3	vAddColor = In.m_vColor0.xyz; \r\n"
			"	if ( nPL1==1 ) \r\n"
			"	{ \r\n"
			"		vAddColor += g_vDiff_CosPhiHalf_CL_TOOL[0].xyz * In.m_vACubeSpot1Spot2.x; \r\n"
			"	} \r\n"
			"	if ( nPL2==1 ) \r\n"
			"	{ \r\n"
			"		vAddColor += g_vDiff_CosPhiHalf_CL_TOOL[1].xyz * In.m_vACubeSpot1Spot2.y; \r\n"
			"	} \r\n"
			" \r\n"
			"	if ( bSoftAlpha ) \r\n"
			"	{ \r\n"
			"		vAddColor += g_vLightDiffuse.xyz * g_vAmbientCube[0].w; \r\n"		// SoftAlpha라면 DirectionLight Diffuse를 넣는다. Opaque나 HardAlpha는 LBuffer에서 한다.
			"	} \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"   vOut.m_vColor1 = float4(vNorNormalize,vColor.w); \r\n"
			"   vOut.m_vColor2 = float4(g_fSpecularIntensity*0.5f*vMaskColor.r,g_fSpecularPower/256.f,g_fCubeMapValue*vMaskColor.b,vColor.w); \r\n"
			"	vOut.m_vColor3.x = ExportVector2ToFloat( min(vAddColor.x * 0.33333333f, 1.f), min(vAddColor.y * 0.33333333f, 1.f) ); \r\n"
			"	vOut.m_vColor3.y = ExportVector2ToFloat( min(vAddColor.z * 0.33333333f, 1.f), vNorConvert.x ); \r\n"
			"	vOut.m_vColor3.z = ExportVector2ToFloat( vNorConvert.y, vNorConvert.z ); \r\n"
			"	if ( bSoftAlpha ) \r\n"
			"	{ \r\n"
			"		vOut.m_vColor3.w = 1.f; \r\n"	// AlphaBlend 때문에 어쩔수 없이 1을 넣어야 한다.
			"	} \r\n"
			"	else \r\n"
			"	{ \r\n"
			"		vOut.m_vColor3.w = g_vAmbientCube[0].w; \r\n"	// Opaque나 HardAlpha는 DirectionLight의 강도를 넘겨주도록 한다.
			"	} \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.3.0 Albedo INSTANCING \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//				ExportFloatToVector2 \r\n"
			" float2 ExportFloatToVector2( float fValue ) \r\n"	
			" { \r\n"
			"   fValue = fValue * 65535.f; \r\n"
			"   float2 vOut; \r\n"
			"	vOut.x = floor( fValue / 256.f ); \r\n"	// >>8 한다는 개념으로. floor 는 정수만.. 내림으로
			"	vOut.x /= 255.f; \r\n"					// 0~255 / 255  로써 0~1 사이에 값을 얻을 수 있다.
			"	vOut.y = frac( fValue / 256.f ); \r\n"	// >>8 가 당해진 값들을 얻는다. frac 은 소수만 얻음.
														// vOut.y 는 0 ~ 255/256 값을 얻는다. 
														// 좀더 정확한 vOut.y 값을 위해서는 얻은 값에서 256 / 255 값을 곱해주면 된다. ( 굳이 할 필요는 없는거 같다 )
			"	return vOut; \r\n"
			" } \r\n"
			" \r\n"
			"VS_OUTPUT_ALBEDO_INSTANCING VS_INSTANCING( VS_INPUT_INSTANCING In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO_INSTANCING Out; \r\n"
			" \r\n"
			"	g_matWorld[0].xyzw = float4(In.m_vMatrix1_AC0W.xyz,0.f); \r\n"
			"	g_matWorld[1].xyzw = float4(In.m_vMatrix2_LMOffsetX.xyz,0.f); \r\n"
			"	g_matWorld[2].xyzw = float4(In.m_vMatrix3_LMOffsetY.xyz,0.f); \r\n"
			"	g_matWorld[3].xyzw = In.m_vMatrix4; \r\n"
			" \r\n"
			"	float2 AC_0XY = ExportFloatToVector2( In.m_vVC_AC0XY.w ) * 3.f; \r\n"
			"	float2 AC_0Z_1X = ExportFloatToVector2( In.m_vAmbientCube_0Z_12_3X.x ) * 3.f; \r\n"
			"	float2 AC_1YZ = ExportFloatToVector2( In.m_vAmbientCube_0Z_12_3X.y ) * 3.f; \r\n"
			"	float2 AC_2XY = ExportFloatToVector2( In.m_vAmbientCube_0Z_12_3X.z ) * 3.f; \r\n"
			"	float2 AC_2Z_3X = ExportFloatToVector2( In.m_vAmbientCube_0Z_12_3X.w ) * 3.f; \r\n"
			"	float2 AC_3YZ = ExportFloatToVector2( In.m_vAmbientCube_3YZ_45.x ) * 3.f; \r\n"
			"	float2 AC_4XY = ExportFloatToVector2( In.m_vAmbientCube_3YZ_45.y ) * 3.f; \r\n"
			"	float2 AC_4Z_5X = ExportFloatToVector2( In.m_vAmbientCube_3YZ_45.z ) * 3.f; \r\n"
			"	float2 AC_5YZ = ExportFloatToVector2( In.m_vAmbientCube_3YZ_45.w ) * 3.f; \r\n"
			" \r\n"
			"	g_vAmbientCube[0].xyz = float3( AC_0XY.x, AC_0XY.y, AC_0Z_1X.x ); \r\n"
			"	g_vAmbientCube[1].xyz = float3( AC_0Z_1X.y, AC_1YZ.x, AC_1YZ.y ); \r\n"
			"	g_vAmbientCube[2].xyz = float3( AC_2XY.x, AC_2XY.y, AC_2Z_3X.x ); \r\n"
			"	g_vAmbientCube[3].xyz = float3( AC_2Z_3X.y, AC_3YZ.x, AC_3YZ.y ); \r\n"
			"	g_vAmbientCube[4].xyz = float3( AC_4XY.x, AC_4XY.y, AC_4Z_5X.x ); \r\n"
			"	g_vAmbientCube[5].xyz = float3( AC_4Z_5X.y, AC_5YZ.x, AC_5YZ.y ); \r\n"
			" \r\n"
			"   g_matWV = mul(g_matWorld,g_matView); \r\n"
			"   g_matWVP = mul(g_matWV,g_matProj); \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(In.m_vPosition, g_matWVP); \r\n"
			"	Out.m_vPosProjSpace = Out.m_vPosition.xyw; \r\n"
			"	Out.m_vNormal = normalize( mul(In.m_vNormal, g_matWV) ); \r\n"
			" \r\n"
			"	float3 vNor = normalize(mul(In.m_vNormal, g_matWorld)); \r\n"
			"   Out.m_vColor0.xyz = AmbientLight( vNor ); \r\n"
			"   Out.m_vColor0.w = In.m_vMatrix1_AC0W.w; \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_INSTANCING( VS_OUTPUT_ALBEDO_INSTANCING In ) \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float3 vNorNormalize = normalize( In.m_vNormal ); \r\n"
			"	float3 vNorConvert = (vNorNormalize+1.f)*0.5f; \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.z + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	float3	vAddColor = In.m_vColor0.xyz; \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"   vOut.m_vColor1 = float4(vNorNormalize,vColor.w); \r\n"
			"   vOut.m_vColor2 = float4(g_fSpecularIntensity*0.5f*vMaskColor.r,g_fSpecularPower/256.f,g_fCubeMapValue*vMaskColor.b,vColor.w); \r\n"
			"	vOut.m_vColor3.x = ExportVector2ToFloat( min(vAddColor.x * 0.33333333f, 1.f), min(vAddColor.y * 0.33333333f, 1.f) ); \r\n"
			"	vOut.m_vColor3.y = ExportVector2ToFloat( min(vAddColor.z * 0.33333333f, 1.f), vNorConvert.x ); \r\n"
			"	vOut.m_vColor3.z = ExportVector2ToFloat( vNorConvert.y, vNorConvert.z ); \r\n"
			"	vOut.m_vColor3.w = In.m_vColor0.w; \r\n"	// Opaque나 HardAlpha는 DirectionLight의 강도를 넘겨주도록 한다.
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique runtime_3 \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"				// 0
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3( 0, 0 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 0, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_ON \r\n"		// 1
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3( 1, 0 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 1, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL2_ON \r\n"		// 2
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3( 0, 1 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 0, 1 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_PL2_ON \r\n"	// 3
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3( 1, 1 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 1, 1 ); \r\n"
			"	} \r\n"
			"	pass albedo_AlphTex \r\n"				// 0
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3( 0, 0 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 0, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_ON_AlphTex \r\n"		// 1
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3( 1, 0 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 1, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL2_ON_AlphTex \r\n"		// 2
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3( 0, 1 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 0, 1 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_PL2_ON_AlphTex \r\n"	// 3
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3( 1, 1 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 1, 1 ); \r\n"
			"	} \r\n"
			"} \r\n"
			"technique runtime_Instancing \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"				// 0
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_INSTANCING(); \r\n"
			"		PixelShader = compile ps_3_0 PS_INSTANCING(); \r\n"
			"	} \r\n"
			"} \r\n"
			" \r\n";
	}

	void SetAmbientCubeVertexColor_PS30_FX( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWorld; \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4x4 g_matView; \r\n"
			"float4x4 g_matProj; \r\n"
			"float4   g_vLightDiffuse; \r\n"
			"float4   g_vPos_Range_CL_TOOL[2]; \r\n"
			"float4   g_vDiff_CosPhiHalf_CL_TOOL[2]; \r\n"
			"float4   g_vAtt_CosHalfThetaSubPhi_CL_TOOL[2]; \r\n"
			"float4   g_vDirect_Falloff_CL_TOOL[2]; \r\n"
			"float    g_fSpecularPower = 256.f; \r\n"
			"float    g_fSpecularIntensity = 2.f; \r\n"
			"float4   g_vWindowSize; \r\n"
			"float    g_fAlpha; \r\n"
			"float4	  g_vAmbientCube[6]; \r\n"
			"float	  g_arrayfAmbientCubePL1[6] = {0.f,0.f,0.f,0.f,0.f,0.f}; \r\n"
			"float	  g_arrayfAmbientCubePL2[6] = {0.f,0.f,0.f,0.f,0.f,0.f}; \r\n"
			"float	  g_fCubeMapValue; \r\n"
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_MaskTexture; \r\n"
			"sampler MaskTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_MaskTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_pTextureLodBlend; \r\n"
			"sampler TextureLodBlendSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_pTextureLodBlend); \r\n"
			"}; \r\n"			
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float3 m_vBinormal  : BINORMAL; \r\n"
			"	float3 m_vTangent   : TANGENT; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_INPUT			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"   float3 m_vNormal	: NORMAL; \r\n"
			"	float4 m_vColor0	: COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"struct VS_INPUT_INSTANCING			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"   float3 m_vNormal		: NORMAL; \r\n"
			"	float4 m_vColor0		: COLOR0; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"	float4 m_vVC_AC0XY					: TEXCOORD1; \r\n"
			"	float4 m_vMatrix1_AC0W				: TEXCOORD2; \r\n"
			"	float4 m_vMatrix2_LMOffsetX			: TEXCOORD3; \r\n"
			"	float4 m_vMatrix3_LMOffsetY			: TEXCOORD4; \r\n"
			"	float4 m_vMatrix4					: TEXCOORD5; \r\n"
			"	float4 m_vAmbientCube_0Z_12_3X		: TEXCOORD6; \r\n"
			"	float4 m_vAmbientCube_3YZ_45		: TEXCOORD7; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_ALBEDO		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition			: POSITION; \r\n"
			"	float4 m_vColor0			: COLOR0; \r\n"
			"	float2 m_vTexCoord0			: TEXCOORD0; \r\n"
			"	float3 m_vNormal			: TEXCOORD1; \r\n"
			"	float3 m_vColor2			: TEXCOORD2; \r\n"
			"	float2 m_vACubeSpot1Spot2	: TEXCOORD3; \r\n"		// x-AmbientCube_Spot1, y-AmbientCube_Spot2
			"	float3 m_vPosProjSpace		: TEXCOORD4; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_ALBEDO_INSTANCING		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition			: POSITION; \r\n"
			"	float4 m_vColor0			: COLOR0; \r\n"
			"	float2 m_vTexCoord0			: TEXCOORD0; \r\n"
			"	float3 m_vNormal			: TEXCOORD1; \r\n"
			"	float4 m_vColor2			: TEXCOORD2; \r\n"
			"	float3 m_vPosProjSpace		: TEXCOORD3; \r\n"
			"}; \r\n"
			" \r\n"
			"struct PS_DEFFERED_OUT		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vColor0	: COLOR0; \r\n"
			"	float4 m_vColor1	: COLOR1; \r\n"
			"	float4 m_vColor2	: COLOR2; \r\n"
			"	float4 m_vColor3	: COLOR3; \r\n"
			"}; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"float3 AmbientLight( const float3 worldNormal ) \r\n"
			"{ \r\n"
			"   float3 nSquared= worldNormal* worldNormal; \r\n"
			"   int3 isNegative= ( worldNormal< 0.0 ); \r\n"
			"   float3 linearColor; \r\n"
			"   linearColor= nSquared.x* g_vAmbientCube[isNegative.x] + \r\n"
			"	nSquared.y* g_vAmbientCube[isNegative.y+2] + \r\n"
			"	nSquared.z* g_vAmbientCube[isNegative.z+4]; \r\n"
			"   return linearColor; \r\n"
			"} \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"float AmbientLightPL1( const float3 worldNormal ) \r\n"
			"{ \r\n"
			"   float3 nSquared= worldNormal* worldNormal; \r\n"
			"   int3 isNegative= ( worldNormal< 0.0 ); \r\n"
			"   float linearColor; \r\n"
			"   linearColor = nSquared.x* g_arrayfAmbientCubePL1[isNegative.x] + \r\n"
			"	nSquared.y* g_arrayfAmbientCubePL1[isNegative.y+2] + \r\n"
			"	nSquared.z* g_arrayfAmbientCubePL1[isNegative.z+4]; \r\n"
			"   return linearColor; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"float AmbientLightPL2( const float3 worldNormal ) \r\n"
			"{ \r\n"
			"   float3 nSquared= worldNormal* worldNormal; \r\n"
			"   int3 isNegative= ( worldNormal< 0.0 ); \r\n"
			"   float linearColor; \r\n"
			"   linearColor = nSquared.x* g_arrayfAmbientCubePL2[isNegative.x] + \r\n"
			"	nSquared.y* g_arrayfAmbientCubePL2[isNegative.y+2] + \r\n"
			"	nSquared.z* g_arrayfAmbientCubePL2[isNegative.z+4]; \r\n"
			"   return linearColor; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.3.0 Albedo \r\n"
			"VS_OUTPUT_ALBEDO VS_3( VS_INPUT In, uniform int nPL1, uniform int nPL2 )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	Out.m_vPosProjSpace = Out.m_vPosition.xyw; \r\n"
			"	Out.m_vNormal = normalize( mul(g_matWV, In.m_vNormal) ); \r\n"
			" \r\n"
			"   Out.m_vColor0 = In.m_vColor0; \r\n"
			" \r\n"
			"	float3 vNor = normalize(mul(g_matWorld, In.m_vNormal)); \r\n"
			"   Out.m_vColor2 = AmbientLight( vNor ); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	Out.m_vACubeSpot1Spot2 = float2(0.f,0.f); \r\n"
			"	if ( nPL1==1 ) \r\n"
			"	{ \r\n"
			"		Out.m_vACubeSpot1Spot2.x = AmbientLightPL1( vNor ); \r\n"
			"	} \r\n"
			"	if ( nPL2==1 ) \r\n"
			"	{ \r\n"
			"		Out.m_vACubeSpot1Spot2.y = AmbientLightPL2( vNor ); \r\n"
			"	} \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			" float ExportVector2ToFloat( float fX, float fY ) // fX 와 fY 는 1 이하여야 한다. \r\n"	
			" { \r\n"
			" 	float2 vecEncode = floor( float2( fX * 255.0f, fY * 255.0f ) ); \r\n"
			" 	float fResult = ( ( vecEncode.x * 256.0f ) + vecEncode.y ) / 65535.0f; \r\n" // 256 - <<8 한다는 개념
			" 	return fResult; \r\n"
			" } \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_3( VS_OUTPUT_ALBEDO In, uniform bool bSoftAlpha, uniform int nPL1, uniform int nPL2 ) \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			"	vColor.xyz *= In.m_vColor0.xyz; \r\n"
			" \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float3 vNorNormalize = normalize( In.m_vNormal ); \r\n"
			"	float3 vNorConvert = (vNorNormalize+1.f)*0.5f; \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.z + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	float3	vAddColor = In.m_vColor2.xyz; \r\n"
			"	if ( nPL1==1 ) \r\n"
			"	{ \r\n"
			"		vAddColor += g_vDiff_CosPhiHalf_CL_TOOL[0].xyz * In.m_vACubeSpot1Spot2.x; \r\n"
			"	} \r\n"
			"	if ( nPL2==1 ) \r\n"
			"	{ \r\n"
			"		vAddColor += g_vDiff_CosPhiHalf_CL_TOOL[1].xyz * In.m_vACubeSpot1Spot2.y; \r\n"
			"	} \r\n"
			" \r\n"
			"	if ( bSoftAlpha ) \r\n"
			"	{ \r\n"
			"		vAddColor += g_vLightDiffuse.xyz * g_vAmbientCube[0].w; \r\n"		// SoftAlpha라면 DirectionLight Diffuse를 넣는다. Opaque나 HardAlpha는 LBuffer에서 한다.
			"	} \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"   vOut.m_vColor1 = float4(vNorNormalize,vColor.w); \r\n"
			"   vOut.m_vColor2 = float4(g_fSpecularIntensity*0.5f*vMaskColor.r,g_fSpecularPower/256.f,g_fCubeMapValue*vMaskColor.b,vColor.w); \r\n"
			"	vOut.m_vColor3.x = ExportVector2ToFloat( min(vAddColor.x * 0.33333333f, 1.f), min(vAddColor.y * 0.33333333f, 1.f) ); \r\n"
			"	vOut.m_vColor3.y = ExportVector2ToFloat( min(vAddColor.z * 0.33333333f, 1.f), vNorConvert.x ); \r\n"
			"	vOut.m_vColor3.z = ExportVector2ToFloat( vNorConvert.y, vNorConvert.z ); \r\n"
			"	if ( bSoftAlpha ) \r\n"
			"	{ \r\n"
			"		vOut.m_vColor3.w = 1.f; \r\n"	// AlphaBlend 때문에 어쩔수 없이 1을 넣어야 한다.
			"	} \r\n"
			"	else \r\n"
			"	{ \r\n"
			"		vOut.m_vColor3.w = g_vAmbientCube[0].w; \r\n"	// Opaque나 HardAlpha는 DirectionLight의 강도를 넘겨주도록 한다.
			"	} \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.3.0 Albedo INSTANCING \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//				ExportFloatToVector2 \r\n"
			" float2 ExportFloatToVector2( float fValue ) \r\n"	
			" { \r\n"
			"   fValue = fValue * 65535.f; \r\n"
			"   float2 vOut; \r\n"
			"	vOut.x = floor( fValue / 256.f ); \r\n"	// >>8 한다는 개념으로. floor 는 정수만.. 내림으로
			"	vOut.x /= 255.f; \r\n"					// 0~255 / 255  로써 0~1 사이에 값을 얻을 수 있다.
			"	vOut.y = frac( fValue / 256.f ); \r\n"	// >>8 가 당해진 값들을 얻는다. frac 은 소수만 얻음.
														// vOut.y 는 0 ~ 255/256 값을 얻는다. 
														// 좀더 정확한 vOut.y 값을 위해서는 얻은 값에서 256 / 255 값을 곱해주면 된다. ( 굳이 할 필요는 없는거 같다 )
			"	return vOut; \r\n"
			" } \r\n"
			" \r\n"
			"VS_OUTPUT_ALBEDO_INSTANCING VS_INSTANCING( VS_INPUT_INSTANCING In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO_INSTANCING Out; \r\n"
			" \r\n"
			"	g_matWorld[0].xyzw = float4(In.m_vMatrix1_AC0W.xyz,0.f); \r\n"
			"	g_matWorld[1].xyzw = float4(In.m_vMatrix2_LMOffsetX.xyz,0.f); \r\n"
			"	g_matWorld[2].xyzw = float4(In.m_vMatrix3_LMOffsetY.xyz,0.f); \r\n"
			"	g_matWorld[3].xyzw = In.m_vMatrix4; \r\n"
			" \r\n"
			"	float2 AC_0XY = ExportFloatToVector2( In.m_vVC_AC0XY.w ) * 3.f; \r\n"
			"	float2 AC_0Z_1X = ExportFloatToVector2( In.m_vAmbientCube_0Z_12_3X.x ) * 3.f; \r\n"
			"	float2 AC_1YZ = ExportFloatToVector2( In.m_vAmbientCube_0Z_12_3X.y ) * 3.f; \r\n"
			"	float2 AC_2XY = ExportFloatToVector2( In.m_vAmbientCube_0Z_12_3X.z ) * 3.f; \r\n"
			"	float2 AC_2Z_3X = ExportFloatToVector2( In.m_vAmbientCube_0Z_12_3X.w ) * 3.f; \r\n"
			"	float2 AC_3YZ = ExportFloatToVector2( In.m_vAmbientCube_3YZ_45.x ) * 3.f; \r\n"
			"	float2 AC_4XY = ExportFloatToVector2( In.m_vAmbientCube_3YZ_45.y ) * 3.f; \r\n"
			"	float2 AC_4Z_5X = ExportFloatToVector2( In.m_vAmbientCube_3YZ_45.z ) * 3.f; \r\n"
			"	float2 AC_5YZ = ExportFloatToVector2( In.m_vAmbientCube_3YZ_45.w ) * 3.f; \r\n"
			" \r\n"
			"	g_vAmbientCube[0].xyz = float3( AC_0XY.x, AC_0XY.y, AC_0Z_1X.x ); \r\n"
			"	g_vAmbientCube[1].xyz = float3( AC_0Z_1X.y, AC_1YZ.x, AC_1YZ.y ); \r\n"
			"	g_vAmbientCube[2].xyz = float3( AC_2XY.x, AC_2XY.y, AC_2Z_3X.x ); \r\n"
			"	g_vAmbientCube[3].xyz = float3( AC_2Z_3X.y, AC_3YZ.x, AC_3YZ.y ); \r\n"
			"	g_vAmbientCube[4].xyz = float3( AC_4XY.x, AC_4XY.y, AC_4Z_5X.x ); \r\n"
			"	g_vAmbientCube[5].xyz = float3( AC_4Z_5X.y, AC_5YZ.x, AC_5YZ.y ); \r\n"
			" \r\n"
			"   g_matWV = mul(g_matWorld,g_matView); \r\n"
			"   g_matWVP = mul(g_matWV,g_matProj); \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(In.m_vPosition, g_matWVP); \r\n"
			"	Out.m_vPosProjSpace = Out.m_vPosition.xyw; \r\n"
			"	Out.m_vNormal = normalize( mul(In.m_vNormal, g_matWV) ); \r\n"
			" \r\n"
			"   Out.m_vColor0 = In.m_vColor0; \r\n"
			" \r\n"
			"	float3 vNor = normalize(mul(In.m_vNormal, g_matWorld)); \r\n"
			"   Out.m_vColor2.xyz = AmbientLight( vNor ); \r\n"
			"   Out.m_vColor2.w = In.m_vMatrix1_AC0W.w; \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_INSTANCING( VS_OUTPUT_ALBEDO_INSTANCING In ) \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			"	vColor.xyz *= In.m_vColor0.xyz; \r\n"
			" \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float3 vNorNormalize = normalize( In.m_vNormal ); \r\n"
			"	float3 vNorConvert = (vNorNormalize+1.f)*0.5f; \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.z + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	float3	vAddColor = In.m_vColor2.xyz; \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"   vOut.m_vColor1 = float4(vNorNormalize,vColor.w); \r\n"
			"   vOut.m_vColor2 = float4(g_fSpecularIntensity*0.5f*vMaskColor.r,g_fSpecularPower/256.f,g_fCubeMapValue*vMaskColor.b,vColor.w); \r\n"
			"	vOut.m_vColor3.x = ExportVector2ToFloat( min(vAddColor.x * 0.33333333f, 1.f), min(vAddColor.y * 0.33333333f, 1.f) ); \r\n"
			"	vOut.m_vColor3.y = ExportVector2ToFloat( min(vAddColor.z * 0.33333333f, 1.f), vNorConvert.x ); \r\n"
			"	vOut.m_vColor3.z = ExportVector2ToFloat( vNorConvert.y, vNorConvert.z ); \r\n"
			"	vOut.m_vColor3.w = In.m_vColor2.w; \r\n"	// Opaque나 HardAlpha는 DirectionLight의 강도를 넘겨주도록 한다.
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique runtime_3 \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"				// 0
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3( 0, 0 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 0, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_ON \r\n"		// 1
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3( 1, 0 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 1, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL2_ON \r\n"		// 2
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3( 0, 1 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 0, 1 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_PL2_ON \r\n"	// 3
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3( 1, 1 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( false, 1, 1 ); \r\n"
			"	} \r\n"
			"	pass albedo_AlphTex \r\n"				// 0
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3( 0, 0 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 0, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_ON_AlphTex \r\n"		// 1
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3( 1, 0 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 1, 0 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL2_ON_AlphTex \r\n"		// 2
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3( 0, 1 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 0, 1 ); \r\n"
			"	} \r\n"
			"	pass albedo_PL1_PL2_ON_AlphTex \r\n"	// 3
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_3( 1, 1 ); \r\n"
			"		PixelShader = compile ps_3_0 PS_3( true, 1, 1 ); \r\n"
			"	} \r\n"
			"} \r\n"
			"technique runtime_Instancing \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"				// 0
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_INSTANCING(); \r\n"
			"		PixelShader = compile ps_3_0 PS_INSTANCING(); \r\n"
			"	} \r\n"
			"} \r\n"
			" \r\n";
	}

	void SetDecal_PS30_FX( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWorld; \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4x4 g_matView; \r\n"
			"float4x4 g_matProj; \r\n"
			"float2   g_vFOG;	// FogEnd, FogDist \r\n"
			"float    g_fSpecularPower = 256.f; \r\n"
			"float    g_fSpecularIntensity = 2.f; \r\n"
			"float    g_fAlpha; \r\n"
			"float2   g_vLightMapUV_Offset; \r\n"
			"float2   g_vLightMapUV_Multiply; \r\n"
			"float4	  g_vVoxelColor; \r\n"
			"float3	  g_vDecalBelndColor; \r\n"
			"float	  g_fCubeMapValue; \r\n"
			"float	  g_fDecalNormal=1.f;	\r\n"
			"float4   g_vWindowSize; \r\n"
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_MaskTexture; \r\n"
			"sampler MaskTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_MaskTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_pTextureLodBlend; \r\n"
			"sampler TextureLodBlendSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_pTextureLodBlend); \r\n"
			"}; \r\n"			
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float4 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_INPUT_DECAL		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"   float3 m_vNormal	: NORMAL; \r\n"
			"	float4 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"struct VS_INPUT_INSTANCING			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"   float3 m_vNormal		: NORMAL; \r\n"
			"	float4 m_vColor0		: COLOR0; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"	float4 m_vVC_AC0XY					: TEXCOORD1; \r\n"
			"	float4 m_vMatrix1_AC0W				: TEXCOORD2; \r\n"
			"	float4 m_vMatrix2_LMOffsetX			: TEXCOORD3; \r\n"
			"	float4 m_vMatrix3_LMOffsetY			: TEXCOORD4; \r\n"
			"	float4 m_vMatrix4					: TEXCOORD5; \r\n"
			"	float4 m_vAmbientCube_0Z_12_3X		: TEXCOORD6; \r\n"
			"	float4 m_vAmbientCube_3YZ_45		: TEXCOORD7; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_DECAL		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float4 m_vColor0		: COLOR0; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"	float3 m_vNormal		: TEXCOORD1; \r\n"
			"	float3 m_vPosProjSpace	: TEXCOORD2; \r\n"
			"	float  m_fFog			: FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"struct PS_DEFFERED_OUT		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vColor0	: COLOR0; \r\n"
			"	float4 m_vColor1	: COLOR1; \r\n"
			"	float4 m_vColor2	: COLOR2; \r\n"
			"}; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					P	S		game 렌더용 Decal \r\n"
			" \r\n"
			"VS_OUTPUT_DECAL VS_DECAL( VS_INPUT_DECAL In, uniform bool bFogEnable )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_DECAL Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	Out.m_vPosProjSpace = Out.m_vPosition.xyw; \r\n"
			"	Out.m_vNormal = normalize( mul(g_matWV, In.m_vNormal) ); \r\n"
			" \r\n"
			"	// Get Color \r\n"
			"	Out.m_vColor0 = In.m_vColor0; \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	Out.m_fFog = 1.f; \r\n"
			"	if ( bFogEnable ) \r\n"
			"	{ \r\n"
			"		Out.m_fFog = saturate((g_vFOG.x - Out.m_vPosition.z) / g_vFOG.y); \r\n"
			"	} \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_DECAL( VS_OUTPUT_DECAL In, uniform bool bBlendColor, uniform int nDecalMode )  \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	if ( bBlendColor ) \r\n"
			"	{ \r\n"
			"		vColor.xyz = (vColor.xyz*vColor.w)+(g_vDecalBelndColor*(1.f-vColor.w)); \r\n"
			"	} \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.z + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor *= In.m_vColor0; \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"	vOut.m_vColor1 = float4(normalize(In.m_vNormal),vColor.w*g_fDecalNormal); \r\n"
			"   vOut.m_vColor2 = float4(g_fSpecularIntensity*0.5f*vMaskColor.r,g_fSpecularPower/256.f,g_fCubeMapValue*vMaskColor.b,vColor.w*g_fDecalNormal); \r\n"
			" \r\n"
			"   if ( nDecalMode == 1 ) \r\n"	// Multiply
			"	{ \r\n"
			"		vOut.m_vColor1 = 1.f; \r\n"
			"		vOut.m_vColor2 = 1.f; \r\n"
			"	} \r\n"
			"   else if ( nDecalMode == 2 ) \r\n"	// Add
			"	{ \r\n"
			"		vOut.m_vColor1 = 0.f; \r\n"
			"		vOut.m_vColor2 = 0.f; \r\n"
			"	} \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_DECAL_ADD( VS_OUTPUT_DECAL In ) : COLOR0 \r\n"
			"{ \r\n"
			"	float4 vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			//"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			//"	vColor.xyz = (vColor.xyz*vColor.w)+(g_vDecalBelndColor*(1.f-vColor.w)); \r\n"
			//" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.z + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			//"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			//" \r\n"
			"	vColor *= In.m_vColor0; \r\n"
			"	vColor *= g_fAlpha; \r\n"
			//"	vColor.a *= g_fAlpha; \r\n"
			//"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	vOut = vColor; \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					P	S		game 렌더용 Decal INSTANCING \r\n"
			" \r\n"
			"VS_OUTPUT_DECAL VS_INSTANCING( VS_INPUT_INSTANCING In, uniform bool bFogEnable )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_DECAL Out; \r\n"
			" \r\n"
			"	g_matWorld[0].xyzw = float4(In.m_vMatrix1_AC0W.xyz,0.f); \r\n"
			"	g_matWorld[1].xyzw = float4(In.m_vMatrix2_LMOffsetX.xyz,0.f); \r\n"
			"	g_matWorld[2].xyzw = float4(In.m_vMatrix3_LMOffsetY.xyz,0.f); \r\n"
			"	g_matWorld[3].xyzw = In.m_vMatrix4; \r\n"
			" \r\n"
			"   g_matWV = mul(g_matWorld,g_matView); \r\n"
			"   g_matWVP = mul(g_matWV,g_matProj); \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(In.m_vPosition, g_matWVP); \r\n"
			"	Out.m_vPosProjSpace = Out.m_vPosition.xyw; \r\n"
			"	float3 vPos = mul(In.m_vPosition, g_matWorld); \r\n"
			"	Out.m_vNormal = normalize( mul(In.m_vNormal, g_matWV) ); \r\n"
			" \r\n"
			"	// Get Color \r\n"
			"	Out.m_vColor0 = In.m_vColor0; \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	Out.m_fFog = 1.f; \r\n"
			"	if ( bFogEnable ) \r\n"
			"	{ \r\n"
			"		Out.m_fFog = saturate((g_vFOG.x - Out.m_vPosition.z) / g_vFOG.y); \r\n"
			"	} \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_INSTANCING( VS_OUTPUT_DECAL In, uniform bool bBlendColor, uniform int nDecalMode )  \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	if ( bBlendColor ) \r\n"
			"	{ \r\n"
			"		vColor.xyz = (vColor.xyz*vColor.w)+(g_vDecalBelndColor*(1.f-vColor.w)); \r\n"
			"	} \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.z + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor *= In.m_vColor0; \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"	vOut.m_vColor1 = float4(normalize(In.m_vNormal),vColor.w*g_fDecalNormal); \r\n"
			"   vOut.m_vColor2 = float4(g_fSpecularIntensity*0.5f*vMaskColor.r,g_fSpecularPower/256.f,g_fCubeMapValue*vMaskColor.b,vColor.w*g_fDecalNormal); \r\n"
			" \r\n"
			"   if ( nDecalMode == 1 ) \r\n"	// Multiply
			"	{ \r\n"
			"		vOut.m_vColor1 = 1.f; \r\n"
			"		vOut.m_vColor2 = 1.f; \r\n"
			"	} \r\n"
			"   else if ( nDecalMode == 2 ) \r\n"	// Add
			"	{ \r\n"
			"		vOut.m_vColor1 = 0.f; \r\n"
			"		vOut.m_vColor2 = 0.f; \r\n"
			"	} \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_INSTANCING_ADD( VS_OUTPUT_DECAL In ) : COLOR0 \r\n"
			"{ \r\n"
			"	float4 vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			//"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			//"	vColor.xyz = (vColor.xyz*vColor.w)+(g_vDecalBelndColor*(1.f-vColor.w)); \r\n"
			//" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.z + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			//"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			//" \r\n"
			"	vColor *= In.m_vColor0; \r\n"
			"	vColor *= g_fAlpha; \r\n"
			//"	vColor.a *= g_fAlpha; \r\n"
			//"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	vOut = vColor; \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique runtime_3 \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass high \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_DECAL(false); \r\n"
			"		PixelShader = compile ps_3_0 PS_DECAL(false,0); \r\n"
			"	} \r\n"
			"	pass high_decal_multiply \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_DECAL(false); \r\n"
			"		PixelShader = compile ps_3_0 PS_DECAL(false,1); \r\n"
			"	} \r\n"
			"	pass pass2_decal_add \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_2_0 VS_DECAL(true); \r\n"
			"		PixelShader = compile ps_2_0 PS_DECAL_ADD(); \r\n"
			"	} \r\n"
			"	pass pieceinpsf \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_DECAL(true); \r\n"
			"		PixelShader = compile ps_3_0 PS_DECAL(true,1); \r\n"
			"	} \r\n"
			"} \r\n"
			"technique runtime_Instancing \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass high \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_INSTANCING(false); \r\n"
			"		PixelShader = compile ps_3_0 PS_INSTANCING(false,0); \r\n"
			"	} \r\n"
			"	pass high_decal_multiply \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_INSTANCING(false); \r\n"
			"		PixelShader = compile ps_3_0 PS_INSTANCING(false,1); \r\n"
			"	} \r\n"
			"	pass pass2_decal_add \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_2_0 VS_INSTANCING(true); \r\n"
			"		PixelShader = compile ps_2_0 PS_INSTANCING_ADD(); \r\n"
			"	} \r\n"
			"} \r\n"
			" \r\n";
	}
};
