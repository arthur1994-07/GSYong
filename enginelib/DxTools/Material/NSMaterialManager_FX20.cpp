#include "pch.h"

#include "NSMaterialManager.h"

// ----------------------------------------------------------------------------
#include "../../SigmaCore/DebugInclude.h"
// ----------------------------------------------------------------------------

namespace NSMaterialManager
{
	void SetDefaultFX( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWorld; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matView; \r\n"
			"float4x4 g_matProj; \r\n"
			"float3   g_vCameraFrom; \r\n"
			"float2   g_vFOG;		// FogEnd, FogDist \r\n"
			"float    g_fSpecularPower = 256.f; \r\n"
			"float    g_fSpecularIntensity = 2.f; \r\n"
			"float    g_fOverLightPowerLM = 3.f; \r\n"
			"float    g_fOverLightPower_PS_2_0 = 1.f; \r\n"
			"float    g_fVS_1_1_ColorMulti = 0.75f; \r\n"
			"float4   g_vWindowSize; \r\n"
			"float    g_fAlpha; \r\n"
			"float2   g_vLightMapUV_Offset; \r\n"
			"float2   g_vLightMapUV_Multiply; \r\n"
			"float3	  g_vVoxelColor; \r\n"
			"float	  g_fCubeMapValue; \r\n"
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_LightMapDayTex; \r\n"
			"sampler LightMapTexSampler_1st = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_LightMapDayTex); \r\n"
			"}; \r\n"
			" \r\n"
			" texture g_GlobalCubeTexture; \r\n"
			" samplerCUBE CubeTexSampler = sampler_state  \r\n"
			" { \r\n"
			" 	Texture = (g_GlobalCubeTexture); \r\n"
			" }; \r\n"
			" \r\n"
			"texture g_MaskTexture; \r\n"
			"sampler MaskTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_MaskTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_pTextureLodBlend; \r\n"
			"sampler TextureLodBlendSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_pTextureLodBlend); \r\n"
			"}; \r\n"			
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_INPUT			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			// SetDefault_PS30_FX 의 VS_INPUT 과 구조체가 동일해야 한다.
			// 최상위 옵션을 사용해도 반사로 인해 SetDefaultFX 를 사용해야 할 수 있으므로 구조체가 통일 되어야 한다.
			//"#ifdef USE_CUBEMAP \r\n"
			//"   float3 m_vNormal    : NORMAL; \r\n"
			//"#else \r\n"
			//"#ifdef USE_SPECULAR \r\n"
			//"   float3 m_vNormal    : NORMAL; \r\n"
			//"#endif \r\n"
			//"#endif \r\n"
			////"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			////"	float2 m_vLightmapUV   : TEXCOORD1;	// LightMap를 사용할 경우, m_vLightmapUV 이름을 유지해주세요. \r\n"
			"   float3 m_vNormal    : NORMAL; \r\n"
			"	float4 m_vAlbedoXY_LMZW   : TEXCOORD0;	// 합쳐진 것을 사용할 경우 m_vAlbedoXY_LMZW 를 사용합니다. \r\n"
			"	// m_vLightmapUV 이름이 있으면, LightMap을 생성해준다. \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"struct VS_INPUT_INSTANCING			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			//"#ifdef USE_CUBEMAP \r\n"
			//"   float3 m_vNormal    : NORMAL; \r\n"
			//"#else \r\n"
			//"#ifdef USE_SPECULAR \r\n"
			//"   float3 m_vNormal    : NORMAL; \r\n"
			//"#endif \r\n"
			//"#endif \r\n"
			"   float3 m_vNormal    : NORMAL; \r\n"
			"	float4 m_vAlbedoXY_LMZW				: TEXCOORD0;	// 합쳐진 것을 사용할 경우 m_vAlbedoXY_LMZW 를 사용합니다. \r\n"
			" \r\n"
			"	float4 m_vVC_AC0XY					: TEXCOORD1; \r\n"
			"	float4 m_vMatrix1_AC0W				: TEXCOORD2; \r\n"
			"	float4 m_vMatrix2_LMOffsetX			: TEXCOORD3; \r\n"
			"	float4 m_vMatrix3_LMOffsetY			: TEXCOORD4; \r\n"
			"	float4 m_vMatrix4					: TEXCOORD5; \r\n"
			"	float4 m_vAmbientCube_0Z_12_3X		: TEXCOORD6; \r\n"
			"	float4 m_vAmbientCube_3YZ_45		: TEXCOORD7; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_1		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float4 m_vColor0     : COLOR0;  \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float2 m_vLightmapUV : TEXCOORD1; \r\n"
			"	float  m_fFog       : FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_ALBEDO		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float2 m_vLightMapUV : TEXCOORD1; \r\n"
			"	float3 m_vPosViewSpace : TEXCOORD2; \r\n"
			"	float4 m_vPosProjSpace	: TEXCOORD3; \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"   float3 m_vCubeTexcoord : TEXCOORD4; \r\n"
			"#endif \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float3 m_vNor					: TEXCOORD5; \r\n"
			"	float3 m_vHalf					: TEXCOORD6; \r\n"
			"#endif \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_2_S		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition				: POSITION; \r\n"
			"	float4 m_vTexCoord0_vLightMapUV : TEXCOORD0; \r\n"// // Texture Alpha(xy) 값과 LightMapUV(zw)를 위함.
			"	float3 m_vPosLight				: TEXCOORD1; \r\n"
			"   float4 m_vShadowProjectionPos	: TEXCOORD2; \r\n"
			"	float  m_fFog					: FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_TEST	// test \r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"	float2 m_vLightmapUV	: TEXCOORD1; \r\n"
			"	float  m_fFog			: FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"struct PS_DEFFERED_OUT		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vColor0	: COLOR0; \r\n"
			"	float4 m_vColor1	: COLOR1; \r\n"
			"	float4 m_vColor2	: COLOR2; \r\n"
			"}; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.1.1 \r\n"
			"VS_OUTPUT_1 VS_1( VS_INPUT In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_1 Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			" \r\n"
			"	Out.m_vColor0 = float4(g_fVS_1_1_ColorMulti,g_fVS_1_1_ColorMulti,g_fVS_1_1_ColorMulti,1.f); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vAlbedoXY_LMZW.xy; \r\n"
			"	Out.m_vLightmapUV = In.m_vAlbedoXY_LMZW.zw; \r\n"
			"	Out.m_vLightmapUV.xy += g_vLightMapUV_Offset; \r\n"
			" \r\n"
			"	Out.m_fFog = saturate((g_vFOG.x - Out.m_vPosition.z) / g_vFOG.y); \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_1( VS_OUTPUT_1 In ) : COLOR0  \r\n"
			"{ \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	// 라이트맵  \r\n"
			"   float4 vLightColor = tex2D( LightMapTexSampler_1st, In.m_vLightmapUV ); \r\n"
			" \r\n"
			"	vColor.xyz *= vLightColor.xyz * In.m_vColor0.xyz * 4.f; \r\n"
			"	vColor.w *= g_fAlpha; \r\n"
			" \r\n"
			"	return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.2.0 Albedo \r\n"
			"VS_OUTPUT_ALBEDO VS_2( VS_INPUT In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	float3 vPos = mul(g_matWorld, In.m_vPosition); \r\n"
			"	Out.m_vPosViewSpace = mul(g_matWV, In.m_vPosition).xyz; \r\n"
			"	Out.m_vPosProjSpace = mul(g_matWVP, In.m_vPosition); \r\n"
			" \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vNor = normalize(mul(g_matWorld, In.m_vNormal)); \r\n"
			"#else \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float3 vNor = normalize(mul(g_matWorld, In.m_vNormal)); \r\n"
			"#endif \r\n"
			"#endif \r\n"
			" \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vEyeToVector = normalize(vPos - g_vCameraFrom); \r\n"
			"	Out.m_vCubeTexcoord = reflect(vEyeToVector, vNor); \r\n"
			"#endif \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vAlbedoXY_LMZW.xy; \r\n"
			" \r\n"
			"	Out.m_vLightMapUV = In.m_vAlbedoXY_LMZW.zw; \r\n"
			"	Out.m_vLightMapUV += g_vLightMapUV_Offset; \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 CUBE_SPEC_PS_2( VS_OUTPUT_ALBEDO In, float4 vColor ) \r\n"
			"{ \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float fSpec = pow( saturate( dot( normalize(In.m_vHalf.xyz), normalize( In.m_vNor ) ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
			"	fSpec *= vMaskColor.x; \r\n"
			" \r\n"
			"	float fNormalDot = 1.f; \r\n"
			"   fNormalDot += fSpec;								// Add Specular \r\n"
			"   vColor.xyz *= fNormalDot; \r\n"	
			"#endif \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMapMask \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float fCubeMapValue = g_fCubeMapValue; \r\n"
			"	{ \r\n"
			"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"		fCubeMapValue *= vMaskColor.z; \r\n"
			"	} \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMap \r\n"
			"	{ \r\n"
			"		vColor.xyz = vColor.xyz*(1.f-fCubeMapValue) + texCUBE( CubeTexSampler, In.m_vCubeTexcoord ).xyz * fCubeMapValue; \r\n"
			"	} \r\n"
			"#endif \r\n"
			" \r\n"
			" return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_2( VS_OUTPUT_ALBEDO In )  \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.w + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor = CUBE_SPEC_PS_2( In, vColor ); \r\n"
			" \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"   vOut.m_vColor1 = 1.f; \r\n"
			"	vOut.m_vColor1.xyz = tex2D( LightMapTexSampler_1st, In.m_vLightMapUV ) * g_fOverLightPowerLM * g_fOverLightPower_PS_2_0 / 3; \r\n"
			"   vOut.m_vColor2 = 1.f; \r\n"
			"   vOut.m_vColor2.xyz = In.m_vPosViewSpace; \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.2.0 Albedo INSTANCING	\r\n"
			"VS_OUTPUT_ALBEDO VS_INSTANCING( VS_INPUT_INSTANCING In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO Out; \r\n"
			" \r\n"
			"	g_matWorld[0].xyzw = float4(In.m_vMatrix1_AC0W.xyz,0.f); \r\n"
			"	g_matWorld[1].xyzw = float4(In.m_vMatrix2_LMOffsetX.xyz,0.f); \r\n"
			"	g_matWorld[2].xyzw = float4(In.m_vMatrix3_LMOffsetY.xyz,0.f); \r\n"
			"	g_matWorld[3].xyzw = In.m_vMatrix4; \r\n"
			" \r\n"
			"   g_matWV = mul(g_matWorld,g_matView); \r\n"
			"   g_matWVP = mul(g_matWV,g_matProj); \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(In.m_vPosition, g_matWVP); \r\n"
			"	float3 vPos = mul(In.m_vPosition, g_matWorld); \r\n"
			"	Out.m_vPosViewSpace = mul(In.m_vPosition, g_matWV).xyz; \r\n"
			"	Out.m_vPosProjSpace = mul(In.m_vPosition, g_matWVP); \r\n"
			" \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vNor = normalize(mul(In.m_vNormal, g_matWorld)); \r\n"
			"#else \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float3 vNor = normalize(mul(In.m_vNormal, g_matWorld)); \r\n"
			"#endif \r\n"
			"#endif \r\n"
			" \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vEyeToVector = normalize(vPos - g_vCameraFrom); \r\n"
			"	Out.m_vCubeTexcoord = reflect(vEyeToVector, vNor); \r\n"
			"#endif \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vAlbedoXY_LMZW.xy; \r\n"
			" \r\n"
			"	Out.m_vLightMapUV = In.m_vAlbedoXY_LMZW.zw; \r\n"
			"	Out.m_vLightMapUV += float2(In.m_vMatrix2_LMOffsetX.w, In.m_vMatrix3_LMOffsetY.w); \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					P	S		test 렌더용 \r\n"
			" \r\n"
			"VS_OUTPUT_TEST VS_TEST( VS_INPUT In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_TEST Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vAlbedoXY_LMZW.xy; \r\n"
			"	Out.m_vLightmapUV = In.m_vAlbedoXY_LMZW.zw; \r\n"
			"	Out.m_vLightmapUV.xy += g_vLightMapUV_Offset; \r\n"
			" \r\n"
			"	Out.m_fFog = saturate((g_vFOG.x - Out.m_vPosition.z) / g_vFOG.y); \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_TEST( VS_OUTPUT_TEST In ) : COLOR0  \r\n"
			"{ \r\n"
			"	// Texture \r\n"
			"	// 라이트맵  \r\n"
			"   float2 vUV = In.m_vLightmapUV*g_vLightMapUV_Multiply; \r\n"
			"   float4 vLightMapDay = tex2D( LightMapTexSampler_1st, vUV ); \r\n"
			" \r\n"
			"	float4 vColor = vLightMapDay * g_fOverLightPower_PS_2_0; \r\n"
			"	vColor.w = g_fAlpha; \r\n"
			" \r\n"
			"	return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique runtime_1 \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass high \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_1_1 VS_1(); \r\n"
			"		PixelShader = compile ps_1_1 PS_1(); \r\n"
			"	} \r\n"
			"} \r\n"
			"technique runtime_2 \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_2(); \r\n"
			"		PixelShader = compile ps_3_0 PS_2(); \r\n"
			"	} \r\n"
			"} \r\n"
			"technique runtime_Instancing \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_INSTANCING(); \r\n"
			"		PixelShader = compile ps_3_0 PS_2(); \r\n"
			"	} \r\n"
			"} \r\n"
			"technique lightmaptest \r\n"
			"{ \r\n"
			"	pass high \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_2_0 VS_TEST(); \r\n"
			"		PixelShader = compile ps_2_0 PS_TEST(); \r\n"
			"	} \r\n"
			"} \r\n"
			" \r\n";
	}

	void SetVoxelColorFX( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWorld; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matView; \r\n"
			"float4x4 g_matProj; \r\n"
			"float3   g_vCameraFrom; \r\n"
			"float2   g_vFOG;	// FogEnd, FogDist \r\n"
			"float    g_fSpecularPower = 256.f; \r\n"
			"float    g_fSpecularIntensity = 2.f; \r\n"
			"float    g_fOverLightPower_PS_2_0 = 1.f; \r\n"
			"float4   g_vWindowSize; \r\n"
			"float    g_fAlpha; \r\n"
			"float3	  g_vVoxelColor; \r\n"
			"float	  g_fCubeMapValue; \r\n"
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			" texture g_GlobalCubeTexture; \r\n"
			" samplerCUBE CubeTexSampler = sampler_state  \r\n"
			" { \r\n"
			" 	Texture = (g_GlobalCubeTexture); \r\n"
			" }; \r\n"
			" \r\n"
			"texture g_MaskTexture; \r\n"
			"sampler MaskTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_MaskTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_pTextureLodBlend; \r\n"
			"sampler TextureLodBlendSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_pTextureLodBlend); \r\n"
			"}; \r\n"			
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_INPUT			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			//"#ifdef USE_CUBEMAP \r\n"
			//"   float3 m_vNormal    : NORMAL; \r\n"
			//"#else \r\n"
			//"#ifdef USE_SPECULAR \r\n"
			//"   float3 m_vNormal    : NORMAL; \r\n"
			//"#endif \r\n"
			//"#endif \r\n"
			"   float3 m_vNormal    : NORMAL; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"struct VS_INPUT_INSTANCING			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			//"#ifdef USE_CUBEMAP \r\n"
			//"   float3 m_vNormal    : NORMAL; \r\n"
			//"#else \r\n"
			//"#ifdef USE_SPECULAR \r\n"
			//"   float3 m_vNormal    : NORMAL; \r\n"
			//"#endif \r\n"
			//"#endif \r\n"
			"   float3 m_vNormal    : NORMAL; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			" \r\n"
			"	float4 m_vVC_AC0XY					: TEXCOORD1; \r\n"
			"	float4 m_vMatrix1_AC0W				: TEXCOORD2; \r\n"
			"	float4 m_vMatrix2_LMOffsetX			: TEXCOORD3; \r\n"
			"	float4 m_vMatrix3_LMOffsetY			: TEXCOORD4; \r\n"
			"	float4 m_vMatrix4					: TEXCOORD5; \r\n"
			"	float4 m_vAmbientCube_0Z_12_3X		: TEXCOORD6; \r\n"
			"	float4 m_vAmbientCube_3YZ_45		: TEXCOORD7; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_1		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float  m_fFog       : FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_ALBEDO		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float3 m_vPosViewSpace : TEXCOORD1; \r\n"
			"	float4 m_vPosProjSpace	: TEXCOORD2; \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"   float3 m_vCubeTexcoord : TEXCOORD3; \r\n"
			"#endif \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float3 m_vNor					: TEXCOORD4; \r\n"
			"	float3 m_vHalf					: TEXCOORD5; \r\n"
			"#endif \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_ALBEDO_INSTANCING		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float3 m_vPosViewSpace : TEXCOORD1; \r\n"
			"	float4 m_vPosProjSpace	: TEXCOORD2; \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"   float3 m_vCubeTexcoord : TEXCOORD3; \r\n"
			"#endif \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float3 m_vNor					: TEXCOORD4; \r\n"
			"	float3 m_vHalf					: TEXCOORD5; \r\n"
			"#endif \r\n"
			"	float3 m_vVoxelColor			: TEXCOORD6; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_2_S \r\n"
			"{ \r\n"
			"	float4 m_vPosition				: POSITION; \r\n"
			"	float2 m_vTexCoord0				: TEXCOORD0; \r\n"
			"	float3 m_vPosLight				: TEXCOORD1; \r\n"
			"   float4 m_vShadowProjectionPos	: TEXCOORD2; \r\n"
			"	float  m_fFog					: FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"struct PS_DEFFERED_OUT		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vColor0	: COLOR0; \r\n"
			"	float4 m_vColor1	: COLOR1; \r\n"
			"	float4 m_vColor2	: COLOR2; \r\n"
			"}; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.1.1 \r\n"
			"VS_OUTPUT_1 VS_1( VS_INPUT In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_1 Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	Out.m_fFog = saturate((g_vFOG.x - Out.m_vPosition.z) / g_vFOG.y); \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_1( VS_OUTPUT_1 In ) : COLOR0  \r\n"
			"{ \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	vColor.xyz *= g_vVoxelColor.xyz; \r\n"
			"	vColor.w *= g_fAlpha; \r\n"
			" \r\n"
			"	return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.2.0 Albedo \r\n"
			"VS_OUTPUT_ALBEDO VS_2( VS_INPUT In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	float3 vPos = mul(g_matWorld, In.m_vPosition); \r\n"
			"	Out.m_vPosViewSpace = mul(g_matWV, In.m_vPosition).xyz; \r\n"
			"	Out.m_vPosProjSpace = mul(g_matWVP, In.m_vPosition); \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vNor = normalize(mul(g_matWorld, In.m_vNormal)); \r\n"
			"#else \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float3 vNor = normalize(mul(g_matWorld, In.m_vNormal)); \r\n"
			"#endif \r\n"
			"#endif \r\n"
			" \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vEyeToVector = normalize(vPos - g_vCameraFrom); \r\n"
			"	Out.m_vCubeTexcoord = reflect(vEyeToVector, vNor); \r\n"
			"#endif \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 CUBE_SPEC_PS_2( VS_OUTPUT_ALBEDO In, float4 vColor ) \r\n"
			"{ \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float fSpec = pow( saturate( dot( normalize(In.m_vHalf.xyz), normalize( In.m_vNor ) ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
			"	fSpec *= vMaskColor.x; \r\n"
			" \r\n"
			"	float fNormalDot = 1.f; \r\n"
			"   fNormalDot += fSpec;								// Add Specular \r\n"
			"   vColor.xyz *= fNormalDot; \r\n"	
			"#endif \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMapMask \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float fCubeMapValue = g_fCubeMapValue; \r\n"
			"	{ \r\n"
			"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"		fCubeMapValue *= vMaskColor.z; \r\n"
			"	} \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMap \r\n"
			"	{ \r\n"
			"		vColor.xyz = vColor.xyz*(1.f-fCubeMapValue) + texCUBE( CubeTexSampler, In.m_vCubeTexcoord ).xyz * fCubeMapValue; \r\n"
			"	} \r\n"
			"#endif \r\n"
			" \r\n"
			" return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_2( VS_OUTPUT_ALBEDO In )  \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.w + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor = CUBE_SPEC_PS_2( In, vColor ); \r\n"
			" \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"   vOut.m_vColor1 = 1.f; \r\n"
			"	vOut.m_vColor1.xyz = g_vVoxelColor.xyz * g_fOverLightPower_PS_2_0 / 3; \r\n"
			"   vOut.m_vColor2 = 1.f; \r\n"
			"   vOut.m_vColor2.xyz = In.m_vPosViewSpace; \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.2.0 Albedo INSTANCING \r\n"
			"VS_OUTPUT_ALBEDO_INSTANCING VS_INSTANCING( VS_INPUT_INSTANCING In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO_INSTANCING Out; \r\n"
			" \r\n"
			"	g_matWorld[0].xyzw = float4(In.m_vMatrix1_AC0W.xyz,0.f); \r\n"
			"	g_matWorld[1].xyzw = float4(In.m_vMatrix2_LMOffsetX.xyz,0.f); \r\n"
			"	g_matWorld[2].xyzw = float4(In.m_vMatrix3_LMOffsetY.xyz,0.f); \r\n"
			"	g_matWorld[3].xyzw = In.m_vMatrix4; \r\n"
			" \r\n"
			"	Out.m_vVoxelColor = In.m_vVC_AC0XY.xyz; \r\n"
			" \r\n"
			"   g_matWV = mul(g_matWorld,g_matView); \r\n"
			"   g_matWVP = mul(g_matWV,g_matProj); \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(In.m_vPosition, g_matWVP); \r\n"
			"	float3 vPos = mul(In.m_vPosition, g_matWorld); \r\n"
			"	Out.m_vPosViewSpace = mul(In.m_vPosition, g_matWV).xyz; \r\n"
			"	Out.m_vPosProjSpace = mul(In.m_vPosition, g_matWVP); \r\n"
			" \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vNor = normalize(mul(In.m_vNormal, g_matWorld)); \r\n"
			"#else \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float3 vNor = normalize(mul(In.m_vNormal, g_matWorld)); \r\n"
			"#endif \r\n"
			"#endif \r\n"
			" \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vEyeToVector = normalize(vPos - g_vCameraFrom); \r\n"
			"	Out.m_vCubeTexcoord = reflect(vEyeToVector, vNor); \r\n"
			"#endif \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 CUBE_SPEC_PS_2_INSTANCING( VS_OUTPUT_ALBEDO_INSTANCING In, float4 vColor ) \r\n"
			"{ \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float fSpec = pow( saturate( dot( normalize(In.m_vHalf.xyz), normalize( In.m_vNor ) ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
			"	fSpec *= vMaskColor.x; \r\n"
			" \r\n"
			"	float fNormalDot = 1.f; \r\n"
			"   fNormalDot += fSpec;								// Add Specular \r\n"
			"   vColor.xyz *= fNormalDot; \r\n"	
			"#endif \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMapMask \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float fCubeMapValue = g_fCubeMapValue; \r\n"
			"	{ \r\n"
			"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"		fCubeMapValue *= vMaskColor.z; \r\n"
			"	} \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMap \r\n"
			"	{ \r\n"
			"		vColor.xyz = vColor.xyz*(1.f-fCubeMapValue) + texCUBE( CubeTexSampler, In.m_vCubeTexcoord ).xyz * fCubeMapValue; \r\n"
			"	} \r\n"
			"#endif \r\n"
			" \r\n"
			" return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_INSTANCING( VS_OUTPUT_ALBEDO_INSTANCING In )  \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.w + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor = CUBE_SPEC_PS_2_INSTANCING( In, vColor ); \r\n"
			" \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"   vOut.m_vColor1 = 1.f; \r\n"
			"	vOut.m_vColor1.xyz = In.m_vVoxelColor.xyz * g_fOverLightPower_PS_2_0 / 3; \r\n"
			"   vOut.m_vColor2 = 1.f; \r\n"
			"   vOut.m_vColor2.xyz = In.m_vPosViewSpace; \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique runtime_1 \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass high \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_1_1 VS_1(); \r\n"
			"		PixelShader = compile ps_1_1 PS_1(); \r\n"
			"	} \r\n"
			"} \r\n"
			"technique runtime_2 \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_2(); \r\n"
			"		PixelShader = compile ps_3_0 PS_2(); \r\n"
			"	} \r\n"
			"} \r\n"
			"technique runtime_Instancing \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_INSTANCING(); \r\n"
			"		PixelShader = compile ps_3_0 PS_INSTANCING(); \r\n"
			"	} \r\n"
			"} \r\n"
			" \r\n";
	}

	void SetVoxelColorVertexColorFX( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWorld; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matView; \r\n"
			"float4x4 g_matProj; \r\n"
			"float3   g_vCameraFrom; \r\n"
			"float2   g_vFOG;	// FogEnd, FogDist \r\n"
			"float    g_fSpecularPower = 256.f; \r\n"
			"float    g_fSpecularIntensity = 2.f; \r\n"
			"float    g_fOverLightPower_PS_2_0 = 1.f; \r\n"
			"float4   g_vWindowSize; \r\n"
			"float    g_fAlpha; \r\n"
			"float3	  g_vVoxelColor; \r\n"
			"float	  g_fCubeMapValue; \r\n"
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			" texture g_GlobalCubeTexture; \r\n"
			" samplerCUBE CubeTexSampler = sampler_state  \r\n"
			" { \r\n"
			" 	Texture = (g_GlobalCubeTexture); \r\n"
			" }; \r\n"
			" \r\n"
			"texture g_MaskTexture; \r\n"
			"sampler MaskTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_MaskTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_pTextureLodBlend; \r\n"
			"sampler TextureLodBlendSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_pTextureLodBlend); \r\n"
			"}; \r\n"			
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float4 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_INPUT			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			//"#ifdef USE_CUBEMAP \r\n"
			//"   float3 m_vNormal    : NORMAL; \r\n"
			//"#else \r\n"
			//"#ifdef USE_SPECULAR \r\n"
			//"   float3 m_vNormal    : NORMAL; \r\n"
			//"#endif \r\n"
			//"#endif \r\n"
			"   float3 m_vNormal    : NORMAL; \r\n"
			"	float4 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"struct VS_INPUT_INSTANCING			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			//"#ifdef USE_CUBEMAP \r\n"
			//"   float3 m_vNormal    : NORMAL; \r\n"
			//"#else \r\n"
			//"#ifdef USE_SPECULAR \r\n"
			//"   float3 m_vNormal    : NORMAL; \r\n"
			//"#endif \r\n"
			//"#endif \r\n"
			"   float3 m_vNormal    : NORMAL; \r\n"
			"	float4 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			" \r\n"
			"	float4 m_vVC_AC0XY					: TEXCOORD1; \r\n"
			"	float4 m_vMatrix1_AC0W				: TEXCOORD2; \r\n"
			"	float4 m_vMatrix2_LMOffsetX			: TEXCOORD3; \r\n"
			"	float4 m_vMatrix3_LMOffsetY			: TEXCOORD4; \r\n"
			"	float4 m_vMatrix4					: TEXCOORD5; \r\n"
			"	float4 m_vAmbientCube_0Z_12_3X		: TEXCOORD6; \r\n"
			"	float4 m_vAmbientCube_3YZ_45		: TEXCOORD7; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_1		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float4 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float  m_fFog       : FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_ALBEDO		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float4 m_vColor0	: COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float3 m_vPosViewSpace : TEXCOORD1; \r\n"
			"	float4 m_vPosProjSpace	: TEXCOORD2; \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"   float3 m_vCubeTexcoord : TEXCOORD3; \r\n"
			"#endif \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float3 m_vNor			: TEXCOORD4; \r\n"
			"	float3 m_vHalf			: TEXCOORD5; \r\n"
			"#endif \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_ALBEDO_INSTANCING		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float4 m_vColor0	: COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float3 m_vPosViewSpace : TEXCOORD1; \r\n"
			"	float4 m_vPosProjSpace	: TEXCOORD2; \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"   float3 m_vCubeTexcoord : TEXCOORD3; \r\n"
			"#endif \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float3 m_vNor			: TEXCOORD4; \r\n"
			"	float3 m_vHalf			: TEXCOORD5; \r\n"
			"#endif \r\n"
			"	float3 m_vVoxelColor	: TEXCOORD6; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_2_S \r\n"
			"{ \r\n"
			"	float4 m_vPosition				: POSITION; \r\n"
			"	float2 m_vTexCoord0				: TEXCOORD0; \r\n"
			"	float3 m_vPosLight				: TEXCOORD1; \r\n"
			"   float4 m_vShadowProjectionPos	: TEXCOORD2; \r\n"
			"	float  m_fFog					: FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"struct PS_DEFFERED_OUT		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vColor0	: COLOR0; \r\n"
			"	float4 m_vColor1	: COLOR1; \r\n"
			"	float4 m_vColor2	: COLOR2; \r\n"
			"}; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.1.1 \r\n"
			"VS_OUTPUT_1 VS_1( VS_INPUT In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_1 Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			" \r\n"
			"	// Get Color \r\n"
			"	Out.m_vColor0 = In.m_vColor0; \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	Out.m_fFog = saturate((g_vFOG.x - Out.m_vPosition.z) / g_vFOG.y); \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_1( VS_OUTPUT_1 In ) : COLOR0  \r\n"
			"{ \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	vColor *= In.m_vColor0; \r\n"
			"	vColor.xyz *= g_vVoxelColor.xyz; \r\n"
			"	vColor.w *= g_fAlpha; \r\n"
			" \r\n"
			"	return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.2.0 Albedo \r\n"
			"VS_OUTPUT_ALBEDO VS_2( VS_INPUT In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	float3 vPos = mul(g_matWorld, In.m_vPosition); \r\n"
			"	Out.m_vPosViewSpace = mul(g_matWV, In.m_vPosition).xyz; \r\n"
			"	Out.m_vPosProjSpace = mul(g_matWVP, In.m_vPosition); \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vNor = normalize(mul(g_matWorld, In.m_vNormal)); \r\n"
			"#else \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float3 vNor = normalize(mul(g_matWorld, In.m_vNormal)); \r\n"
			"#endif \r\n"
			"#endif \r\n"
			" \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vEyeToVector = normalize(vPos - g_vCameraFrom); \r\n"
			"	Out.m_vCubeTexcoord = reflect(vEyeToVector, vNor); \r\n"
			"#endif \r\n"
			" \r\n"
			"	// Get Color \r\n"
			"	Out.m_vColor0 = In.m_vColor0; \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 CUBE_SPEC_PS_2( VS_OUTPUT_ALBEDO In, float4 vColor ) \r\n"
			"{ \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float fSpec = pow( saturate( dot( normalize(In.m_vHalf.xyz), normalize( In.m_vNor ) ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
			"	fSpec *= vMaskColor.x; \r\n"
			" \r\n"
			"	float fNormalDot = 1.f; \r\n"
			"   fNormalDot += fSpec;								// Add Specular \r\n"
			"   vColor.xyz *= fNormalDot; \r\n"	
			"#endif \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMapMask \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float fCubeMapValue = g_fCubeMapValue; \r\n"
			"	{ \r\n"
			"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"		fCubeMapValue *= vMaskColor.z; \r\n"
			"	} \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMap \r\n"
			"	{ \r\n"
			"		vColor.xyz = vColor.xyz*(1.f-fCubeMapValue) + texCUBE( CubeTexSampler, In.m_vCubeTexcoord ).xyz * fCubeMapValue; \r\n"
			"	} \r\n"
			"#endif \r\n"
			" \r\n"
			" return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_2( VS_OUTPUT_ALBEDO In ) \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.w + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor = CUBE_SPEC_PS_2( In, vColor ); \r\n"
			" \r\n"
			"	vColor *= In.m_vColor0; \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"   vOut.m_vColor1 = 1.f; \r\n"
			"	vOut.m_vColor1.xyz = g_vVoxelColor.xyz * g_fOverLightPower_PS_2_0 / 3; \r\n"
			"   vOut.m_vColor2 = 1.f; \r\n"
			"   vOut.m_vColor2.xyz = In.m_vPosViewSpace; \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.2.0 Albedo INSTANCING \r\n"
			"VS_OUTPUT_ALBEDO_INSTANCING VS_INSTANCING( VS_INPUT_INSTANCING In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO_INSTANCING Out; \r\n"
			" \r\n"
			"	g_matWorld[0].xyzw = float4(In.m_vMatrix1_AC0W.xyz,0.f); \r\n"
			"	g_matWorld[1].xyzw = float4(In.m_vMatrix2_LMOffsetX.xyz,0.f); \r\n"
			"	g_matWorld[2].xyzw = float4(In.m_vMatrix3_LMOffsetY.xyz,0.f); \r\n"
			"	g_matWorld[3].xyzw = In.m_vMatrix4; \r\n"
			" \r\n"
			"	Out.m_vVoxelColor = In.m_vVC_AC0XY.xyz; \r\n"
			" \r\n"
			"   g_matWV = mul(g_matWorld,g_matView); \r\n"
			"   g_matWVP = mul(g_matWV,g_matProj); \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(In.m_vPosition, g_matWVP); \r\n"
			"	float3 vPos = mul(In.m_vPosition, g_matWorld); \r\n"
			"	Out.m_vPosViewSpace = mul(In.m_vPosition, g_matWV).xyz; \r\n"
			"	Out.m_vPosProjSpace = mul(In.m_vPosition, g_matWVP); \r\n"
			" \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vNor = normalize(mul(In.m_vNormal, g_matWorld)); \r\n"
			"#else \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float3 vNor = normalize(mul(In.m_vNormal, g_matWorld)); \r\n"
			"#endif \r\n"
			"#endif \r\n"
			" \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vEyeToVector = normalize(vPos - g_vCameraFrom); \r\n"
			"	Out.m_vCubeTexcoord = reflect(vEyeToVector, vNor); \r\n"
			"#endif \r\n"
			" \r\n"
			"	// Get Color \r\n"
			"	Out.m_vColor0 = In.m_vColor0; \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 CUBE_SPEC_PS_2_INSTANCING( VS_OUTPUT_ALBEDO_INSTANCING In, float4 vColor ) \r\n"
			"{ \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float fSpec = pow( saturate( dot( normalize(In.m_vHalf.xyz), normalize( In.m_vNor ) ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
			"	fSpec *= vMaskColor.x; \r\n"
			" \r\n"
			"	float fNormalDot = 1.f; \r\n"
			"   fNormalDot += fSpec;								// Add Specular \r\n"
			"   vColor.xyz *= fNormalDot; \r\n"	
			"#endif \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMapMask \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float fCubeMapValue = g_fCubeMapValue; \r\n"
			"	{ \r\n"
			"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"		fCubeMapValue *= vMaskColor.z; \r\n"
			"	} \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMap \r\n"
			"	{ \r\n"
			"		vColor.xyz = vColor.xyz*(1.f-fCubeMapValue) + texCUBE( CubeTexSampler, In.m_vCubeTexcoord ).xyz * fCubeMapValue; \r\n"
			"	} \r\n"
			"#endif \r\n"
			" \r\n"
			" return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_INSTANCING( VS_OUTPUT_ALBEDO_INSTANCING In ) \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.w + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor = CUBE_SPEC_PS_2_INSTANCING( In, vColor ); \r\n"
			" \r\n"
			"	vColor *= In.m_vColor0; \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"   vOut.m_vColor1 = 1.f; \r\n"
			"	vOut.m_vColor1.xyz = In.m_vVoxelColor.xyz * g_fOverLightPower_PS_2_0 / 3; \r\n"
			"   vOut.m_vColor2 = 1.f; \r\n"
			"   vOut.m_vColor2.xyz = In.m_vPosViewSpace; \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique runtime_1 \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass high \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_1_1 VS_1(); \r\n"
			"		PixelShader = compile ps_1_1 PS_1(); \r\n"
			"	} \r\n"
			"} \r\n"
			"technique runtime_2 \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_2(); \r\n"
			"		PixelShader = compile ps_3_0 PS_2(); \r\n"
			"	} \r\n"
			"} \r\n"
			"technique runtime_Instancing \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_INSTANCING(); \r\n"
			"		PixelShader = compile ps_3_0 PS_INSTANCING(); \r\n"
			"	} \r\n"
			"} \r\n"
			" \r\n";
	}

	void SetAmbientCubeFX( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWorld; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matView; \r\n"
			"float4x4 g_matProj; \r\n"
			"float3   g_vCameraFrom; \r\n"
			"float2   g_vFOG;	// FogEnd, FogDist \r\n"
			"float    g_fSpecularPower = 256.f; \r\n"
			"float    g_fSpecularIntensity = 2.f; \r\n"
			"float    g_fOverLightPower_PS_2_0 = 1.f; \r\n"
			"float4   g_vWindowSize; \r\n"
			"float    g_fAlpha; \r\n"
			"float3	  g_vAmbientCube[6]; \r\n"
			"float	  g_fCubeMapValue; \r\n"
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			" texture g_GlobalCubeTexture; \r\n"
			" samplerCUBE CubeTexSampler = sampler_state  \r\n"
			" { \r\n"
			" 	Texture = (g_GlobalCubeTexture); \r\n"
			" }; \r\n"
			" \r\n"
			"texture g_MaskTexture; \r\n"
			"sampler MaskTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_MaskTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_pTextureLodBlend; \r\n"
			"sampler TextureLodBlendSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_pTextureLodBlend); \r\n"
			"}; \r\n"			
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_INPUT			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"struct VS_INPUT_INSTANCING			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			" \r\n"
			"	float4 m_vVC_AC0XY					: TEXCOORD1; \r\n"
			"	float4 m_vMatrix1_AC0W				: TEXCOORD2; \r\n"
			"	float4 m_vMatrix2_LMOffsetX			: TEXCOORD3; \r\n"
			"	float4 m_vMatrix3_LMOffsetY			: TEXCOORD4; \r\n"
			"	float4 m_vMatrix4					: TEXCOORD5; \r\n"
			"	float4 m_vAmbientCube_0Z_12_3X		: TEXCOORD6; \r\n"
			"	float4 m_vAmbientCube_3YZ_45		: TEXCOORD7; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_1		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float  m_fFog       : FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_ALBEDO		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float3 m_vPosViewSpace : TEXCOORD1; \r\n"
			"	float4 m_vPosProjSpace	: TEXCOORD2; \r\n"
			"	float3 m_vColor0    : TEXCOORD3; \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"   float3 m_vCubeTexcoord : TEXCOORD4; \r\n"
			"#endif \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float3 m_vNor			: TEXCOORD5; \r\n"
			"	float3 m_vHalf			: TEXCOORD6; \r\n"
			"#endif \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_2_S \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float3 m_vPosLight	: TEXCOORD1; \r\n"
			"	float3 m_vColor0    : TEXCOORD2; \r\n"
			"   float4 m_vShadowProjectionPos : TEXCOORD3; \r\n"
			"	float  m_fFog       : FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"struct PS_DEFFERED_OUT		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vColor0	: COLOR0; \r\n"
			"	float4 m_vColor1	: COLOR1; \r\n"
			"	float4 m_vColor2	: COLOR2; \r\n"
			"}; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"float3 AmbientLight( const float3 worldNormal) \r\n"
			"{ \r\n"
			"   float3 nSquared= worldNormal* worldNormal; \r\n"
			"   int3 isNegative= ( worldNormal< 0.0 ); \r\n"
			"   float3 linearColor; \r\n"
			"   linearColor= nSquared.x* g_vAmbientCube[isNegative.x] + \r\n"
			"	nSquared.y* g_vAmbientCube[isNegative.y+2] + \r\n"
			"	nSquared.z* g_vAmbientCube[isNegative.z+4]; \r\n"
			"   return linearColor; \r\n"
			"} \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.1.1 \r\n"
			"VS_OUTPUT_1 VS_1( VS_INPUT In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_1 Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			" \r\n"
			"   float3 vNor = normalize( mul(g_matWorld, In.m_vNormal) ); \r\n"
			"   Out.m_vColor0 = float4(AmbientLight( vNor )*0.25f,1.f); \r\n"		// ps.1.x 버젼에서 3 을 곱할 수가 없어서 0.3333 을 넣지 못하고 0.5를 넣었다. OverLighting 를 위함.
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	Out.m_fFog = saturate((g_vFOG.x - Out.m_vPosition.z) / g_vFOG.y); \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_1( VS_OUTPUT_1 In ) : COLOR0  \r\n"
			"{ \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	vColor.xyz *= In.m_vColor0.xyz * 4.f; \r\n"							// OverLighting 을 위함.
			"	vColor.w *= g_fAlpha; \r\n"
			" \r\n"
			"	return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.2.0 Albedo \r\n"
			"VS_OUTPUT_ALBEDO VS_2( VS_INPUT In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	float3 vPos = mul(g_matWorld, In.m_vPosition); \r\n"
			"	Out.m_vPosViewSpace = mul(g_matWV, In.m_vPosition).xyz; \r\n"
			"	Out.m_vPosProjSpace = mul(g_matWVP, In.m_vPosition); \r\n"
			"	float3 vNor = normalize(mul(g_matWorld, In.m_vNormal)); \r\n"
			" \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vEyeToVector = normalize(vPos - g_vCameraFrom); \r\n"
			"	Out.m_vCubeTexcoord = reflect(vEyeToVector, vNor); \r\n"
			"#endif \r\n"
			" \r\n"
			"   Out.m_vColor0 = AmbientLight( vNor ); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 CUBE_SPEC_PS_2( VS_OUTPUT_ALBEDO In, float4 vColor ) \r\n"
			"{ \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float fSpec = pow( saturate( dot( normalize(In.m_vHalf.xyz), normalize( In.m_vNor ) ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
			"	fSpec *= vMaskColor.x; \r\n"
			" \r\n"
			"	float fNormalDot = 1.f; \r\n"
			"   fNormalDot += fSpec;								// Add Specular \r\n"
			"   vColor.xyz *= fNormalDot; \r\n"	
			"#endif \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMapMask \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float fCubeMapValue = g_fCubeMapValue; \r\n"
			"	{ \r\n"
			"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"		fCubeMapValue *= vMaskColor.z; \r\n"
			"	} \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMap \r\n"
			"	{ \r\n"
			"		vColor.xyz = vColor.xyz*(1.f-fCubeMapValue) + texCUBE( CubeTexSampler, In.m_vCubeTexcoord ).xyz * fCubeMapValue; \r\n"
			"	} \r\n"
			"#endif \r\n"
			" \r\n"
			" return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_2( VS_OUTPUT_ALBEDO In ) \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.w + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor = CUBE_SPEC_PS_2( In, vColor ); \r\n"
			" \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"   vOut.m_vColor1 = 1.f; \r\n"
			"	vOut.m_vColor1.xyz = In.m_vColor0.xyz * g_fOverLightPower_PS_2_0 / 3; \r\n"
			"   vOut.m_vColor2 = 1.f; \r\n"
			"   vOut.m_vColor2.xyz = In.m_vPosViewSpace; \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.2.0 Albedo INSTANCING \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//				ExportFloatToVector2 \r\n"
			" float2 ExportFloatToVector2( float fValue ) \r\n"	
			" { \r\n"
			"   fValue = fValue * 65535.f; \r\n"
			"   float2 vOut; \r\n"
			"	vOut.x = floor( fValue / 256.f ); \r\n"	// >>8 한다는 개념으로.
			"	vOut.x /= 255.f; \r\n"
			"	vOut.y = frac( fValue / 256.f ); \r\n"	// >>8 가 당해진 값들을 얻는다. 퀄리티 차이랑 속도를 생각해서 /255 를 하지는 말자.
			//"	vOut.y = frac( fValue / 256.f ) / 255.f; \r\n"	// >>8 가 당해진 값들을 얻는다.	/ 255.f 를 하는건 0~1 값을 얻기 위함.
			"	return vOut; \r\n"
			" } \r\n"
			" \r\n"
			"VS_OUTPUT_ALBEDO VS_INSTANCING( VS_INPUT_INSTANCING In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO Out; \r\n"
			" \r\n"
			"	g_matWorld[0].xyzw = float4(In.m_vMatrix1_AC0W.xyz,0.f); \r\n"
			"	g_matWorld[1].xyzw = float4(In.m_vMatrix2_LMOffsetX.xyz,0.f); \r\n"
			"	g_matWorld[2].xyzw = float4(In.m_vMatrix3_LMOffsetY.xyz,0.f); \r\n"
			"	g_matWorld[3].xyzw = In.m_vMatrix4; \r\n"
			" \r\n"
			"	float2 AC_0XY = ExportFloatToVector2( In.m_vVC_AC0XY.w ) * 3.f; \r\n"
			"	float2 AC_0Z_1X = ExportFloatToVector2( In.m_vAmbientCube_0Z_12_3X.x ) * 3.f; \r\n"
			"	float2 AC_1YZ = ExportFloatToVector2( In.m_vAmbientCube_0Z_12_3X.y ) * 3.f; \r\n"
			"	float2 AC_2XY = ExportFloatToVector2( In.m_vAmbientCube_0Z_12_3X.z ) * 3.f; \r\n"
			"	float2 AC_2Z_3X = ExportFloatToVector2( In.m_vAmbientCube_0Z_12_3X.w ) * 3.f; \r\n"
			"	float2 AC_3YZ = ExportFloatToVector2( In.m_vAmbientCube_3YZ_45.x ) * 3.f; \r\n"
			"	float2 AC_4XY = ExportFloatToVector2( In.m_vAmbientCube_3YZ_45.y ) * 3.f; \r\n"
			"	float2 AC_4Z_5X = ExportFloatToVector2( In.m_vAmbientCube_3YZ_45.z ) * 3.f; \r\n"
			"	float2 AC_5YZ = ExportFloatToVector2( In.m_vAmbientCube_3YZ_45.w ) * 3.f; \r\n"
			" \r\n"
			"	g_vAmbientCube[0] = float3( AC_0XY.x, AC_0XY.y, AC_0Z_1X.x ); \r\n"
			"	g_vAmbientCube[1] = float3( AC_0Z_1X.y, AC_1YZ.x, AC_1YZ.y ); \r\n"
			"	g_vAmbientCube[2] = float3( AC_2XY.x, AC_2XY.y, AC_2Z_3X.x ); \r\n"
			"	g_vAmbientCube[3] = float3( AC_2Z_3X.y, AC_3YZ.x, AC_3YZ.y ); \r\n"
			"	g_vAmbientCube[4] = float3( AC_4XY.x, AC_4XY.y, AC_4Z_5X.x ); \r\n"
			"	g_vAmbientCube[5] = float3( AC_4Z_5X.y, AC_5YZ.x, AC_5YZ.y ); \r\n"
			" \r\n"
			"   g_matWV = mul(g_matWorld,g_matView); \r\n"
			"   g_matWVP = mul(g_matWV,g_matProj); \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(In.m_vPosition, g_matWVP); \r\n"
			"	float3 vPos = mul(In.m_vPosition, g_matWorld); \r\n"
			"	Out.m_vPosViewSpace = mul(In.m_vPosition, g_matWV).xyz; \r\n"
			"	Out.m_vPosProjSpace = mul(In.m_vPosition, g_matWVP); \r\n"
			"	float3 vNor = normalize(mul(In.m_vNormal, g_matWorld)); \r\n"
			" \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vEyeToVector = normalize(vPos - g_vCameraFrom); \r\n"
			"	Out.m_vCubeTexcoord = reflect(vEyeToVector, vNor); \r\n"
			"#endif \r\n"
			" \r\n"
			"   Out.m_vColor0 = AmbientLight( vNor ); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 CUBE_SPEC_PS_2_INSTANCING( VS_OUTPUT_ALBEDO In, float4 vColor ) \r\n"
			"{ \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float fSpec = pow( saturate( dot( normalize(In.m_vHalf.xyz), normalize( In.m_vNor ) ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
			"	fSpec *= vMaskColor.x; \r\n"
			" \r\n"
			"	float fNormalDot = 1.f; \r\n"
			"   fNormalDot += fSpec;								// Add Specular \r\n"
			"   vColor.xyz *= fNormalDot; \r\n"	
			"#endif \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMapMask \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float fCubeMapValue = g_fCubeMapValue; \r\n"
			"	{ \r\n"
			"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"		fCubeMapValue *= vMaskColor.z; \r\n"
			"	} \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMap \r\n"
			"	{ \r\n"
			"		vColor.xyz = vColor.xyz*(1.f-fCubeMapValue) + texCUBE( CubeTexSampler, In.m_vCubeTexcoord ).xyz * fCubeMapValue; \r\n"
			"	} \r\n"
			"#endif \r\n"
			" \r\n"
			" return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_INSTANCING( VS_OUTPUT_ALBEDO In ) \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.w + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor = CUBE_SPEC_PS_2_INSTANCING( In, vColor ); \r\n"
			" \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"   vOut.m_vColor1 = 1.f; \r\n"
			"	vOut.m_vColor1.xyz = In.m_vColor0.xyz * g_fOverLightPower_PS_2_0 / 3; \r\n"
			"   vOut.m_vColor2 = 1.f; \r\n"
			"   vOut.m_vColor2.xyz = In.m_vPosViewSpace; \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique runtime_1 \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass high \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_1_1 VS_1(); \r\n"
			"		PixelShader = compile ps_1_1 PS_1(); \r\n"
			"	} \r\n"
			"} \r\n"
			"technique runtime_2 \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_2(); \r\n"
			"		PixelShader = compile ps_3_0 PS_2(); \r\n"
			"	} \r\n"
			"} \r\n"
			"technique runtime_Instancing \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_INSTANCING(); \r\n"
			"		PixelShader = compile ps_3_0 PS_INSTANCING(); \r\n"
			"	} \r\n"
			"} \r\n"
			" \r\n";
	}

	void SetAmbientCubeVertexColorFX( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWorld; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matView; \r\n"
			"float4x4 g_matProj; \r\n"
			"float3   g_vCameraFrom; \r\n"
			"float2   g_vFOG;	// FogEnd, FogDist \r\n"
			"float    g_fSpecularPower = 256.f; \r\n"
			"float    g_fSpecularIntensity = 2.f; \r\n"
			"float    g_fOverLightPower_PS_2_0 = 1.f; \r\n"
			"float4   g_vWindowSize; \r\n"
			"float    g_fAlpha; \r\n"
			"float3	  g_vAmbientCube[6]; \r\n"
			"float	  g_fCubeMapValue; \r\n"
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			" texture g_GlobalCubeTexture; \r\n"
			" samplerCUBE CubeTexSampler = sampler_state  \r\n"
			" { \r\n"
			" 	Texture = (g_GlobalCubeTexture); \r\n"
			" }; \r\n"
			" \r\n"
			"texture g_MaskTexture; \r\n"
			"sampler MaskTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_MaskTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_pTextureLodBlend; \r\n"
			"sampler TextureLodBlendSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_pTextureLodBlend); \r\n"
			"}; \r\n"			
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_INPUT			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float4 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"struct VS_INPUT_INSTANCING			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float4 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			" \r\n"
			"	float4 m_vVC_AC0XY					: TEXCOORD1; \r\n"
			"	float4 m_vMatrix1_AC0W				: TEXCOORD2; \r\n"
			"	float4 m_vMatrix2_LMOffsetX			: TEXCOORD3; \r\n"
			"	float4 m_vMatrix3_LMOffsetY			: TEXCOORD4; \r\n"
			"	float4 m_vMatrix4					: TEXCOORD5; \r\n"
			"	float4 m_vAmbientCube_0Z_12_3X		: TEXCOORD6; \r\n"
			"	float4 m_vAmbientCube_3YZ_45		: TEXCOORD7; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_1		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float  m_fFog       : FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_ALBEDO		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float3 m_vPosViewSpace : TEXCOORD1; \r\n"
			"	float4 m_vPosProjSpace	: TEXCOORD2; \r\n"
			"	float3 m_vColor0    : TEXCOORD3; \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"   float3 m_vCubeTexcoord : TEXCOORD4; \r\n"
			"#endif \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float3 m_vNor			: TEXCOORD5; \r\n"
			"	float3 m_vHalf			: TEXCOORD6; \r\n"
			"#endif \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_2_S \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float3 m_vPosLight	: TEXCOORD1; \r\n"
			"	float3 m_vColor0    : TEXCOORD2; \r\n"
			"   float4 m_vShadowProjectionPos : TEXCOORD3; \r\n"
			"	float  m_fFog       : FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"struct PS_DEFFERED_OUT		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vColor0	: COLOR0; \r\n"
			"	float4 m_vColor1	: COLOR1; \r\n"
			"	float4 m_vColor2	: COLOR2; \r\n"
			"}; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"float3 AmbientLight( const float3 worldNormal) \r\n"
			"{ \r\n"
			"   float3 nSquared= worldNormal* worldNormal; \r\n"
			"   int3 isNegative= ( worldNormal< 0.0 ); \r\n"
			"   float3 linearColor; \r\n"
			"   linearColor= nSquared.x* g_vAmbientCube[isNegative.x] + \r\n"
			"	nSquared.y* g_vAmbientCube[isNegative.y+2] + \r\n"
			"	nSquared.z* g_vAmbientCube[isNegative.z+4]; \r\n"
			"   return linearColor; \r\n"
			"} \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.1.1 \r\n"
			"VS_OUTPUT_1 VS_1( VS_INPUT In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_1 Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			" \r\n"
			"   float3 vNor = normalize( mul(g_matWorld, In.m_vNormal) ); \r\n"
			"   Out.m_vColor0 = In.m_vColor0.xyz; \r\n"
			"   Out.m_vColor0 *= float4(AmbientLight( vNor )*0.25f,1.f); \r\n"		// ps.1.x 버젼에서 3 을 곱할 수가 없어서 0.3333 을 넣지 못하고 0.5를 넣었다. OverLighting 를 위함.
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	Out.m_fFog = saturate((g_vFOG.x - Out.m_vPosition.z) / g_vFOG.y); \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_1( VS_OUTPUT_1 In ) : COLOR0  \r\n"
			"{ \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	vColor.xyz *= In.m_vColor0.xyz * 4.f; \r\n"							// OverLighting 을 위함.
			"	vColor.w *= g_fAlpha; \r\n"
			" \r\n"
			"	return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.2.0 Albedo \r\n"
			"VS_OUTPUT_ALBEDO VS_2( VS_INPUT In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	float3 vPos = mul(g_matWorld, In.m_vPosition); \r\n"
			"	Out.m_vPosViewSpace = mul(g_matWV, In.m_vPosition).xyz; \r\n"
			"	Out.m_vPosProjSpace = mul(g_matWVP, In.m_vPosition); \r\n"
			"	float3 vNor = normalize(mul(g_matWorld, In.m_vNormal)); \r\n"
			" \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vEyeToVector = normalize(vPos - g_vCameraFrom); \r\n"
			"	Out.m_vCubeTexcoord = reflect(vEyeToVector, vNor); \r\n"
			"#endif \r\n"
			" \r\n"
			"   Out.m_vColor0 = In.m_vColor0.xyz; \r\n"
			"   Out.m_vColor0 *= AmbientLight( vNor ); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 CUBE_SPEC_PS_2( VS_OUTPUT_ALBEDO In, float4 vColor ) \r\n"
			"{ \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float fSpec = pow( saturate( dot( normalize(In.m_vHalf.xyz), normalize( In.m_vNor ) ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
			"	fSpec *= vMaskColor.x; \r\n"
			" \r\n"
			"	float fNormalDot = 1.f; \r\n"
			"   fNormalDot += fSpec;								// Add Specular \r\n"
			"   vColor.xyz *= fNormalDot; \r\n"	
			"#endif \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMapMask \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float fCubeMapValue = g_fCubeMapValue; \r\n"
			"	{ \r\n"
			"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"		fCubeMapValue *= vMaskColor.z; \r\n"
			"	} \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMap \r\n"
			"	{ \r\n"
			"		vColor.xyz = vColor.xyz*(1.f-fCubeMapValue) + texCUBE( CubeTexSampler, In.m_vCubeTexcoord ).xyz * fCubeMapValue; \r\n"
			"	} \r\n"
			"#endif \r\n"
			" \r\n"
			" return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_2( VS_OUTPUT_ALBEDO In ) \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.w + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor = CUBE_SPEC_PS_2( In, vColor ); \r\n"
			" \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"   vOut.m_vColor1 = 1.f; \r\n"
			"	vOut.m_vColor1.xyz = In.m_vColor0.xyz * g_fOverLightPower_PS_2_0 / 3; \r\n"
			"   vOut.m_vColor2 = 1.f; \r\n"
			"   vOut.m_vColor2.xyz = In.m_vPosViewSpace; \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					game 렌더용	ps.2.0 Albedo INSTANCING \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//				ExportFloatToVector2 \r\n"
			" float2 ExportFloatToVector2( float fValue ) \r\n"	
			" { \r\n"
			"   fValue = fValue * 65535.f; \r\n"
			"   float2 vOut; \r\n"
			"	vOut.x = floor( fValue / 256.f ); \r\n"	// >>8 한다는 개념으로.
			"	vOut.x /= 255.f; \r\n"
			"	vOut.y = frac( fValue / 256.f ); \r\n"	// >>8 가 당해진 값들을 얻는다. 퀄리티 차이랑 속도를 생각해서 /255 를 하지는 말자.
			//"	vOut.y = frac( fValue / 256.f ) / 255.f; \r\n"	// >>8 가 당해진 값들을 얻는다.	/ 255.f 를 하는건 0~1 값을 얻기 위함.
			"	return vOut; \r\n"
			" } \r\n"
			" \r\n"
			"VS_OUTPUT_ALBEDO VS_INSTANCING( VS_INPUT_INSTANCING In )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_ALBEDO Out; \r\n"
			" \r\n"
			"	g_matWorld[0].xyzw = float4(In.m_vMatrix1_AC0W.xyz,0.f); \r\n"
			"	g_matWorld[1].xyzw = float4(In.m_vMatrix2_LMOffsetX.xyz,0.f); \r\n"
			"	g_matWorld[2].xyzw = float4(In.m_vMatrix3_LMOffsetY.xyz,0.f); \r\n"
			"	g_matWorld[3].xyzw = In.m_vMatrix4; \r\n"
			" \r\n"
			"	float2 AC_0XY = ExportFloatToVector2( In.m_vVC_AC0XY.w ) * 3.f; \r\n"
			"	float2 AC_0Z_1X = ExportFloatToVector2( In.m_vAmbientCube_0Z_12_3X.x ) * 3.f; \r\n"
			"	float2 AC_1YZ = ExportFloatToVector2( In.m_vAmbientCube_0Z_12_3X.y ) * 3.f; \r\n"
			"	float2 AC_2XY = ExportFloatToVector2( In.m_vAmbientCube_0Z_12_3X.z ) * 3.f; \r\n"
			"	float2 AC_2Z_3X = ExportFloatToVector2( In.m_vAmbientCube_0Z_12_3X.w ) * 3.f; \r\n"
			"	float2 AC_3YZ = ExportFloatToVector2( In.m_vAmbientCube_3YZ_45.x ) * 3.f; \r\n"
			"	float2 AC_4XY = ExportFloatToVector2( In.m_vAmbientCube_3YZ_45.y ) * 3.f; \r\n"
			"	float2 AC_4Z_5X = ExportFloatToVector2( In.m_vAmbientCube_3YZ_45.z ) * 3.f; \r\n"
			"	float2 AC_5YZ = ExportFloatToVector2( In.m_vAmbientCube_3YZ_45.w ) * 3.f; \r\n"
			" \r\n"
			"	g_vAmbientCube[0] = float3( AC_0XY.x, AC_0XY.y, AC_0Z_1X.x ); \r\n"
			"	g_vAmbientCube[1] = float3( AC_0Z_1X.y, AC_1YZ.x, AC_1YZ.y ); \r\n"
			"	g_vAmbientCube[2] = float3( AC_2XY.x, AC_2XY.y, AC_2Z_3X.x ); \r\n"
			"	g_vAmbientCube[3] = float3( AC_2Z_3X.y, AC_3YZ.x, AC_3YZ.y ); \r\n"
			"	g_vAmbientCube[4] = float3( AC_4XY.x, AC_4XY.y, AC_4Z_5X.x ); \r\n"
			"	g_vAmbientCube[5] = float3( AC_4Z_5X.y, AC_5YZ.x, AC_5YZ.y ); \r\n"
			" \r\n"
			"   g_matWV = mul(g_matWorld,g_matView); \r\n"
			"   g_matWVP = mul(g_matWV,g_matProj); \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(In.m_vPosition, g_matWVP); \r\n"
			"	float3 vPos = mul(In.m_vPosition, g_matWorld); \r\n"
			"	Out.m_vPosViewSpace = mul(In.m_vPosition, g_matWV).xyz; \r\n"
			"	Out.m_vPosProjSpace = mul(In.m_vPosition, g_matWVP); \r\n"
			"	float3 vNor = normalize(mul(In.m_vNormal, g_matWorld)); \r\n"
			" \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vEyeToVector = normalize(vPos - g_vCameraFrom); \r\n"
			"	Out.m_vCubeTexcoord = reflect(vEyeToVector, vNor); \r\n"
			"#endif \r\n"
			" \r\n"
			"   Out.m_vColor0 = In.m_vColor0.xyz; \r\n"
			"   Out.m_vColor0 *= AmbientLight( vNor ); \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 CUBE_SPEC_PS_2_INSTANCING( VS_OUTPUT_ALBEDO In, float4 vColor ) \r\n"
			"{ \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float fSpec = pow( saturate( dot( normalize(In.m_vHalf.xyz), normalize( In.m_vNor ) ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
			"	fSpec *= vMaskColor.x; \r\n"
			" \r\n"
			"	float fNormalDot = 1.f; \r\n"
			"   fNormalDot += fSpec;								// Add Specular \r\n"
			"   vColor.xyz *= fNormalDot; \r\n"	
			"#endif \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMapMask \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float fCubeMapValue = g_fCubeMapValue; \r\n"
			"	{ \r\n"
			"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"		fCubeMapValue *= vMaskColor.z; \r\n"
			"	} \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMap \r\n"
			"	{ \r\n"
			"		vColor.xyz = vColor.xyz*(1.f-fCubeMapValue) + texCUBE( CubeTexSampler, In.m_vCubeTexcoord ).xyz * fCubeMapValue; \r\n"
			"	} \r\n"
			"#endif \r\n"
			" \r\n"
			" return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"PS_DEFFERED_OUT PS_INSTANCING( VS_OUTPUT_ALBEDO In ) \r\n"
			"{ \r\n"
			"	PS_DEFFERED_OUT vOut; \r\n"
			" \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.w + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor = CUBE_SPEC_PS_2_INSTANCING( In, vColor ); \r\n"
			" \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	vOut.m_vColor0 = vColor; \r\n"
			"   vOut.m_vColor1 = 1.f; \r\n"
			"	vOut.m_vColor1.xyz = In.m_vColor0.xyz * g_fOverLightPower_PS_2_0 / 3; \r\n"
			"   vOut.m_vColor2 = 1.f; \r\n"
			"   vOut.m_vColor2.xyz = In.m_vPosViewSpace; \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique runtime_1 \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass high \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_1_1 VS_1(); \r\n"
			"		PixelShader = compile ps_1_1 PS_1(); \r\n"
			"	} \r\n"
			"} \r\n"
			"technique runtime_2 \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_2(); \r\n"
			"		PixelShader = compile ps_3_0 PS_2(); \r\n"
			"	} \r\n"
			"} \r\n"
			"technique runtime_Instancing \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass albedo \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_3_0 VS_INSTANCING(); \r\n"
			"		PixelShader = compile ps_3_0 PS_INSTANCING(); \r\n"
			"	} \r\n"
			"} \r\n"
			" \r\n";
	}

	void SetDecalFX( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWorld; \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4x4 g_matView; \r\n"
			"float4x4 g_matProj; \r\n"
			"float3   g_vCameraFrom; \r\n"
			"float2   g_vFOG;	// FogEnd, FogDist \r\n"
			"float    g_fSpecularPower = 256.f; \r\n"
			"float    g_fSpecularIntensity = 2.f; \r\n"
			"float    g_fAlpha; \r\n"
			"float2   g_vLightMapUV_Offset; \r\n"
			"float2   g_vLightMapUV_Multiply; \r\n"
			"float3	  g_vVoxelColor; \r\n"
			"float3	  g_vDecalBelndColor; \r\n"
			"float	  g_fCubeMapValue; \r\n"
			"float4   g_vWindowSize; \r\n"
			" \r\n"
			"texture g_BaseTexture; \r\n"
			"sampler BaseTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BaseTexture); \r\n"
			"}; \r\n"
			" \r\n"
			" texture g_GlobalCubeTexture; \r\n"
			" samplerCUBE CubeTexSampler = sampler_state  \r\n"
			" { \r\n"
			" 	Texture = (g_GlobalCubeTexture); \r\n"
			" }; \r\n"
			" \r\n"
			"texture g_MaskTexture; \r\n"
			"sampler MaskTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_MaskTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_pTextureLodBlend; \r\n"
			"sampler TextureLodBlendSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_pTextureLodBlend); \r\n"
			"}; \r\n"			
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"struct VS_INPUT_TOOL		// editer 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float3 m_vNormal    : NORMAL; \r\n"
			"	float4 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_INPUT_DECAL			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			//"#ifdef USE_CUBEMAP \r\n"
			//"   float3 m_vNormal    : NORMAL; \r\n"
			//"#else \r\n"
			//"#ifdef USE_SPECULAR \r\n"
			//"   float3 m_vNormal    : NORMAL; \r\n"
			//"#endif \r\n"
			//"#endif \r\n"
			"   float3 m_vNormal    : NORMAL; \r\n"
			"	float4 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"struct VS_INPUT_INSTANCING			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			//"#ifdef USE_CUBEMAP \r\n"
			//"   float3 m_vNormal    : NORMAL; \r\n"
			//"#else \r\n"
			//"#ifdef USE_SPECULAR \r\n"
			//"   float3 m_vNormal    : NORMAL; \r\n"
			//"#endif \r\n"
			//"#endif \r\n"
			"   float3 m_vNormal    : NORMAL; \r\n"
			"	float4 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			" \r\n"
			"	float4 m_vVC_AC0XY					: TEXCOORD1; \r\n"
			"	float4 m_vMatrix1_AC0W				: TEXCOORD2; \r\n"
			"	float4 m_vMatrix2_LMOffsetX			: TEXCOORD3; \r\n"
			"	float4 m_vMatrix3_LMOffsetY			: TEXCOORD4; \r\n"
			"	float4 m_vMatrix4					: TEXCOORD5; \r\n"
			"	float4 m_vAmbientCube_0Z_12_3X		: TEXCOORD6; \r\n"
			"	float4 m_vAmbientCube_3YZ_45		: TEXCOORD7; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_DECAL		// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition  : POSITION; \r\n"
			"	float4 m_vColor0    : COLOR0; \r\n"
			"	float2 m_vTexCoord0 : TEXCOORD0; \r\n"
			"	float4 m_vPosProjSpace	: TEXCOORD1; \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"   float3 m_vCubeTexcoord	: TEXCOORD2; \r\n"
			"#endif \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float3 m_vNor			: TEXCOORD3; \r\n"
			"	float3 m_vHalf			: TEXCOORD4; \r\n"
			"#endif \r\n"
			"	float  m_fFog       : FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					P	S		game 렌더용 Decal \r\n"
			" \r\n"
			"VS_OUTPUT_DECAL VS_DECAL( VS_INPUT_DECAL In, uniform bool bFogEnable )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_DECAL Out; \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(g_matWVP, In.m_vPosition); \r\n"
			"	float3 vPos = mul(g_matWorld, In.m_vPosition); \r\n"
			"	Out.m_vPosProjSpace = mul(g_matWVP, In.m_vPosition); \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vNor = normalize(mul(g_matWorld, In.m_vNormal)); \r\n"
			"#else \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float3 vNor = normalize(mul(g_matWorld, In.m_vNormal)); \r\n"
			"#endif \r\n"
			"#endif \r\n"
			" \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vEyeToVector = normalize(vPos - g_vCameraFrom); \r\n"
			"	Out.m_vCubeTexcoord = reflect(vEyeToVector, vNor); \r\n"
			"#endif \r\n"
			" \r\n"
			"	// Get Color \r\n"
			"	Out.m_vColor0 = In.m_vColor0; \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	Out.m_fFog = 1.f; \r\n"
			"	if ( bFogEnable ) \r\n"
			"	{ \r\n"
			"		Out.m_fFog = saturate((g_vFOG.x - Out.m_vPosition.z) / g_vFOG.y); \r\n"
			"	} \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 CUBE_SPEC_PS_2( VS_OUTPUT_DECAL In, float4 vColor ) \r\n"
			"{ \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float fSpec = pow( saturate( dot( normalize(In.m_vHalf.xyz), normalize( In.m_vNor ) ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
			"	fSpec *= vMaskColor.x; \r\n"
			" \r\n"
			"	float fNormalDot = 1.f; \r\n"
			"   fNormalDot += fSpec;								// Add Specular \r\n"
			"   vColor.xyz *= fNormalDot; \r\n"	
			"#endif \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMapMask \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float fCubeMapValue = g_fCubeMapValue; \r\n"
			"	{ \r\n"
			"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"		fCubeMapValue *= vMaskColor.z; \r\n"
			"	} \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMap \r\n"
			"	{ \r\n"
			"		vColor.xyz = vColor.xyz*(1.f-fCubeMapValue) + texCUBE( CubeTexSampler, In.m_vCubeTexcoord ).xyz * fCubeMapValue; \r\n"
			"	} \r\n"
			"#endif \r\n"
			" \r\n"
			" return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_DECAL( VS_OUTPUT_DECAL In, uniform bool bBlendColor ) : COLOR0  \r\n"
			"{ \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.w + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor = CUBE_SPEC_PS_2( In, vColor ); \r\n"
			" \r\n"
			"	vColor *= In.m_vColor0; \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	return vColor; \r\n"
			" \r\n"
			"	if ( bBlendColor ) \r\n"
			"	{ \r\n"
			"		vColor.xyz = (vColor.xyz*vColor.w)+(g_vDecalBelndColor*(1.f-vColor.w)); \r\n"
			"	} \r\n"
			" \r\n"
			"	return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					P	S		game 렌더용 Decal INSTANCING \r\n"
			" \r\n"
			"VS_OUTPUT_DECAL VS_INSTANCING( VS_INPUT_INSTANCING In, uniform bool bFogEnable )  \r\n"
			"{ \r\n"
			"	VS_OUTPUT_DECAL Out; \r\n"
			" \r\n"
			"	g_matWorld[0].xyzw = float4(In.m_vMatrix1_AC0W.xyz,0.f); \r\n"
			"	g_matWorld[1].xyzw = float4(In.m_vMatrix2_LMOffsetX.xyz,0.f); \r\n"
			"	g_matWorld[2].xyzw = float4(In.m_vMatrix3_LMOffsetY.xyz,0.f); \r\n"
			"	g_matWorld[3].xyzw = In.m_vMatrix4; \r\n"
			" \r\n"
			"   g_matWV = mul(g_matWorld,g_matView); \r\n"
			"   g_matWVP = mul(g_matWV,g_matProj); \r\n"
			" \r\n"
			"	// Now that we have the calculated weight, add in the final influence \r\n"
			"	Out.m_vPosition = mul(In.m_vPosition, g_matWVP); \r\n"
			"	float3 vPos = mul(In.m_vPosition, g_matWorld); \r\n"
			"	Out.m_vPosProjSpace = mul(In.m_vPosition, g_matWVP); \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vNor = normalize(mul(In.m_vNormal, g_matWorld)); \r\n"
			"#else \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float3 vNor = normalize(mul(In.m_vNormal, g_matWorld)); \r\n"
			"#endif \r\n"
			"#endif \r\n"
			" \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float3 vEyeToVector = normalize(vPos - g_vCameraFrom); \r\n"
			"	Out.m_vCubeTexcoord = reflect(vEyeToVector, vNor); \r\n"
			"#endif \r\n"
			" \r\n"
			"	// Get Color \r\n"
			"	Out.m_vColor0 = In.m_vColor0; \r\n"
			" \r\n"
			"	// Pass the texture coordinate \r\n"
			"	Out.m_vTexCoord0 = In.m_vTexCoord0; \r\n"
			" \r\n"
			"	Out.m_fFog = 1.f; \r\n"
			"	if ( bFogEnable ) \r\n"
			"	{ \r\n"
			"		Out.m_fFog = saturate((g_vFOG.x - Out.m_vPosition.z) / g_vFOG.y); \r\n"
			"	} \r\n"
			" \r\n"
			"	return Out; \r\n"
			"} \r\n"
			" \r\n"
			"float4 CUBE_SPEC_PS_2_INSTANCING( VS_OUTPUT_DECAL In, float4 vColor ) \r\n"
			"{ \r\n"
			"#ifdef USE_SPECULAR \r\n"
			"	float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"	float fSpec = pow( saturate( dot( normalize(In.m_vHalf.xyz), normalize( In.m_vNor ) ) ), g_fSpecularPower) * g_fSpecularIntensity; \r\n"
			"	fSpec *= vMaskColor.x; \r\n"
			" \r\n"
			"	float fNormalDot = 1.f; \r\n"
			"   fNormalDot += fSpec;								// Add Specular \r\n"
			"   vColor.xyz *= fNormalDot; \r\n"	
			"#endif \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMapMask \r\n"
			"#ifdef USE_CUBEMAP \r\n"
			"	float fCubeMapValue = g_fCubeMapValue; \r\n"
			"	{ \r\n"
			"		float4 vMaskColor = tex2D( MaskTexSampler, In.m_vTexCoord0 ); \r\n"
			"		fCubeMapValue *= vMaskColor.z; \r\n"
			"	} \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMap \r\n"
			"	{ \r\n"
			"		vColor.xyz = vColor.xyz*(1.f-fCubeMapValue) + texCUBE( CubeTexSampler, In.m_vCubeTexcoord ).xyz * fCubeMapValue; \r\n"
			"	} \r\n"
			"#endif \r\n"
			" \r\n"
			" return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"float4 PS_INSTANCING( VS_OUTPUT_DECAL In, uniform bool bBlendColor ) : COLOR0  \r\n"
			"{ \r\n"
			"	// Texture \r\n"
			"	float4 vColor = tex2D( BaseTexSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	float2 vProjTex = 0.5 * In.m_vPosProjSpace.xy / In.m_vPosProjSpace.w + float2( 0.5, 0.5 ); \r\n"
			"	vProjTex.y = 1.0f - vProjTex.y; \r\n"
			"	vProjTex.xy += g_vWindowSize.xy; \r\n"
			" \r\n"
			"	float fTextureLodBlend = tex2D( TextureLodBlendSampler, vProjTex ).r; \r\n"
			" \r\n"
			"	vColor = CUBE_SPEC_PS_2_INSTANCING( In, vColor ); \r\n"
			" \r\n"
			"	vColor *= In.m_vColor0; \r\n"
			"	vColor.a *= g_fAlpha; \r\n"
			"	vColor.a = lerp( fTextureLodBlend*vColor.a, vColor.a, g_fAlpha ); \r\n"
			" \r\n"
			"	return vColor; \r\n"
			" \r\n"
			"	if ( bBlendColor ) \r\n"
			"	{ \r\n"
			"		vColor.xyz = (vColor.xyz*vColor.w)+(g_vDecalBelndColor*(1.f-vColor.w)); \r\n"
			"	} \r\n"
			" \r\n"
			"	return vColor; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique runtime_2 \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass high \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_2_0 VS_DECAL(false); \r\n"
			"		PixelShader = compile ps_2_0 PS_DECAL(false); \r\n"
			"	} \r\n"
			"	pass high_decal_multiply \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_2_0 VS_DECAL(false); \r\n"
			"		PixelShader = compile ps_2_0 PS_DECAL(false); \r\n"
			"	} \r\n"
			"	pass none \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_2_0 VS_DECAL(true); \r\n"
			"		PixelShader = compile ps_2_0 PS_DECAL(true); \r\n"
			"	} \r\n"
			"	pass pass2_decal_add \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_2_0 VS_DECAL(true); \r\n"
			"		PixelShader = compile ps_2_0 PS_DECAL(true); \r\n"
			"	} \r\n"
			"} \r\n"
			"technique runtime_Instancing \r\n"
			"{ \r\n"
			"	//------------------------------------------------------------------------------------- \r\n"
			"	// LightMap \r\n"
			"	pass high \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_2_0 VS_INSTANCING(false); \r\n"
			"		PixelShader = compile ps_2_0 PS_INSTANCING(false); \r\n"
			"	} \r\n"
			"	pass high_decal_multiply \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_2_0 VS_INSTANCING(false); \r\n"
			"		PixelShader = compile ps_2_0 PS_INSTANCING(false); \r\n"
			"	} \r\n"
			"	pass pass2_decal_add \r\n"
			"	{ \r\n"
			"		VertexShader = compile vs_2_0 VS_INSTANCING(true); \r\n"
			"		PixelShader = compile ps_2_0 PS_INSTANCING(true); \r\n"
			"	} \r\n"
			"} \r\n"
			" \r\n";
	}
};