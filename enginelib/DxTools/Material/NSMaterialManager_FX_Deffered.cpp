#include "pch.h"

#include "NSMaterialManager.h"

// ----------------------------------------------------------------------------
#include "../../SigmaCore/DebugInclude.h"
// ----------------------------------------------------------------------------

namespace NSMaterialManager
{
	void SetDefaultMaterial_Deffered( std::string& strFX )
	{
		strFX = 
			"//-------------------------------------------------------------------------------------- \r\n"
			"//       shhan \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Global variables \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"float4x4 g_matWV; \r\n"
			"float4x4 g_matWVP; \r\n"
			"float4x4 g_matLightObjectWV; \r\n"
			"float4x4 g_matLightObjectWVP; \r\n"
			"float4x4 g_matInverseView; \r\n"
			"float4x4 g_matInverseProj; \r\n"
			"float4x4 g_matInvView_Shadow_Clip2Tex; \r\n"
			"float4x4 g_matInvView_Shadow_2nd_Clip2Tex; \r\n"
			//"float4x4 g_matInvView_Shadow_PL1_Clip2Tex; \r\n"
			//"float4x4 g_matInvView_Shadow_PL2_Clip2Tex; \r\n"
			"float4   g_vLightDiffuse; \r\n"
			"float3   g_vLightDirViewSpace; \r\n"
			"float3   g_vLightPosViewSpace; \r\n"
			"float3   g_vLightPosWorldSpace; \r\n"
			"float2   g_vFOG;		// FogEnd, FogDist \r\n"
			"float3   g_vFogColor; \r\n"
			"float    g_fSpecularPower = 256.f; \r\n"
			"float    g_fSpecularIntensity = 2.f; \r\n"
			"float4   g_vWindowSize; \r\n"
			"float    g_fAlpha; \r\n"
			"float2   g_vLightMapUV_Offset; \r\n"
			"float2   g_vLightMapUV_Multiply; \r\n"
			"float3	  g_vVoxelColor; \r\n"
			"float	  g_fCubeMapValue; \r\n"
			"float	  g_fDecalNormal = 1.f; \r\n"
			"float4   g_vShadow; \r\n"	// 기본 Deffered 일 경우		x-SIZE, y-EPSILON, z-1/SIZE w-COLOR
										// PS_LSPASS 에서 쓰일 경우 NM - x(Size), y(Offset), z(1/Size)
										//							CSM - x(Size), y(Offset), z(1/Size), w(1/CSM2Size)
			" \r\n"
			"texture g_BackBufferTexture; \r\n"
			"sampler BackBufferSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BackBufferTexture); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_BackBufferTexture_2nd; \r\n"
			"sampler BackBufferSampler_2nd = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BackBufferTexture_2nd); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_BackBufferTexture_3rd; \r\n"
			"sampler BackBufferSampler_3rd = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BackBufferTexture_3rd); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_BackBufferTexture_4th; \r\n"
			"sampler BackBufferSampler_4th = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BackBufferTexture_4th); \r\n"
			"	MinFilter = Point; \r\n"
			"	MagFilter = Point; \r\n"
			"	MipFilter = Point; \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_BackBufferTexture_LBuffer; \r\n"
			"sampler BackBufferSampler_LBuffer = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_BackBufferTexture_LBuffer); \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_DepthBuffer; \r\n"
			"sampler DepthBufferSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_DepthBuffer); \r\n"
			"}; \r\n"			
			" \r\n"
			" texture g_GlobalCubeTexture; \r\n"
			" samplerCUBE CubeTexSampler = sampler_state  \r\n"
			" { \r\n"
			" 	Texture = (g_GlobalCubeTexture); \r\n"
			" }; \r\n"
			" \r\n"
			"texture g_ShadowTexture; \r\n"
			"sampler ShadowTexSampler = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_ShadowTexture); \r\n"
			" \r\n"
			"	MinFilter = Point; \r\n"
			"	MagFilter = Point; \r\n"
			"	AddressU = Clamp; \r\n"
			"	AddressV = Clamp; \r\n"
			"}; \r\n"
			" \r\n"
			"texture g_ShadowTexture_CSM; \r\n"
			"sampler ShadowTexSampler_CSM = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_ShadowTexture_CSM); \r\n"
			" \r\n"
			"	MinFilter = Point; \r\n"
			"	MagFilter = Point; \r\n"
			"	AddressU = Clamp; \r\n"
			"	AddressV = Clamp; \r\n"
			"}; \r\n"

			"texture g_ShadowTexture_CSM_2; \r\n"
			"sampler ShadowTexSampler_CSM_2 = sampler_state  \r\n"
			"{ \r\n"
			"	Texture = (g_ShadowTexture_CSM_2); \r\n"
			"}; \r\n"
			" \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"// Basic vertex transformation \r\n"
			"//-------------------------------------------------------------------------------------- \r\n"
			"struct VS_INPUT_TOOL	\r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float4 m_vColor0		: COLOR0; \r\n"
			"	float3 m_vNormal		: NORMAL; \r\n"
			"	float3 m_vBinormal		: BINORMAL; \r\n"
			"	float3 m_vTangent		: TANGENT; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"} Vertex_tool : SEMANTIC_VS_INPUT_TOOL; \r\n"
			" \r\n"
			"struct VS_OUTPUT_GPASS	\r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float4 m_vColor0		: COLOR0; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"	float3 m_vNormal		: TEXCOORD1; \r\n"
			"	float3 m_vBinormal		: TEXCOORD2; \r\n"
			"	float3 m_vTangent		: TEXCOORD3; \r\n"
			"	float3 m_vPosViewSpace	: TEXCOORD4; \r\n"
			"	float4 m_vPosProjSpace	: TEXCOORD5; \r\n"
			"}; \r\n"
			" \r\n"
			"struct PS_DEFFERED_OUT	\r\n"
			"{ \r\n"
			"	float4 m_vColor0		: COLOR0; \r\n"	// Albedo
			"	float4 m_vColor1		: COLOR1; \r\n"	// Normal
			"	float4 m_vColor2		: COLOR2; \r\n"	// Specular(Intensity,Power), CubeMap
			//"	float4 m_vColor3		: COLOR3; \r\n"	// Position
			"}; \r\n"
			"struct VS_OUTPUT_QUAD	\r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_INPUT_LPASS	\r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_LPASS	\r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float3 m_vPosProjSpace	: TEXCOORD0; \r\n"	// Albedo 좌표를 얻기 위함.
			//"	float3 m_vDirViewSpace	: TEXCOORD1; \r\n"	// 위치값을 얻기위한 방향벡터
			"}; \r\n"
			" \r\n"
			"struct VS_OUTPUT_MPASS	\r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float2 m_vTexCoord0     : TEXCOORD0; \r\n"	// Texture Alpha(xy) 값을 위함.
			"	float3 m_vPosLight		: TEXCOORD1; \r\n"	// Albedo 좌표를 얻기 위함.
			"	float  m_fFog			: FOG; \r\n"
			"}; \r\n"
			" \r\n"
			"struct VS_INPUT			// game 렌더용 \r\n"
			"{ \r\n"
			"	float4 m_vPosition		: POSITION; \r\n"
			"	float2 m_vTexCoord0		: TEXCOORD0; \r\n"
			"	float2 m_vLightmapUV	: TEXCOORD1;	// LightMap를 사용할 경우, m_vLightmapUV 이름을 유지해주세요. \r\n"
			"	// m_vLightmapUV 이름이 있으면, LightMap을 생성해준다. \r\n"
			"} Vertex : SEMANTIC_VS_INPUT; \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					N o r m a l \r\n"
			"float3 GetNormal( VS_OUTPUT_GPASS In, float4 vMaskColor ) \r\n"
			"{ \r\n"
			"    // If using a signed texture, we must unbias the normal map data \r\n"
			"    float3 Normal; \r\n"
			"    Normal.xy = (vMaskColor.wy * 2) - 1; \r\n"
			"	 Normal.z = sqrt( 1.f - dot( Normal.xy, Normal.xy ) ); \r\n"
			"    \r\n"
			"    // Move the normal from tangent space to world space \r\n"
			"    float3x3 mTangentFrame = { In.m_vTangent, In.m_vBinormal, In.m_vNormal }; \r\n"
			"    Normal = mul( Normal, mTangentFrame ); \r\n"
			"    Normal = normalize( Normal ); \r\n"
			" \r\n"
			"    return Normal;  \r\n"
			"}  \r\n"
			" \r\n"
			"float2 CascadeShadow( float4 vShadowProjectionPos, sampler __ShadowTexSampler, float fTexSize, float fTexelOffset )  \r\n"
			"{ \r\n"
			"   //------------------------------------------ ShadowMap \r\n"
			"   //transform from RT space to texture space. \r\n"
			"	float2 ShadowTexC = vShadowProjectionPos.xy / vShadowProjectionPos.w;  \r\n"
			//"   float2 ShadowTexC = 0.5 * vShadowProjectionPos.xy / vShadowProjectionPos.w + float2( 0.5, 0.5 ); \r\n"
			//"   ShadowTexC.y = 1.0f - ShadowTexC.y; \r\n"
			" \r\n"
			"   // transform to texel space \r\n"
			"   float2 texelpos = fTexSize * ShadowTexC; \r\n"
			" \r\n"
			"   // Determine the lerp amounts      \r\n"      
			"   float2 lerps = frac( texelpos ); \r\n"
			" \r\n"
			"   //read in bilerp stamp, doing the shadow checks \r\n"
			"   float sourcevals[4]; \r\n"
			"   float fShadowProjZdivW = vShadowProjectionPos.z / vShadowProjectionPos.w; \r\n"
			"   sourcevals[0] = (tex2D( __ShadowTexSampler, ShadowTexC ) + g_vShadow.y < fShadowProjZdivW)? 0.f: 1.0f; \r\n"
			"   sourcevals[1] = (tex2D( __ShadowTexSampler, ShadowTexC + float2(fTexelOffset, 0) ) + g_vShadow.y < fShadowProjZdivW)? 0.f: 1.0f; \r\n"
			"   sourcevals[2] = (tex2D( __ShadowTexSampler, ShadowTexC + float2(0, fTexelOffset) ) + g_vShadow.y < fShadowProjZdivW)? 0.f: 1.0f; \r\n"
			"   sourcevals[3] = (tex2D( __ShadowTexSampler, ShadowTexC + float2(fTexelOffset, fTexelOffset) ) + g_vShadow.y < fShadowProjZdivW)? 0.f: 1.0f; \r\n"
			" \r\n"
			"   // lerp between the shadow values to calculate our light amount \r\n"
			"   float2 vLightAmount; \r\n"
			"   vLightAmount.x = lerp( lerp( sourcevals[0], sourcevals[1], lerps.x ), \r\n"
			" 							lerp( sourcevals[2], sourcevals[3], lerps.x ), \r\n"
			" 							lerps.y ); \r\n"
			" \r\n"
			"   // 끝부분이 어색한게 있어서 부드럽게 처리함. \r\n"
			"   float2 vLowUV = 1.f - saturate( ShadowTexC.xy * 5.f );		// UV 범위 0 ~ 0.2 ~ 1 -> 알파수치 1 ~ 0 ~ 0 로 변환 \r\n"
			"   float2 vHighUV = 1.f - saturate( (1.f-ShadowTexC.xy) * 5.f );	// UV 범위 0 ~ 0.8 ~ 1 -> 알파수치 0 ~ 0 ~ 1 로 변환 \r\n"
			"   vLightAmount.y = vLowUV.x + vLowUV.y + vHighUV.x + vHighUV.y; \r\n"
			"   vLightAmount.y = saturate(vLightAmount.y); \r\n"
			" \r\n"
			"   return vLightAmount; \r\n"
			"} \r\n"
			" \r\n"

			"float2 CascadeShadow_Length( float4 vShadowProjectionPos, sampler __ShadowTexSampler, float distToLight, float fTexSize, float fTexelOffset )  \r\n"
			"{ \r\n"
			"   //------------------------------------------ ShadowMap \r\n"
			"   //transform from RT space to texture space. \r\n"
			"	float2 ShadowTexC = vShadowProjectionPos.xy / vShadowProjectionPos.w;  \r\n"
			//"   float2 ShadowTexC = 0.5 * vShadowProjectionPos.xy / vShadowProjectionPos.w + float2( 0.5, 0.5 ); \r\n"
			//"   ShadowTexC.y = 1.0f - ShadowTexC.y; \r\n"
			" \r\n"
			"   // transform to texel space \r\n"
			"   float2 texelpos = fTexSize * ShadowTexC; \r\n"
			" \r\n"
			"   // Determine the lerp amounts      \r\n"      
			"   float2 lerps = frac( texelpos ); \r\n"
			" \r\n"
			"   //read in bilerp stamp, doing the shadow checks \r\n"
			"   float sourcevals[4]; \r\n"
			"   float fShadowProjZdivW = distToLight; \r\n"
			"   sourcevals[0] = (tex2D( __ShadowTexSampler, ShadowTexC ) + g_vShadow.y < fShadowProjZdivW)? 0.f: 1.0f; \r\n"
			"   sourcevals[1] = (tex2D( __ShadowTexSampler, ShadowTexC + float2(fTexelOffset, 0) ) + g_vShadow.y < fShadowProjZdivW)? 0.f: 1.0f; \r\n"
			"   sourcevals[2] = (tex2D( __ShadowTexSampler, ShadowTexC + float2(0, fTexelOffset) ) + g_vShadow.y < fShadowProjZdivW)? 0.f: 1.0f; \r\n"
			"   sourcevals[3] = (tex2D( __ShadowTexSampler, ShadowTexC + float2(fTexelOffset, fTexelOffset) ) + g_vShadow.y < fShadowProjZdivW)? 0.f: 1.0f; \r\n"
			" \r\n"
			"   // lerp between the shadow values to calculate our light amount \r\n"
			"   float2 vLightAmount; \r\n"
			"   vLightAmount.x = lerp( lerp( sourcevals[0], sourcevals[1], lerps.x ), \r\n"
			" 							lerp( sourcevals[2], sourcevals[3], lerps.x ), \r\n"
			" 							lerps.y ); \r\n"
			" \r\n"
			"   // 끝부분이 어색한게 있어서 부드럽게 처리함. \r\n"
			"   float2 vLowUV = 1.f - saturate( ShadowTexC.xy * 5.f );		// UV 범위 0 ~ 0.2 ~ 1 -> 알파수치 1 ~ 0 ~ 0 로 변환 \r\n"
			"   float2 vHighUV = 1.f - saturate( (1.f-ShadowTexC.xy) * 5.f );	// UV 범위 0 ~ 0.8 ~ 1 -> 알파수치 0 ~ 0 ~ 1 로 변환 \r\n"
			"   vLightAmount.y = vLowUV.x + vLowUV.y + vHighUV.x + vHighUV.y; \r\n"
			"   vLightAmount.y = saturate(vLightAmount.y); \r\n"
			" \r\n"
			"   return vLightAmount; \r\n"
			"} \r\n"
			" \r\n"

			"float2 btex2D_rg(sampler2D shadowMap, float2 uv, float radius, float2 offset)   \r\n"
			"{  \r\n"
				// simple 3x3 filter
			"	float2 o = offset;  \r\n"
			"	float2 c = tex2D(shadowMap, uv.xy).rg ; \r\n" // center
			"	c += tex2D(shadowMap, uv.xy - o.xy).rg; \r\n"  // top left
			"	c += tex2D(shadowMap, uv.xy + o.xy).rg; \r\n"  // bottom right
			"	c += tex2D(shadowMap, float2(uv.x - o.x, uv.y)).rg; \r\n"  // left
			"	c += tex2D(shadowMap, float2(uv.x + o.x, uv.y)).rg; \r\n"  // right
			"	c += tex2D(shadowMap, float2(uv.x, uv.y + o.y)).rg; \r\n"  // bottom
			"	c += tex2D(shadowMap, float2(uv.x, uv.y - o.y)).rg; \r\n"  // top
			"	c += tex2D(shadowMap, float2(uv.x - o.x, uv.y + o.y)).rg; \r\n"  // bottom left
			"	c += tex2D(shadowMap, float2(uv.x + o.x, uv.y - o.y)).rg; \r\n"  // top right
			"	return c / 9;  \r\n"
			"}  \r\n"

			"float linstep(float min, float max, float v)   \r\n"
			"{   \r\n"
			"	return clamp((v - min) / (max - min), 0, 1);   \r\n"
			"}   \r\n"

			"float ReduceLightBleeding(float p_max, float Amount)   \r\n"
			"{   \r\n"
				// Remove the [0, Amount] tail and linearly rescale (Amount, 1]. 
			"	return linstep(Amount, 1, p_max);  \r\n" 
			"}   \r\n"

			//"#define MIN_VARIANCE 0.101  \r\n"
			"#define MIN_VARIANCE 1.0  \r\n"

			// @param t In this context its the distance to light.
			"float ChebyshevUpperBound(float2 moments, float t)  \r\n"
			"{  \r\n"
				// one tail ineqality valid if t > moments.x
			"	float p = (t <= moments.x);  \r\n"

			// 
			//"	float pSS = (t <= (moments.x+MIN_VARIANCE));  \r\n"

				// compute variance 
			"	float variance = moments.y - (moments.x*moments.x);  \r\n"
			"	variance = max(variance, MIN_VARIANCE);  \r\n"

				// compute probabilistic upper bound
			"	float d = t - moments.x;  \r\n"
			"	float p_max = variance / (variance + d*d);  \r\n"

			"	return max(p, p_max);  \r\n"
			"}  \r\n"

			// @param lightTexCoord The uv to sample in the shadowMap
			// @param radius The radius to blur
			// @param offset The inverse shadow map size -> how much to move when bluring
			//float ShadowContribution(sampler2D shadowMap, float2 lightTexCoord, float distToLight, float radius, float2 offset) 
			"float2 ShadowContribution(sampler __ShadowTexSampler, float4 vShadowProjectionPos, float distToLight, float fOffset)  \r\n"
			"{  \r\n"
				//------------------------------------------ ShadowMap 
				//transform from RT space to texture space. 
			"	float2 ShadowTexC = vShadowProjectionPos.xy / vShadowProjectionPos.w;  \r\n"
			//"	float2 ShadowTexC = 0.5 * vShadowProjectionPos.xy / vShadowProjectionPos.w + float2( 0.5, 0.5 );  \r\n"
			//"	ShadowTexC.y = 1.0f - ShadowTexC.y;  \r\n"

				// read the moments from the variance shadow map
			"	float2 moments = btex2D_rg( __ShadowTexSampler, ShadowTexC, 2.f, float2(fOffset,fOffset) );  \r\n"
			//"	float2 moments = tex2D(__ShadowTexSampler, ShadowTexC).rg;  \r\n"

				// compute the Chebyshev upper bound
			"	float p_max = ChebyshevUpperBound(moments, distToLight);  \r\n"
			
			"   // lerp between the shadow values to calculate our light amount \r\n"
			"   float2 vLightAmount; \r\n"
			"   vLightAmount.x = ReduceLightBleeding(p_max, 0.0f); \r\n"

			"   // 끝부분이 어색한게 있어서 부드럽게 처리함. \r\n"
			"   float2 vLowUV = 1.f - saturate( ShadowTexC.xy * 5.f );		// UV 범위 0 ~ 0.2 ~ 1 -> 알파수치 1 ~ 0 ~ 0 로 변환 \r\n"
			"   float2 vHighUV = 1.f - saturate( (1.f-ShadowTexC.xy) * 5.f );	// UV 범위 0 ~ 0.8 ~ 1 -> 알파수치 0 ~ 0 ~ 1 로 변환 \r\n"
			"   vLightAmount.y = vLowUV.x + vLowUV.y + vHighUV.x + vHighUV.y; \r\n"
			"   vLightAmount.y = saturate(vLightAmount.y); \r\n"

			"   return vLightAmount; \r\n"

			"}  \r\n"


			//////////////////////////////////////////////////////////////////////////
			// PCF - Percentage-Closer Filtering
			"float2 Poisson4[] = { \r\n"
			"	{-0.5, -0.5}, \r\n"
			"	{-0.5, 0.5}, \r\n"
			"	{0.5, -0.5}, \r\n"
			"	{0.5, 0.5}, \r\n"
			"}; \r\n"	// 망함

			"float2 Poisson9[] = { \r\n"
			"	{-0.66666,	-0.66666}, \r\n"
			"	{-0.66666,	0.0}, \r\n"
			"	{-0.66666,	0.66666}, \r\n"
			"	{-0.0,		-0.66666}, \r\n"
			"	{-0.0,		0.0}, \r\n"
			"	{-0.0,		0.66666}, \r\n"
			"	{0.66666,	-0.66666}, \r\n"
			"	{0.66666,	0.0}, \r\n"
			"	{0.66666,	0.66666}, \r\n"
			"}; \r\n"	// 망함

			//"float2 Poisson16[] = { \r\n"
			////"	{-0.978698, -0.0884121}, \r\n"
			////"	{-0.841121, 0.521165}, \r\n"
			//"	{-0.71746, -0.50322}, \r\n"
			////"	{-0.702933, 0.903134}, \r\n"
			//"	{-0.663198, 0.15482}, \r\n"
			//"	{-0.495102, -0.232887}, \r\n"
			////"	{-0.364238, -0.961791}, \r\n"
			//"	{-0.345866, -0.564379}, \r\n"
			//"	{-0.325663, 0.64037}, \r\n"
			//"	{-0.182714, 0.321329}, \r\n"
			//"	{-0.142613, -0.0227363}, \r\n"
			//"	{-0.0564287, -0.36729}, \r\n"
			////"	{-0.0185858, 0.918882}, \r\n"
			//"	{0.0381787, -0.728996}, \r\n"
			//"	{0.16599, 0.093112}, \r\n"
			//"	{0.253639, 0.719535}, \r\n"
			////"	{0.369549, -0.655019}, \r\n"
			//"	{0.423627, 0.429975}, \r\n"
			//"	{0.530747, -0.364971}, \r\n"
			////"	{0.566027, -0.940489}, \r\n"
			//"	{0.639332, 0.0284127}, \r\n"
			//"	{0.652089, 0.669668}, \r\n"
			//"	{0.773797, 0.345012}, \r\n"
			////"	{0.968871, 0.840449}, \r\n"
			////"	{0.991882, -0.657338}, \r\n"
			//"}; \r\n"
			"float2 Poisson16[] = { \r\n"
			//"	{-0.978698, -0.0884121}, \r\n"
			//"	{-0.841121, 0.521165}, \r\n"
			"	{-0.71746*2, -0.50322*2}, \r\n"
			//"	{-0.702933, 0.903134}, \r\n"
			"	{-0.663198*2, 0.15482*2}, \r\n"
			"	{-0.495102*2, -0.232887*2}, \r\n"
			//"	{-0.364238, -0.961791}, \r\n"
			"	{-0.345866*2, -0.564379*2}, \r\n"
			"	{-0.325663*2, 0.64037*2}, \r\n"
			"	{-0.182714*2, 0.321329*2}, \r\n"
			"	{-0.142613*2, -0.0227363*2}, \r\n"
			"	{-0.0564287*2, -0.36729*2}, \r\n"
			//"	{-0.0185858, 0.918882}, \r\n"
			"	{0.0381787*2, -0.728996*2}, \r\n"
			"	{0.16599*2, 0.093112*2}, \r\n"
			"	{0.253639*2, 0.719535*2}, \r\n"
			//"	{0.369549, -0.655019}, \r\n"
			"	{0.423627*2, 0.429975*2}, \r\n"
			"	{0.530747*2, -0.364971*2}, \r\n"
			//"	{0.566027, -0.940489}, \r\n"
			"	{0.639332*2, 0.0284127*2}, \r\n"
			"	{0.652089*2, 0.669668*2}, \r\n"
			"	{0.773797*2, 0.345012*2}, \r\n"
			//"	{0.968871, 0.840449}, \r\n"
			//"	{0.991882, -0.657338}, \r\n"
			"}; \r\n"

			"float2 Poisson25[] = { \r\n"
			"	{-0.978698, -0.0884121}, \r\n"
			"	{-0.841121, 0.521165}, \r\n"
			"	{-0.71746, -0.50322}, \r\n"
			"	{-0.702933, 0.903134}, \r\n"
			"	{-0.663198, 0.15482}, \r\n"
			"	{-0.495102, -0.232887}, \r\n"
			"	{-0.364238, -0.961791}, \r\n"
			"	{-0.345866, -0.564379}, \r\n"
			"	{-0.325663, 0.64037}, \r\n"
			"	{-0.182714, 0.321329}, \r\n"
			"	{-0.142613, -0.0227363}, \r\n"
			"	{-0.0564287, -0.36729}, \r\n"
			"	{-0.0185858, 0.918882}, \r\n"
			"	{0.0381787, -0.728996}, \r\n"
			"	{0.16599, 0.093112}, \r\n"
			"	{0.253639, 0.719535}, \r\n"
			"	{0.369549, -0.655019}, \r\n"
			"	{0.423627, 0.429975}, \r\n"
			"	{0.530747, -0.364971}, \r\n"
			"	{0.566027, -0.940489}, \r\n"
			"	{0.639332, 0.0284127}, \r\n"
			"	{0.652089, 0.669668}, \r\n"
			"	{0.773797, 0.345012}, \r\n"
			"	{0.968871, 0.840449}, \r\n"
			"	{0.991882, -0.657338}, \r\n"
			"}; \r\n"

			"float2 Poisson32[] = { \r\n"
			"	{-0.975402, -0.0711386}, \r\n"
			"	{-0.920347, -0.41142}, \r\n"
			"	{-0.883908, 0.217872}, \r\n"
			"	{-0.884518, 0.568041}, \r\n"
			"	{-0.811945, 0.90521}, \r\n"
			"	{-0.792474, -0.779962}, \r\n"
			"	{-0.614856, 0.386578}, \r\n"
			"	{-0.580859, -0.208777}, \r\n"
			"	{-0.53795, 0.716666}, \r\n"
			"	{-0.515427, 0.0899991}, \r\n"
			"	{-0.454634, -0.707938}, \r\n"
			"	{-0.420942, 0.991272}, \r\n"
			"	{-0.261147, 0.588488}, \r\n"
			"	{-0.211219, 0.114841}, \r\n"
			"	{-0.146336, -0.259194}, \r\n"
			"	{-0.139439, -0.888668}, \r\n"
			"	{0.0116886, 0.326395}, \r\n"
			"	{0.0380566, 0.625477}, \r\n"
			"	{0.0625935, -0.50853}, \r\n"
			"	{0.125584, 0.0469069}, \r\n"
			"	{0.169469, -0.997253}, \r\n"
			"	{0.320597, 0.291055}, \r\n"
			"	{0.359172, -0.633717}, \r\n"
			"	{0.435713, -0.250832}, \r\n"
			"	{0.507797, -0.916562}, \r\n"
			"	{0.545763, 0.730216}, \r\n"
			"	{0.56859, 0.11655}, \r\n"
			"	{0.743156, -0.505173}, \r\n"
			"	{0.736442, -0.189734}, \r\n"
			"	{0.843562, 0.357036}, \r\n"
			"	{0.865413, 0.763726}, \r\n"
			"	{0.872005, -0.927}, \r\n"
			"}; \r\n"

			"#define PCF_POISSON_COUNT 16 \r\n"
			"#define PCF_POISSON Poisson16 \r\n"

			// Performs PCF filtering on the shadow map using multiple taps in the filter region.
			"float2 PCF_SoftShadow( sampler __ShadowTexSampler, float4 vShadowProjectionPos, float distToLight, float fTexelOffset ) \r\n"
			"{ \r\n"
			"   //------------------------------------------ ShadowMap \r\n"
			"   //transform from RT space to texture space. \r\n"
			"	float2 ShadowTexC = vShadowProjectionPos.xy / vShadowProjectionPos.w;  \r\n"

			"   float2 vLightAmount = 0; \r\n"

			//"   float fShadowProjZdivW = distToLight; \r\n"
			"   float fShadowProjZdivW = vShadowProjectionPos.z / vShadowProjectionPos.w; \r\n"
			"	for ( int i = 0; i < PCF_POISSON_COUNT; ++i ) \r\n"
			"	{ \r\n"
			"		float2 offset = PCF_POISSON[i] * fTexelOffset; \r\n"
			"		vLightAmount.x += (tex2D( __ShadowTexSampler, ShadowTexC + offset ) + g_vShadow.y < fShadowProjZdivW)? 0.f: 1.0f; \r\n"
			"	} \r\n"
			"	vLightAmount.x /= PCF_POISSON_COUNT; \r\n"

			"   // 끝부분이 어색한게 있어서 부드럽게 처리함. \r\n"
			"   float2 vLowUV = 1.f - saturate( ShadowTexC.xy * 5.f );		// UV 범위 0 ~ 0.2 ~ 1 -> 알파수치 1 ~ 0 ~ 0 로 변환 \r\n"
			"   float2 vHighUV = 1.f - saturate( (1.f-ShadowTexC.xy) * 5.f );	// UV 범위 0 ~ 0.8 ~ 1 -> 알파수치 0 ~ 0 ~ 1 로 변환 \r\n"
			"   vLightAmount.y = vLowUV.x + vLowUV.y + vHighUV.x + vHighUV.y; \r\n"
			"   vLightAmount.y = saturate(vLightAmount.y); \r\n"

			"   return vLightAmount; \r\n"
			"} \r\n"


			//"float VSM_FILTER( float4 vShadowProjectionPos, sampler __ShadowTexSampler, float fragDepth )  \r\n"
			//"{  \r\n"
			//	//------------------------------------------ ShadowMap 
			//	//transform from RT space to texture space. 
			//"	float2 ShadowTexC = 0.5 * vShadowProjectionPos.xy / vShadowProjectionPos.w + float2( 0.5, 0.5 );  \r\n"
			//"	ShadowTexC.y = 1.0f - ShadowTexC.y;  \r\n"

			//"	float lit = (float)0.0f;  \r\n"
			//"	float2 moments = tex2D( __ShadowTexSampler, ShadowTexC );  \r\n"

			//"	float E_x2 = moments.y;  \r\n"
			//"	float Ex_2 = moments.x * moments.x;  \r\n"
			//"	float variance = E_x2 - Ex_2;     \r\n" 
			//"	float mD = (moments.x - fragDepth );  \r\n"
			//"	float mD_2 = mD * mD;  \r\n"
			//"	float p = variance / (variance + mD_2 );  \r\n"
			//"	lit = max( p, fragDepth <= moments.x );  \r\n"

			//"	return lit;  \r\n"
			//"}  \r\n"

			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//				TOOL		L-Pass Sun 			// SoftAlpha 텍스쳐들은 들어오지 못한다.	\r\n"
			"float4 PS_LSPASS( VS_OUTPUT_QUAD In, uniform int nShadowMode ) : COLOR0  \r\n"
			"{ \r\n"
			"	float4 vOut = 1.f; \r\n"
			" \r\n"
			"	// Normal Vector 얻기. \r\n"
			"	float3 vNor = tex2D( BackBufferSampler_2nd, In.m_vTexCoord0 ); \r\n"
			"	vNor = normalize( vNor ); \r\n"
			" \r\n"
			"	// Specular, CubeMap Factor 얻기. \r\n"
			"	float3 vSpecularCubemap = tex2D( BackBufferSampler_3rd, In.m_vTexCoord0 ).xyz; \r\n"
			"	vSpecularCubemap.x *= 2.f; \r\n"
			"	vSpecularCubemap.y *= 256.f; \r\n"
			" \r\n"
			"	// Shadow 얻기. \r\n"
			"	float fShadow = tex2D( BackBufferSampler_4th, In.m_vTexCoord0 ).w; \r\n"
			" \r\n"
			"	// Get the depth buffer value at this pixel. \r\n"
			"	float zOverW = tex2D( DepthBufferSampler, In.m_vTexCoord0 ).x; \r\n"
			"	// H is the viewport position at this pixel in the range -1 to 1. \r\n"
			"	float4 H = float4(In.m_vTexCoord0.x * 2 - 1, (1 - In.m_vTexCoord0.y) * 2 - 1, zOverW, 1); \r\n"
			"	// Transform by the view-projection inverse. \r\n"
			"	float4 D = mul(g_matInverseProj, H); \r\n"
			"	// Divide by w to get the world position. \r\n"
			"	float4 vPositionViewSpace = D / D.w; \r\n"
			"	vPositionViewSpace.w = 1.f; \r\n"
			" \r\n"
			"	float3	vAddColor = 0.f; \r\n"
			" \r\n"
			//"   if ( fShadow > 0.f ) \r\n"	// 조건문
			"	{ \r\n"
			"		float fNormalDot = 1.f; \r\n"
			"		if ( fShadow == 0.f ) \r\n"	// 조건문	- 이곳은 Voxel 셋팅만 온다.
			"		{ \r\n"
			"			fShadow = 1.0f; \r\n"			// 그림자에 영향받지 않는 강도. 그림자 영향받으면 0, 아니면 1
			"			fNormalDot = dot( g_vLightDirViewSpace, vNor ); \r\n"
			"			fNormalDot += 1.f; \r\n"
			"			fNormalDot *= 0.5f; \r\n"		// Diffuse 의 내적. 좀더 입체적으로 보이기 위해 (-1~1) -> (0~1) 로 변경.
			"		} \r\n"
			"		else \r\n"	// 조건문
			"		{ \r\n"
			"			fNormalDot = saturate(dot( g_vLightDirViewSpace, vNor )); \r\n"
			"		} \r\n"
			"	\r\n"
			"		// HalfVector \r\n"
			"		float3 vHalf = -vPositionViewSpace.xyz; \r\n"
			"		vHalf = normalize( vHalf ); \r\n"
			"		vHalf += g_vLightDirViewSpace; \r\n"
			"		vHalf = normalize( vHalf ); \r\n"
			"	\r\n"
			"		float fLightAmount = fShadow; \r\n"
			"	\r\n"
			"		if ( nShadowMode == 1 ) \r\n"				// CSM#1(Depth깊이) + CSM#2(VSM)
			"		{ \r\n"
			"			float4 vShadowProjectionPos = mul(g_matInvView_Shadow_Clip2Tex, vPositionViewSpace); \r\n"
			"			float4 vShadowProjPos_2nd = mul(g_matInvView_Shadow_2nd_Clip2Tex, vPositionViewSpace); \r\n"

			//"			fLightAmount = VSM_FILTER( vShadowProjectionPos, ShadowTexSampler_CSM, length(g_vLightPosViewSpace-vPositionViewSpace.xyz) );  \r\n"
			//"			fLightAmount = ShadowContribution(ShadowTexSampler_CSM, vShadowProjectionPos, length(g_vLightPosViewSpace-vPositionViewSpace.xyz));  \r\n"

			"			float3 vPosWorldSpace; \r\n"
			"			vPosWorldSpace = mul(g_matInverseView, vPositionViewSpace); \r\n"

			"			float2 vLightAmountNEW = ShadowContribution(ShadowTexSampler_CSM_2, vShadowProjPos_2nd, length(g_vLightPosWorldSpace-vPosWorldSpace.xyz), g_vShadow.w );  \r\n"
			"			fLightAmount = (fLightAmount * vLightAmountNEW.y) + (vLightAmountNEW.x * (1.f-vLightAmountNEW.y));  \r\n"
			//"			vLightAmountNEW = CascadeShadow_Length( vShadowProjectionPos, ShadowTexSampler_CSM, length(g_vLightPosWorldSpace-vPosWorldSpace.xyz), g_vShadow.x, g_vShadow.z );  \r\n"
			"			vLightAmountNEW = CascadeShadow( vShadowProjectionPos, ShadowTexSampler_CSM, g_vShadow.x, g_vShadow.z );  \r\n"
			//"			vLightAmountNEW = PCF_SoftShadow( ShadowTexSampler_CSM, vShadowProjectionPos, length(g_vLightPosWorldSpace-vPosWorldSpace.xyz), g_vShadow.z ); \r\n"
			"			fLightAmount = (fLightAmount * vLightAmountNEW.y) + (vLightAmountNEW.x * (1.f-vLightAmountNEW.y));  \r\n"
			"		} \r\n"
			"		else \r\n"			// CSM#1,CharShadow (Depth깊이)
			"		{ \r\n"
			"			float4 vShadowProjectionPos = mul(g_matInvView_Shadow_Clip2Tex, vPositionViewSpace); \r\n"

			"			float3 vPosWorldSpace; \r\n"
			"			vPosWorldSpace = mul(g_matInverseView, vPositionViewSpace); \r\n"

			//"			float2 vLightAmountNEW = CascadeShadow_Length( vShadowProjectionPos, ShadowTexSampler, length(g_vLightPosWorldSpace-vPosWorldSpace.xyz), g_vShadow.x, g_vShadow.z );  \r\n"
			"			float2 vLightAmountNEW = CascadeShadow( vShadowProjectionPos, ShadowTexSampler, g_vShadow.x, g_vShadow.z );  \r\n"
			//"			float2 vLightAmountNEW = PCF_SoftShadow( ShadowTexSampler, vShadowProjectionPos, length(g_vLightPosWorldSpace-vPosWorldSpace.xyz), g_vShadow.z ); \r\n"
			"			fLightAmount = (fLightAmount * vLightAmountNEW.y) + (vLightAmountNEW.x * (1.f-vLightAmountNEW.y));  \r\n"
			"		} \r\n"
			"	\r\n"
			"		float fSpec = pow( saturate( dot( vHalf, vNor ) ), vSpecularCubemap.y) * vSpecularCubemap.x; \r\n"
			"		fNormalDot += fSpec;								// Add Specular \r\n"
			"	\r\n"
			"		fLightAmount *= fNormalDot; \r\n"
			"	\r\n"
			"		vAddColor += g_vLightDiffuse.xyz * fLightAmount; \r\n"
			"		vAddColor /= 3.f; \r\n"
			"	} \r\n"
			" \r\n"
			"	vOut.xyz = vAddColor; \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					M-Pass deffered \r\n"
			"float4 PS_MPASS_deffered_wld( VS_OUTPUT_QUAD In, uniform bool bSoftAlpha, uniform int nShadowMode ) : COLOR0  \r\n"
			"{ \r\n"
			"	// Texture \r\n"
			"	float4 vOut = tex2D( BackBufferSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	// Light Accumulation 값 얻기. \r\n"
			"	float3 vLColor = tex2D( BackBufferSampler_2nd, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	// Position 얻기. \r\n"
			"	float4 vPositionViewSpace = tex2D( BackBufferSampler_3rd, In.m_vTexCoord0 ); \r\n"
			"	vPositionViewSpace.w = 1.f; \r\n"
			" \r\n"
			"	vOut.xyz = vOut*vLColor*3.f; \r\n"
			" \r\n"
			"	if ( bSoftAlpha ) \r\n"
			"	{ \r\n"
			"		vOut.xyz *= 1.f / vOut.w; \r\n"
			"	} \r\n"

			"   if ( nShadowMode == 1 )\r\n"		// Z 값을 기준으로 계산함.
			"	{ \r\n"
			"		//------------------------------------------ ShadowMap \r\n"
			"		float4 vShadowProjectionPos = mul(g_matInvView_Shadow_Clip2Tex, vPositionViewSpace); \r\n"
			"	 \r\n"
			"		//transform from RT space to texture space. \r\n"
			"		float2 ShadowTexC = vShadowProjectionPos.xy / vShadowProjectionPos.w;  \r\n"
			//"		float2 ShadowTexC = 0.5 * vShadowProjectionPos.xy / vShadowProjectionPos.w + float2( 0.5, 0.5 ); \r\n"
			//"		ShadowTexC.y = 1.0f - ShadowTexC.y; \r\n"
			"	 \r\n"
			"		// transform to texel space \r\n"
			"		float2 texelpos = g_vShadow.x * ShadowTexC; \r\n"
			"	 \r\n"
			"		// Determine the lerp amounts      \r\n"      
			"		float2 lerps = frac( texelpos ); \r\n"
			"	 \r\n"
			"		//read in bilerp stamp, doing the shadow checks \r\n"
			"		float sourcevals[4]; \r\n"
			"		float fShadowProjZdivW = vShadowProjectionPos.z / vShadowProjectionPos.w; \r\n"
			"		sourcevals[0] = (tex2D( ShadowTexSampler, ShadowTexC ) + g_vShadow.y < fShadowProjZdivW)? g_vShadow.w: 1.0f; \r\n"
			"		sourcevals[1] = (tex2D( ShadowTexSampler, ShadowTexC + float2(g_vShadow.z, 0) ) + g_vShadow.y < fShadowProjZdivW)? g_vShadow.w: 1.0f; \r\n"
			"		sourcevals[2] = (tex2D( ShadowTexSampler, ShadowTexC + float2(0, g_vShadow.z) ) + g_vShadow.y < fShadowProjZdivW)? g_vShadow.w: 1.0f; \r\n"
			"		sourcevals[3] = (tex2D( ShadowTexSampler, ShadowTexC + float2(g_vShadow.z, g_vShadow.z) ) + g_vShadow.y < fShadowProjZdivW)? g_vShadow.w: 1.0f; \r\n"
			"	 \r\n"
			"		// lerp between the shadow values to calculate our light amount \r\n"
			"		float fLightAmount = lerp( lerp( sourcevals[0], sourcevals[1], lerps.x ), \r\n"
			" 								lerp( sourcevals[2], sourcevals[3], lerps.x ), \r\n"
			" 								lerps.y ); \r\n"
			"	 \r\n"
			"		// 끝부분이 어색한게 있어서 부드럽게 처리함. \r\n"
			"		float2 vLowUV = 1.f - saturate( ShadowTexC.xy * 5.f );		// UV 범위 0 ~ 0.2 ~ 1 -> 알파수치 1 ~ 0 ~ 0 로 변환 \r\n"
			"		float2 vHighUV = 1.f - saturate( (1.f-ShadowTexC.xy) * 5.f );	// UV 범위 0 ~ 0.8 ~ 1 -> 알파수치 0 ~ 0 ~ 1 로 변환 \r\n"
			"		fLightAmount += vLowUV.x + vLowUV.y + vHighUV.x + vHighUV.y; \r\n"
			"		fLightAmount = saturate(fLightAmount); \r\n"
			"	 \r\n"
			"		vOut.xyz *= fLightAmount; \r\n"
			"	} \r\n"
			//"   else if ( nShadowMode == 2 )\r\n"	// 거리값을 기준으로 계산함.
			//"	{ \r\n"
			//"		//------------------------------------------ ShadowMap \r\n"
			//"		float4 vShadowProjectionPos = mul(g_matInvView_Shadow_Clip2Tex, vPositionViewSpace); \r\n"
			//"	 \r\n"
			//"		//transform from RT space to texture space. \r\n"
			//"		float2 ShadowTexC = vShadowProjectionPos.xy / vShadowProjectionPos.w;  \r\n"
			////"		float2 ShadowTexC = 0.5 * vShadowProjectionPos.xy / vShadowProjectionPos.w + float2( 0.5, 0.5 ); \r\n"
			////"		ShadowTexC.y = 1.0f - ShadowTexC.y; \r\n"
			//"	 \r\n"
			//"		// transform to texel space \r\n"
			//"		float2 texelpos = g_vShadow.x * ShadowTexC; \r\n"
			//"	 \r\n"
			//"		// Determine the lerp amounts      \r\n"      
			//"		float2 lerps = frac( texelpos ); \r\n"
			//"	 \r\n"
			//"		float3 vPosWorldSpace; \r\n"
			//"		vPosWorldSpace = mul(g_matInverseView, vPositionViewSpace); \r\n"

			//"		//read in bilerp stamp, doing the shadow checks \r\n"
			//"		float sourcevals[4]; \r\n"
			//"		float fShadowProjZdivW = length(g_vLightPosWorldSpace-vPosWorldSpace.xyz); \r\n"
			//"		sourcevals[0] = (tex2D( ShadowTexSampler, ShadowTexC ) + g_vShadow.y < fShadowProjZdivW)? g_vShadow.w: 1.0f; \r\n"
			//"		sourcevals[1] = (tex2D( ShadowTexSampler, ShadowTexC + float2(g_vShadow.z, 0) ) + g_vShadow.y < fShadowProjZdivW)? g_vShadow.w: 1.0f; \r\n"
			//"		sourcevals[2] = (tex2D( ShadowTexSampler, ShadowTexC + float2(0, g_vShadow.z) ) + g_vShadow.y < fShadowProjZdivW)? g_vShadow.w: 1.0f; \r\n"
			//"		sourcevals[3] = (tex2D( ShadowTexSampler, ShadowTexC + float2(g_vShadow.z, g_vShadow.z) ) + g_vShadow.y < fShadowProjZdivW)? g_vShadow.w: 1.0f; \r\n"
			//"	 \r\n"
			//"		// lerp between the shadow values to calculate our light amount \r\n"
			//"		float fLightAmount = lerp( lerp( sourcevals[0], sourcevals[1], lerps.x ), \r\n"
			//" 								lerp( sourcevals[2], sourcevals[3], lerps.x ), \r\n"
			//" 								lerps.y ); \r\n"
			//"	 \r\n"
			//"		// 끝부분이 어색한게 있어서 부드럽게 처리함. \r\n"
			//"		float2 vLowUV = 1.f - saturate( ShadowTexC.xy * 5.f );		// UV 범위 0 ~ 0.2 ~ 1 -> 알파수치 1 ~ 0 ~ 0 로 변환 \r\n"
			//"		float2 vHighUV = 1.f - saturate( (1.f-ShadowTexC.xy) * 5.f );	// UV 범위 0 ~ 0.8 ~ 1 -> 알파수치 0 ~ 0 ~ 1 로 변환 \r\n"
			//"		fLightAmount += vLowUV.x + vLowUV.y + vHighUV.x + vHighUV.y; \r\n"
			//"		fLightAmount = saturate(fLightAmount); \r\n"
			//"	 \r\n"
			//"		vOut.xyz *= fLightAmount; \r\n"
			//"	} \r\n"

			" \r\n"
			"	float fFog = saturate((g_vFOG.x - vPositionViewSpace.z) / g_vFOG.y); \r\n"
			"	vOut.xyz = (vOut.xyz*fFog) + g_vFogColor*(1.f-fFog); \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//				ExportFloatToVector2 \r\n"
			" float2 ExportFloatToVector2( float fValue ) \r\n"	
			" { \r\n"
			"   fValue = fValue * 65535.f; \r\n"
			"   float2 vOut; \r\n"
			"	vOut.x = floor( fValue / 256.f ); \r\n"	// >>8 한다는 개념으로.
			"	vOut.x /= 255.f; \r\n"
			"	vOut.y = frac( fValue / 256.f ); \r\n"	// >>8 가 당해진 값들을 얻는다. 퀄리티 차이랑 속도를 생각해서 /255 를 하지는 말자.
			//"	vOut.y = frac( fValue / 256.f ) / 255.f; \r\n"	// >>8 가 당해진 값들을 얻는다.	/ 255.f 를 하는건 0~1 값을 얻기 위함.
			"	return vOut; \r\n"
			" } \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//				TOOL		M-Pass deffered \r\n"
			// nShadowInIndoor : 0 - OutDoor, 1 - Indoor(NM), 2 - Indoor(CSM)
			"float4 PS_MPASS_deffered_csm( VS_OUTPUT_QUAD In, uniform bool bSoftAlpha, uniform int nShadowInIndoor ) : COLOR0  \r\n"
			"{ \r\n"
			"	// Texture \r\n"
			"	float4 vOut = tex2D( BackBufferSampler, In.m_vTexCoord0 ); \r\n"
			" \r\n"
			"	// Light Accumulation 값 얻기. \r\n"
			"	float4 vNorOrig; \r\n"
			"	float3 vLColor = tex2D( BackBufferSampler_4th, In.m_vTexCoord0 ).xyz; \r\n"
			"	vNorOrig.wx = ExportFloatToVector2( vLColor.y ); \r\n"
			"	vNorOrig.yz = ExportFloatToVector2( vLColor.z ); \r\n"
			"	vNorOrig.xyz = vNorOrig.xyz*2.f-1.f; \r\n"
			"	vLColor.xy = ExportFloatToVector2( vLColor.x ); \r\n"
			"	vLColor.z = vNorOrig.w; \r\n"
			" \r\n"
			"	// Normal Vector 얻기. \r\n"
			"	float3 vNor = tex2D( BackBufferSampler_2nd, In.m_vTexCoord0 ); \r\n"
			"	vNor = normalize( vNor ); \r\n"
			" \r\n"
			"	float fBaseDot = dot( g_vLightDirViewSpace, normalize( vNorOrig.xyz ) ); \r\n"
			"	float fNormalDot = dot( g_vLightDirViewSpace, vNor ); \r\n"
			"	fNormalDot = (fNormalDot - fBaseDot)*1.f; \r\n" 
			"	fNormalDot = max( fNormalDot, -1.f ) + 1.f;     // -1~1 -> 0~2 \r\n"
			"	vLColor *= fNormalDot; \r\n" 
			" \r\n"
			//"	vLColor += tex2D( BackBufferSampler_LBuffer, In.m_vTexCoord0 ); \r\n"
			"	float3 vSpotLightRT = tex2D( BackBufferSampler_LBuffer, In.m_vTexCoord0 ); \r\n"
			"	vLColor += vSpotLightRT; \r\n"
			"	vLColor *= 3.f; \r\n"
			" \r\n"
			"	// Specular, CubeMap Factor 얻기. \r\n"
			"	float3 vSpecularCubemap = tex2D( BackBufferSampler_3rd, In.m_vTexCoord0 ).xyz; \r\n"
			"	vSpecularCubemap.x *= 2.f; \r\n"
			"	vSpecularCubemap.y *= 256.f; \r\n"
			" \r\n"
			"	// Get the depth buffer value at this pixel. \r\n"
			"	float zOverW = tex2D( DepthBufferSampler, In.m_vTexCoord0 ).x; \r\n"
			"	// H is the viewport position at this pixel in the range -1 to 1. \r\n"
			"	float4 H = float4(In.m_vTexCoord0.x * 2 - 1, (1 - In.m_vTexCoord0.y) * 2 - 1, zOverW, 1); \r\n"
			"	// Transform by the view-projection inverse. \r\n"
			"	float4 D = mul(g_matInverseProj, H); \r\n"
			"	// Divide by w to get the world position. \r\n"
			"	float4 vPositionViewSpace = D / D.w; \r\n"
			"	vPositionViewSpace.w = 1.f; \r\n"
			" \r\n"
			"	// CubMap 작업. \r\n"
			"	float3 vEyeToVector = normalize(vPositionViewSpace.xyz); \r\n"
			"	float3 vCubeTexcoord = reflect(vEyeToVector, vNor); \r\n"
			"	vCubeTexcoord = mul(g_matInverseView, vCubeTexcoord); \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMapMask \r\n"
			"	float fCubeMapValue = vSpecularCubemap.z; \r\n"
			" \r\n"
			"	//------------------------------------------ CubeMap \r\n"
			"	{ \r\n"
			"		vOut.xyz = vOut.xyz*(1.f-fCubeMapValue) + texCUBE( CubeTexSampler, vCubeTexcoord ).xyz * fCubeMapValue; \r\n"
			"	} \r\n"
			" \r\n"
			"	vOut.xyz = vOut*vLColor; \r\n"
			" \r\n"
			"	if ( bSoftAlpha ) \r\n"
			"	{ \r\n"
			"		vOut.xyz *= 1.f / vOut.w; \r\n"
			"	} \r\n"
			" \r\n"
			"   if ( nShadowInIndoor != 0 ) \r\n"		// Z 값을 기준으로 계산함. 실내맵일 경우
			"	{ \r\n"
			"		//------------------------------------------ ShadowMap \r\n"
			"		float4 vShadowProjectionPos = mul(g_matInvView_Shadow_Clip2Tex, vPositionViewSpace); \r\n"
			"	 \r\n"
			"		//transform from RT space to texture space. \r\n"
			"		float2 ShadowTexC = vShadowProjectionPos.xy / vShadowProjectionPos.w;  \r\n"
			"	 \r\n"
			"		// transform to texel space \r\n"
			"		float2 texelpos = g_vShadow.x * ShadowTexC; \r\n"
			"	 \r\n"
			"		// Determine the lerp amounts      \r\n"      
			"		float2 lerps = frac( texelpos ); \r\n"
			"	 \r\n"
			"		//read in bilerp stamp, doing the shadow checks \r\n"
			"		float sourcevals[4]; \r\n"
			"		float fShadowProjZdivW = vShadowProjectionPos.z / vShadowProjectionPos.w; \r\n"
			"		float fShadowColor = g_vShadow.w; \r\n"
			"		if ( nShadowInIndoor == 2 ) \r\n"
			"		{ \r\n"
			"			fShadowColor = min ( 1.f, max ( g_vShadow.w, (vSpotLightRT.x + vSpotLightRT.y + vSpotLightRT.z)*3.f ) ); \r\n"
			"		} \r\n"
			"		sourcevals[0] = (tex2D( ShadowTexSampler, ShadowTexC ) + g_vShadow.y < fShadowProjZdivW)? fShadowColor: 1.0f; \r\n"
			"		sourcevals[1] = (tex2D( ShadowTexSampler, ShadowTexC + float2(g_vShadow.z, 0) ) + g_vShadow.y < fShadowProjZdivW)? fShadowColor: 1.0f; \r\n"
			"		sourcevals[2] = (tex2D( ShadowTexSampler, ShadowTexC + float2(0, g_vShadow.z) ) + g_vShadow.y < fShadowProjZdivW)? fShadowColor: 1.0f; \r\n"
			"		sourcevals[3] = (tex2D( ShadowTexSampler, ShadowTexC + float2(g_vShadow.z, g_vShadow.z) ) + g_vShadow.y < fShadowProjZdivW)? fShadowColor: 1.0f; \r\n"
			"	 \r\n"
			"		// lerp between the shadow values to calculate our light amount \r\n"
			"		float fLightAmount = lerp( lerp( sourcevals[0], sourcevals[1], lerps.x ), \r\n"
			" 								lerp( sourcevals[2], sourcevals[3], lerps.x ), \r\n"
			" 								lerps.y ); \r\n"
			"	 \r\n"
			"		// 끝부분이 어색한게 있어서 부드럽게 처리함. \r\n"
			"		float2 vLowUV = 1.f - saturate( ShadowTexC.xy * 5.f );		// UV 범위 0 ~ 0.2 ~ 1 -> 알파수치 1 ~ 0 ~ 0 로 변환 \r\n"
			"		float2 vHighUV = 1.f - saturate( (1.f-ShadowTexC.xy) * 5.f );	// UV 범위 0 ~ 0.8 ~ 1 -> 알파수치 0 ~ 0 ~ 1 로 변환 \r\n"
			"		fLightAmount += vLowUV.x + vLowUV.y + vHighUV.x + vHighUV.y; \r\n"
			"		fLightAmount = saturate(fLightAmount); \r\n"
			"	 \r\n"
			"		vOut.xyz *= fLightAmount; \r\n"
			"	} \r\n"
			" \r\n"
			"	float fFog = saturate((g_vFOG.x - vPositionViewSpace.z) / g_vFOG.y); \r\n"
			"	vOut.xyz = (vOut.xyz*fFog) + g_vFogColor*(1.f-fFog); \r\n"
			" \r\n"
			"	return vOut; \r\n"
			"} \r\n"
			" \r\n"
			"//---------------------------------------------------------------------------------------------------------- \r\n"
			"//					technique \r\n"
			" \r\n"
			"technique game \r\n"
			"{ \r\n"
			"	pass light_accumulation_sun_pass \r\n"	// 0			// CSM#1, CharShadow(Depth깊이)
			"	{ \r\n"
			"		PixelShader = compile ps_3_0 PS_LSPASS(0); \r\n"
			"	} \r\n"
			"	pass light_accumulation_sun_CSM_pass_VSM \r\n"	// 1	// CSM#1(Depth깊이) + CSM#2(VSM)
			"	{ \r\n"
			"		PixelShader = compile ps_3_0 PS_LSPASS(1); \r\n"
			"	} \r\n"
			"	pass material_pass_deffered_wld1 \r\n"	// 2		// 그림자 없음.
			"	{ \r\n"
			"		PixelShader = compile ps_3_0 PS_MPASS_deffered_wld( false, 0 ); \r\n"
			"	} \r\n"
			"	pass material_pass_deffered_wld2 \r\n"	// 3		// 그림자 없음.
			"	{ \r\n"
			"		PixelShader = compile ps_3_0 PS_MPASS_deffered_wld( true, 0 ); \r\n"
			"	} \r\n"
			"	pass material_pass_deffered_wld3 \r\n"	// 4		// Z 값을 기준으로 계산함.
			"	{ \r\n"
			"		PixelShader = compile ps_3_0 PS_MPASS_deffered_wld( false, 1 ); \r\n"
			"	} \r\n"
			"	pass material_pass_deffered_wld4 \r\n"	// 5		// Z 값을 기준으로 계산함.
			"	{ \r\n"
			"		PixelShader = compile ps_3_0 PS_MPASS_deffered_wld( true, 1 ); \r\n"
			"	} \r\n"
			"	pass material_pass_deffered_csm1 \r\n"	// 6	// 전통 CSM
			"	{ \r\n"
			"		PixelShader = compile ps_3_0 PS_MPASS_deffered_csm( false, 0 ); \r\n"
			"	} \r\n"
			"	pass material_pass_deffered_csm2 \r\n"	// 7	// 전통 CSM
			"	{ \r\n"
			"		PixelShader = compile ps_3_0 PS_MPASS_deffered_csm( true, 0 ); \r\n"
			"	} \r\n"
			"	pass material_pass_deffered_csm1_Indoor \r\n"	// 8	// CSM 이 아닌 기본 Shadow 를 렌더링 한다.
			"	{ \r\n"
			"		PixelShader = compile ps_3_0 PS_MPASS_deffered_csm( false, 1 ); \r\n"
			"	} \r\n"
			"	pass material_pass_deffered_csm2_Indoor \r\n"	// 9	// CSM 이 아닌 기본 Shadow 를 렌더링 한다.
			"	{ \r\n"
			"		PixelShader = compile ps_3_0 PS_MPASS_deffered_csm( true, 1 ); \r\n"
			"	} \r\n"
			"	pass material_pass_deffered_csm1_Indoor_spotlightrt \r\n"	// 10	// SpotLightRT 에 들어갈시 CSM 이 아닌 기본 Shadow 를 FadeOut 한다.
			"	{ \r\n"
			"		PixelShader = compile ps_3_0 PS_MPASS_deffered_csm( false, 2 ); \r\n"
			"	} \r\n"
			"	pass material_pass_deffered_csm2_Indoor_spotlightrt \r\n"	// 11	// SpotLightRT 에 들어갈시 CSM 이 아닌 기본 Shadow 를 FadeOut 한다.
			"	{ \r\n"
			"		PixelShader = compile ps_3_0 PS_MPASS_deffered_csm( true, 2 ); \r\n"
			"	} \r\n"
			"}; \r\n"
			" \r\n";
	}
};

